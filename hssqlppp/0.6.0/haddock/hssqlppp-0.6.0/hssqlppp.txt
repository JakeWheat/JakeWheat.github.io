-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SQL parser and type checker
--   
--   SQL parser and type checker, targets PostgreSQL SQL and PL/pgSQL.
--   
--   Pre alpha: works well and is stable for a subset of SQL, but there are
--   lots of unfinished areas and the api is likely to change a lot from
--   release to release at this time.
--   
--   Documentation, examples on the homepage:
--   <a>http://jakewheat.github.com/hssqlppp/</a>.
--   
--   Changes here:
--   <a>https://github.com/JakeWheat/hssqlppp/blob/master/CHANGES</a>
@package hssqlppp
@version 0.6.0


-- | Contains the SQL data types, type errors, and a few supporting
--   functions.
module Database.HsSqlPpp.Types

-- | Standard types of things. This covers all the usual postgres types
--   plus some extra ones added for use by the hssqlppp typechecker
data Type

-- | basic type of a scalar value. These are either built in types in
--   postgres, or implemented in C or similar
ScalarType :: Text -> Type

-- | a domain type is used for a constraint on a table column which would
--   used on multiple columns on a table or in multiple tables, using a
--   domain type is a way of just writing the constraint once
DomainType :: Text -> Type

-- | enum type, not really supported in hssqlppp yet
EnumType :: Text -> Type

-- | String literals in postgres have an unknown type. The effective type
--   is determined using what seems to amount to some simple ad hoc rules
--   based on the context of the string literal. Hssqlppp also treats ?
--   placeholders and nulls the same way, so they have UnknownType, not
--   sure how closely this matches postgres
UnknownType :: Type

-- | postgres automatically creates an array type for every scalar type
--   (plus some other types?) If there is no array type for a type in the
--   catalog, then you can't work with arrays of that type
ArrayType :: Type -> Type

-- | refer to composite type in catalog by name. not sure if this needs to
--   exist along with CompositeType
NamedCompositeType :: Text -> Type

-- | refer to composite type by structure
CompositeType :: [(Text, TypeExtra)] -> Type

-- | CompositeTypeExtra [(Text,TypeExtra)] | hack to support the
--   environment for a tref
TrefType :: [((Text, Text), TypeExtra)] -> Type

-- | the fields are anonymous as well as the type itself
AnonymousCompositeType :: [Type] -> Type

-- | The pseudo type is used for types which only appear as argument or
--   return types in function definitions and/or are used only in plpgsql
--   and not regular sql. hssqlppp also follows this usage for the types
--   used in hssqlppp which don't have an exact counterpart in postgres
Pseudo :: PseudoType -> Type

-- | Quick fix to add precision and nullable information to the annotation
--   types. This approach should be revisited, maybe this information
--   should be in the Type type?
data TypeExtra
TypeExtra :: Type -> Maybe Int -> Maybe Int -> Bool -> TypeExtra
[teType] :: TypeExtra -> Type
[tePrecision] :: TypeExtra -> Maybe Int
[teScale] :: TypeExtra -> Maybe Int
[teNullable] :: TypeExtra -> Bool

-- | Pseudo types: mainly used for the argument and return types of
--   functions. The weird undocumented types are just used to represent
--   functions with those types which are in the postgres default catalog
data PseudoType

-- | setof is used for set returning functions
SetOfType :: Type -> PseudoType

-- | used to represent polymorphic functions, all the AnyElement parameters
--   and the return type if AnyElement must be the same type for a given
--   function call invocation.
AnyElement :: PseudoType

-- | like AnyElement, but the type must be an array type
AnyArray :: PseudoType

-- | like AnyElement, but the type must be an enum type
AnyEnum :: PseudoType

-- | like AnyElement, but the type must be a non array type
AnyNonArray :: PseudoType
AnyRange :: PseudoType

-- | Any drops the restriction that all the Any types must be the same type
Any :: PseudoType

-- | record types are used in plpgsql for a sort of dynamic typing or rough
--   polymorphism substitute. They can refer to values of named composite
--   type, composite type or anonymous composite type, not sure if non
--   composite types as well.
Record :: (Maybe Type) -> PseudoType

-- | presumably used for the types of OLD and NEW in a trigger function.
--   Hssqlppp will probably use the Record type above for these. |
--   TriggerRecord | Trigger | cstring - a C string | Cstring | represents
--   the return type of a function which doesn't return anything. Not sure
--   if it is used anywhere else
Void :: PseudoType
data TypeError
NoMatchingOperator :: Text -> [Type] -> TypeError
AmbiguousOperator :: Text -> [Type] -> TypeError
TypelessEmptyArray :: TypeError
IncompatibleTypeSet :: [Type] -> TypeError
IncompatibleTypes :: Type -> Type -> TypeError
WrongNumberOfColumns :: TypeError
WrongTypes :: Type -> [Type] -> TypeError
IncompatibleUnionTypes :: Type -> Type -> TypeError
TypeAlreadyExists :: Type -> TypeError
SchemaAlreadyExists :: Text -> TypeError
BadCatalogUpdate :: Text -> TypeError
UnrecognisedRelation :: (Text, Text) -> TypeError
DomainDefNotFound :: Type -> TypeError
TypeNotKnown :: Type -> TypeError
UnknownTypeName :: Text -> TypeError
UnrecognisedIdentifier :: Text -> TypeError
UnrecognisedCorrelationName :: Text -> TypeError
SchemadColumnName :: Text -> TypeError
DbSchemadColumnName :: Text -> TypeError
BadStarExpand :: TypeError
InternalError :: String -> TypeError
AmbiguousIdentifier :: Text -> TypeError
OdbcFuncBadContent :: TypeError
DuplicateColumnName :: Text -> TypeError
TooManyColumnsInInsert :: TypeError

module Database.HsSqlPpp.Lex

-- | Represents a lexed token
data Token

-- | a symbol in postgresql dialect is one of the following:
--   
--   <ul>
--   <li>one of the characters (),;[]{} (the {} is for odbc)</li>
--   <li>'..' or ':=' or '.' or ':'</li>
--   <li>a compound symbol, which starts with one of
--   '*/&lt;&gt;=~!@%^&amp;|`?'</li>
--   </ul>
--   
--   things that are not lexed as symbols:
--   
--   <ul>
--   <li>[] used in quoted identifiers, prefix @,#,: used in
--   identifiers</li>
--   <li>$n positional arg</li>
--   </ul>
Symbol :: String -> Token

-- | This is an identifier or keyword.
--   
--   The 'Maybe (Char,Char)' selects the quoted style - <a>Nothing</a>
--   means the identifier was unquoted otherwise the two characters are the
--   start and end quote.
--   
--   '"' is used to quote identifiers in standard sql, sql server also uses
--   [brackets] to quote identifiers.
--   
--   The identifier also includes the 'variable marker prefix' used in sql
--   server (e.g. @identifier, #identifier), and oracle (e.g. :identifier)
Identifier :: (Maybe (String, String)) -> String -> Token
PrefixedVariable :: Char -> String -> Token

-- | a postgresql positional arg, e.g. $1
PositionalArg :: Int -> Token

-- | This is a string literal.
--   
--   The first field is the quotes used: single quote (') for normal
--   strings, E' for escape supporting strings, and $$ delimiter for
--   postgresql dollar quoted strings.
--   
--   The lexer doesn't process the escapes in strings, but passes on the
--   literal source e.g. E'\n' parses to SqlString "E'" "\n" with the
--   literal characters '\' and 'n' in the string, not a newline character.
--   quotes within a string ('') or escaped string ('' or \') are passed
--   through unchanged
SqlString :: String -> String -> String -> Token

-- | a number literal (integral or otherwise), stored in original format
--   unchanged
SqlNumber :: String -> Token

-- | non-significant whitespace (space, tab, newline) (strictly speaking,
--   it is up to the client to decide whether the whitespace is significant
--   or not)
Whitespace :: String -> Token

-- | a commented line using --, contains every character starting with the
--   '--' and including the terminating newline character if there is one -
--   this will be missing if the last line in the source is a line comment
--   with no trailing newline
LineComment :: String -> Token

-- | a block comment, /* stuff */, includes the comment delimiters
BlockComment :: String -> Token

-- | an antiquotation splice, e.g. $x(stuff)
Splice :: Char -> String -> Token

-- | the copy data in a copy from stdin
CopyPayload :: String -> Token

-- | Accurate pretty printing, if you lex a bunch of tokens, then pretty
--   print them, should should get back exactly the same string
prettyToken :: Dialect -> Token -> String

-- | parser for a sql token
lexToken :: Dialect -> Parser ((FilePath, Int, Int), Token)
lexTokens :: Dialect -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseError [((FilePath, Int, Int), Token)]
data Dialect
Dialect :: String -> SyntaxFlavour -> [(Text, [Text])] -> [Text] -> [Text] -> [Text] -> [(Text, Text)] -> Catalog -> Dialect
[diName] :: Dialect -> String
[diSyntaxFlavour] :: Dialect -> SyntaxFlavour
[diCanonicalTypeNames] :: Dialect -> [(Text, [Text])]
[diTextTypes] :: Dialect -> [Text]
[diDatetimeTypes] :: Dialect -> [Text]
[diNumberTypes] :: Dialect -> [Text]
[namesForAnsiTypes] :: Dialect -> [(Text, Text)]
[diDefaultCatalog] :: Dialect -> Catalog
ansiDialect :: Dialect

module Database.HsSqlPpp.Dialect
data Dialect
Dialect :: String -> SyntaxFlavour -> [(Text, [Text])] -> [Text] -> [Text] -> [Text] -> [(Text, Text)] -> Catalog -> Dialect
[diName] :: Dialect -> String
[diSyntaxFlavour] :: Dialect -> SyntaxFlavour
[diCanonicalTypeNames] :: Dialect -> [(Text, [Text])]
[diTextTypes] :: Dialect -> [Text]
[diDatetimeTypes] :: Dialect -> [Text]
[diNumberTypes] :: Dialect -> [Text]
[namesForAnsiTypes] :: Dialect -> [(Text, Text)]
[diDefaultCatalog] :: Dialect -> Catalog
data SyntaxFlavour
Ansi :: SyntaxFlavour
Postgres :: SyntaxFlavour
SqlServer :: SyntaxFlavour
Oracle :: SyntaxFlavour
ansiDialect :: Dialect
postgresDialect :: Dialect
sqlServerDialect :: Dialect
oracleDialect :: Dialect
canonicalizeTypeName :: Dialect -> Text -> Text
ansiTypeNameToDialect :: Dialect -> Text -> Maybe Text


-- | This module contains the database catalog data types and helper
--   functions.
--   
--   The catalog data type holds the catalog information needed to type
--   check sql code, and a catalog value is produced after typechecking sql
--   which represents the catalog that would be produced (e.g. for sql
--   containing ddl)
--   
--   You can create a catalog using the <a>CatalogUpdate</a> type, and
--   there is example and util in the repo which reads a catalog from an
--   existing database in postgres.
module Database.HsSqlPpp.Catalog

-- | The main datatype, this holds the catalog and context information to
--   type check against.
data Catalog
data CatalogUpdate

-- | register a schema with the given name
CatCreateSchema :: CatName -> CatalogUpdate

-- | register a base scalar type with the given name
CatCreateScalarType :: CatName -> CatalogUpdate

-- | register a domain type with name and base type
CatCreateDomainType :: CatName -> CatName -> CatalogUpdate

-- | register an array type with name and base type
CatCreateArrayType :: CatName -> CatName -> CatalogUpdate

-- | register a prefix op, opname, param type, return type
CatCreatePrefixOp :: CatName -> CatName -> CatName -> CatalogUpdate

-- | register a postfix op, opname, param type, return type
CatCreatePostfixOp :: CatName -> CatName -> CatName -> CatalogUpdate

-- | register a binary op, opname, the two param types, return type
CatCreateBinaryOp :: CatName -> CatName -> CatName -> CatName -> CatalogUpdate

-- | register a function: name, param types, retsetof, return type
CatCreateFunction :: CatName -> [CatName] -> Bool -> CatName -> CatalogUpdate

-- | register a variadic function: name, param types, retsetof, return type
--   the last parameter will be wrapped in an array type
CatCreateVariadicFunction :: CatName -> [CatName] -> Bool -> CatName -> CatalogUpdate

-- | special ops include between, substring, position, basically all
--   operators/functions which use mixfix or extra syntax (not including
--   non scalar functions like aggregates)
CatCreateSpecialOp :: CatName -> [CatName] -> Bool -> CatName -> CatalogUpdate

-- | register a aggregate: name, param types, return type
CatCreateAggregate :: CatName -> [CatName] -> CatName -> CatalogUpdate

-- | register a table only: name, (colname,typename) pairs
CatCreateTable :: (CatName, CatName) -> [(CatName, CatNameExtra)] -> CatalogUpdate

-- | register a cast in the catalog
CatCreateCast :: CatName -> CatName -> CastContext -> CatalogUpdate

-- | register a type category for a type (used in the implicit cast
--   resolution)
CatCreateTypeCategoryEntry :: CatName -> (Text, Bool) -> CatalogUpdate

-- | Use to note what the flavour of a cast is, i.e. if/when it can be used
--   implicitly.
data CastContext
ImplicitCastContext :: CastContext
AssignmentCastContext :: CastContext
ExplicitCastContext :: CastContext
data CompositeFlavour
Composite :: CompositeFlavour
TableComposite :: CompositeFlavour
ViewComposite :: CompositeFlavour

-- | represents the name of something in the catalog, when schema support
--   is added then this will change to (String,String)
type CatName = Text

-- | type name and precision and nullability
data CatNameExtra
CatNameExtra :: CatName -> Maybe Int -> Maybe Int -> Bool -> CatNameExtra
[catName] :: CatNameExtra -> CatName
[catPrecision] :: CatNameExtra -> Maybe Int
[catScale] :: CatNameExtra -> Maybe Int
[catNullable] :: CatNameExtra -> Bool
mkCatNameExtra :: CatName -> CatNameExtra
mkCatNameExtraNN :: CatName -> CatNameExtra

-- | Applies a list of <a>CatalogUpdate</a>s to an <a>Catalog</a> value to
--   produce a new Catalog value. TODO: there will be a split between the
--   individual low level updates which just update one <tt>row</tt> in the
--   catalog type, and the high level updates which correspond to ddl (e.g.
--   create type will also add the array type, create table will add a
--   table, supply the private columns automatically, and add the composite
--   type) highlevel not implemented yet. You must use the correct case and
--   the canonical names for identifiers/types
updateCatalog :: [CatalogUpdate] -> Catalog -> Either [TypeError] Catalog
deconstructCatalog :: Catalog -> [CatalogUpdate]

-- | Represent an environment using an abstracted version of the syntax
--   which produced the environment. This structure has all the catalog
--   queries resolved. No attempt is made to combine environment parts from
--   different sources, they are just stacked together, the logic for
--   working with combined environments is in the query functions below
data Environment

-- | represents type check failure upstream, don't produce additional type
--   check errors
brokeEnvironment :: Environment
envSelectListEnvironment :: [(Text, TypeExtra)] -> Either [TypeError] Environment


-- | Functions to parse SQL.
module Database.HsSqlPpp.Parse

-- | Parse a list of statements
parseStatements :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra [Statement]

-- | Parse a list of procedural sql statements
parseProcSQL :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra [Statement]

-- | Parse a single query expr
parseQueryExpr :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra QueryExpr

-- | Parse a single scalar expr
parseScalarExpr :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra ScalarExpr

-- | Settings to influence the parsing
data ParseFlags
ParseFlags :: Dialect -> ParseFlags
[pfDialect] :: ParseFlags -> Dialect
defaultParseFlags :: ParseFlags
data Dialect
Dialect :: String -> SyntaxFlavour -> [(Text, [Text])] -> [Text] -> [Text] -> [Text] -> [(Text, Text)] -> Catalog -> Dialect
[diName] :: Dialect -> String
[diSyntaxFlavour] :: Dialect -> SyntaxFlavour
[diCanonicalTypeNames] :: Dialect -> [(Text, [Text])]
[diTextTypes] :: Dialect -> [Text]
[diDatetimeTypes] :: Dialect -> [Text]
[diNumberTypes] :: Dialect -> [Text]
[namesForAnsiTypes] :: Dialect -> [(Text, Text)]
[diDefaultCatalog] :: Dialect -> Catalog
ansiDialect :: Dialect

-- | Simple wrapper to allow showing the source context of a ParseError
data ParseErrorExtra
ParseErrorExtra :: ParseError -> Maybe (Int, Int) -> Text -> ParseErrorExtra

-- | wrapped error
[parseErrorError] :: ParseErrorExtra -> ParseError

-- | source position adjustment to get the context bit in error messages
--   right - this is the same as what is passed into parseSqlWithPosition
[parseErrorPosition] :: ParseErrorExtra -> Maybe (Int, Int)

-- | sql source
[parseErrorSqlSource] :: ParseErrorExtra -> Text
parseName :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra Name
parseNameComponent :: ParseFlags -> FilePath -> Maybe (Int, Int) -> Text -> Either ParseErrorExtra NameComponent


-- | This module contains the ast node data types. They are very
--   permissive, in that they allow a lot of invalid SQL to be represented.
--   The type checking process should catch all invalid trees, but doesn't
--   quite manage at the moment. Sorry about all the seemingly pointless
--   type synonyms below, they are an artefact of using UUAGC. You can see
--   labels for the fields by looking at the ag source here:
--   <a>https://github.com/JakeWheat/hssqlppp/blob/master/src/Database/HsSqlPpp/Internals/AstInternal.ag</a>
module Database.HsSqlPpp.Syntax
data Name
Name :: (Annotation) -> (([NameComponent])) -> Name
AntiName :: (String) -> Name
data NameComponent
Nmc :: String -> NameComponent
QNmc :: String -> NameComponent
AntiNameComponent :: String -> NameComponent
nameComponents :: Name -> [NameComponent]
ncStr :: NameComponent -> String
data TypeName
SimpleTypeName :: (Annotation) -> (Name) -> TypeName
PrecTypeName :: (Annotation) -> (Name) -> (Integer) -> TypeName
Prec2TypeName :: (Annotation) -> (Name) -> (Integer) -> (Integer) -> TypeName
ArrayTypeName :: (Annotation) -> (TypeName) -> TypeName
SetOfTypeName :: (Annotation) -> (TypeName) -> TypeName
data ScalarExpr
NumberLit :: (Annotation) -> (String) -> ScalarExpr
StringLit :: (Annotation) -> (String) -> ScalarExpr
NullLit :: (Annotation) -> ScalarExpr
BooleanLit :: (Annotation) -> (Bool) -> ScalarExpr
TypedStringLit :: (Annotation) -> (TypeName) -> (String) -> ScalarExpr
Interval :: (Annotation) -> (String) -> (IntervalField) -> ((Maybe Int)) -> ScalarExpr
Identifier :: (Annotation) -> (Name) -> ScalarExpr
Star :: (Annotation) -> ScalarExpr
QStar :: (Annotation) -> (NameComponent) -> ScalarExpr
PositionalArg :: (Annotation) -> (Integer) -> ScalarExpr
Placeholder :: (Annotation) -> ScalarExpr
PrefixOp :: (Annotation) -> (Name) -> (ScalarExpr) -> ScalarExpr
PostfixOp :: (Annotation) -> (Name) -> (ScalarExpr) -> ScalarExpr
BinaryOp :: (Annotation) -> (Name) -> (ScalarExpr) -> (ScalarExpr) -> ScalarExpr
SpecialOp :: (Annotation) -> (Name) -> (ScalarExprList) -> ScalarExpr
Extract :: (Annotation) -> (ExtractField) -> (ScalarExpr) -> ScalarExpr
App :: (Annotation) -> (Name) -> (ScalarExprList) -> ScalarExpr
AggregateApp :: (Annotation) -> (Distinct) -> (ScalarExpr) -> (ScalarExprDirectionPairList) -> ScalarExpr
WindowApp :: (Annotation) -> (ScalarExpr) -> (ScalarExprList) -> (ScalarExprDirectionPairList) -> ((Maybe FrameClause)) -> ScalarExpr
Cast :: (Annotation) -> (ScalarExpr) -> (TypeName) -> ScalarExpr
ImplicitCast :: (Annotation) -> (ScalarExpr) -> (TypeExtra) -> ScalarExpr
Case :: (Annotation) -> (CaseScalarExprListScalarExprPairList) -> (MaybeScalarExpr) -> ScalarExpr
CaseSimple :: (Annotation) -> (ScalarExpr) -> (CaseScalarExprListScalarExprPairList) -> (MaybeScalarExpr) -> ScalarExpr
Parens :: (Annotation) -> (ScalarExpr) -> ScalarExpr
InPredicate :: (Annotation) -> (ScalarExpr) -> (Bool) -> (InList) -> ScalarExpr
Exists :: (Annotation) -> (QueryExpr) -> ScalarExpr
ScalarSubQuery :: (Annotation) -> (QueryExpr) -> ScalarExpr
LiftApp :: (Annotation) -> (Name) -> (LiftFlavour) -> (ScalarExprList) -> ScalarExpr
OdbcLiteral :: (Annotation) -> (OdbcLiteralType) -> (String) -> ScalarExpr
OdbcFunc :: (Annotation) -> (ScalarExpr) -> ScalarExpr
AntiScalarExpr :: (String) -> ScalarExpr
data InList
InList :: (Annotation) -> (ScalarExprList) -> InList
InQueryExpr :: (Annotation) -> (QueryExpr) -> InList
data LiftFlavour
LiftAny :: LiftFlavour
LiftAll :: LiftFlavour
data Direction
Asc :: Direction
Desc :: Direction
data NullsOrder
NullsDefault :: NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
data Distinct
Distinct :: Distinct
All :: Distinct
data CombineType
Except :: CombineType
Union :: CombineType
Intersect :: CombineType
UnionAll :: CombineType
data IntervalField
IntervalYear :: IntervalField
IntervalMonth :: IntervalField
IntervalDay :: IntervalField
IntervalHour :: IntervalField
IntervalMinute :: IntervalField
IntervalSecond :: IntervalField
IntervalYearToMonth :: IntervalField
IntervalDayToHour :: IntervalField
IntervalDayToMinute :: IntervalField
IntervalDayToSecond :: IntervalField
IntervalHourToMinute :: IntervalField
IntervalHourToSecond :: IntervalField
IntervalMinuteToSecond :: IntervalField
data ExtractField
ExtractCentury :: ExtractField
ExtractDay :: ExtractField
ExtractDecade :: ExtractField
ExtractDow :: ExtractField
ExtractDoy :: ExtractField
ExtractEpoch :: ExtractField
ExtractHour :: ExtractField
ExtractIsodow :: ExtractField
ExtractIsoyear :: ExtractField
ExtractMicroseconds :: ExtractField
ExtractMillennium :: ExtractField
ExtractMilliseconds :: ExtractField
ExtractMinute :: ExtractField
ExtractMonth :: ExtractField
ExtractQuarter :: ExtractField
ExtractSecond :: ExtractField
ExtractTimezone :: ExtractField
ExtractTimezoneHour :: ExtractField
ExtractTimezoneMinute :: ExtractField
ExtractWeek :: ExtractField
ExtractYear :: ExtractField
data FrameClause
FrameUnboundedPreceding :: FrameClause
FrameUnboundedFull :: FrameClause
FrameRowsUnboundedPreceding :: FrameClause
data OdbcLiteralType
OLDate :: OdbcLiteralType
OLTime :: OdbcLiteralType
OLTimestamp :: OdbcLiteralType
data QueryExpr
Select :: (Annotation) -> (Distinct) -> (SelectList) -> (TableRefList) -> (MaybeBoolExpr) -> (ScalarExprList) -> (MaybeBoolExpr) -> (ScalarExprDirectionPairList) -> (MaybeScalarExpr) -> (MaybeScalarExpr) -> ([QueryHint]) -> QueryExpr
[ann] :: QueryExpr -> (Annotation)
[selDistinct] :: QueryExpr -> (Distinct)
[selSelectList] :: QueryExpr -> (SelectList)
[selTref] :: QueryExpr -> (TableRefList)
[selWhere] :: QueryExpr -> (MaybeBoolExpr)
[selGroupBy] :: QueryExpr -> (ScalarExprList)
[selHaving] :: QueryExpr -> (MaybeBoolExpr)
[selOrderBy] :: QueryExpr -> (ScalarExprDirectionPairList)
[selLimit] :: QueryExpr -> (MaybeScalarExpr)
[selOffset] :: QueryExpr -> (MaybeScalarExpr)
[selOption] :: QueryExpr -> ([QueryHint])
CombineQueryExpr :: (Annotation) -> (CombineType) -> (QueryExpr) -> (QueryExpr) -> QueryExpr
[ann] :: QueryExpr -> (Annotation)
[cqType] :: QueryExpr -> (CombineType)
[cqQe0] :: QueryExpr -> (QueryExpr)
[cqQe1] :: QueryExpr -> (QueryExpr)
Values :: (Annotation) -> (ScalarExprListList) -> QueryExpr
[ann] :: QueryExpr -> (Annotation)
[qeValues] :: QueryExpr -> (ScalarExprListList)
WithQueryExpr :: (Annotation) -> (WithQueryList) -> (QueryExpr) -> QueryExpr
[ann] :: QueryExpr -> (Annotation)
[withs] :: QueryExpr -> (WithQueryList)
[withQe] :: QueryExpr -> (QueryExpr)

-- | 'default' valued select, use for creating select values
--   
--   <pre>
--   makeSelect :: QueryExpr
--   makeSelect = Select
--                {ann = emptyAnnotation
--                ,selDistinct = All
--                ,selSelectList = (SelectList emptyAnnotation [])
--                ,selTref = []
--                ,selWhere = Nothing
--                ,selGroupBy = []
--                ,selHaving = Nothing
--                ,selOrderBy = []
--                ,selLimit = Nothing
--                ,selOffset = Nothing
--                ,selOption = []}
--   </pre>
--   
--   On its own, it isn't valid syntax: to use it you have to replace the
--   select list at minimum
--   
--   use something like this
--   
--   <pre>
--   s = makeSelect {selSelectList = sl [se $ i "a"]
--                  ,selTref = [tref "t"]}
--       where
--           a = emptyAnnotation
--           sl = SelectList a
--           se = SelExp a
--           i = Identifier a
--           tref t = Tref a (Name a [Nmc t])
--   </pre>
makeSelect :: QueryExpr
data WithQuery
WithQuery :: (Annotation) -> (NameComponent) -> ((Maybe [NameComponent])) -> (QueryExpr) -> WithQuery
data SelectList
SelectList :: (Annotation) -> (SelectItemList) -> SelectList
data SelectItem
SelExp :: (Annotation) -> (ScalarExpr) -> SelectItem
SelectItem :: (Annotation) -> (ScalarExpr) -> (NameComponent) -> SelectItem
data TableRef
Tref :: (Annotation) -> (Name) -> TableRef
FunTref :: (Annotation) -> (ScalarExpr) -> TableRef
SubTref :: (Annotation) -> (QueryExpr) -> TableRef
JoinTref :: (Annotation) -> (TableRef) -> (Natural) -> (JoinType) -> ((Maybe JoinHint)) -> (TableRef) -> (OnExpr) -> TableRef
TableAlias :: (Annotation) -> (NameComponent) -> (TableRef) -> TableRef
FullAlias :: (Annotation) -> (NameComponent) -> (([NameComponent])) -> (TableRef) -> TableRef
TableRefParens :: (Annotation) -> (TableRef) -> TableRef
OdbcTableRef :: (Annotation) -> (TableRef) -> TableRef
data JoinExpr
JoinOn :: (Annotation) -> (ScalarExpr) -> JoinExpr
JoinUsing :: (Annotation) -> (([NameComponent])) -> JoinExpr
data JoinType
Inner :: JoinType
LeftOuter :: JoinType
RightOuter :: JoinType
FullOuter :: JoinType
Cross :: JoinType
data JoinHint
Loop :: JoinHint
Hash :: JoinHint
Merge :: JoinHint
data QueryHint
QueryHintPartitionGroup :: QueryHint
QueryHintColumnarHostGroup :: QueryHint
type OnExpr = Maybe (JoinExpr)
data Natural
Natural :: Natural
Unnatural :: Natural
data Statement
QueryStatement :: (Annotation) -> (QueryExpr) -> Statement
Insert :: (Annotation) -> (Name) -> (([NameComponent])) -> (QueryExpr) -> (MaybeSelectList) -> Statement
Update :: (Annotation) -> (Name) -> (SetClauseList) -> (TableRefList) -> (MaybeBoolExpr) -> (MaybeSelectList) -> Statement
Delete :: (Annotation) -> (Name) -> (TableRefList) -> (MaybeBoolExpr) -> (MaybeSelectList) -> Statement
CopyFrom :: (Annotation) -> (Name) -> (([NameComponent])) -> (CopyFromSource) -> (([CopyFromOption])) -> Statement
CopyData :: (Annotation) -> (String) -> Statement
CopyTo :: (Annotation) -> (CopyToSource) -> (String) -> (([CopyToOption])) -> Statement
Truncate :: (Annotation) -> (([Name])) -> (RestartIdentity) -> (Cascade) -> Statement
CreateTable :: (Annotation) -> (Name) -> (AttributeDefList) -> (ConstraintList) -> (MaybeTablePartitionDef) -> (Replace) -> Statement
AlterTable :: (Annotation) -> (Name) -> (AlterTableOperation) -> Statement
AlterDatabase :: (Annotation) -> (Name) -> (AlterDatabaseOperation) -> Statement
CreateSequence :: (Annotation) -> (Name) -> (Integer) -> ((Maybe Integer)) -> ((Maybe Integer)) -> (Integer) -> (Integer) -> Statement
AlterSequence :: (Annotation) -> (Name) -> (AlterSequenceOperation) -> Statement
CreateTableAs :: (Annotation) -> (Name) -> (Replace) -> (QueryExpr) -> Statement
CreateView :: (Annotation) -> (Name) -> (MaybeNameComponentList) -> (QueryExpr) -> Statement
AlterView :: (Annotation) -> (Name) -> (MaybeNameComponentList) -> (QueryExpr) -> Statement
CreateType :: (Annotation) -> (Name) -> (TypeAttributeDefList) -> Statement
CreateUser :: (Annotation) -> (Name) -> (String) -> Statement
CreateLogin :: (Annotation) -> (Name) -> (String) -> Statement
AlterUser :: (Annotation) -> (Name) -> (String) -> Statement
AlterLogin :: (Annotation) -> (Name) -> (String) -> Statement
CreateSchema :: (Annotation) -> (NameComponent) -> ((Maybe Name)) -> Statement
AlterSchema :: (Annotation) -> (NameComponent) -> (AlterSchemaOperation) -> Statement
CreateFunction :: (Annotation) -> (Name) -> (ParamDefList) -> (TypeName) -> (Replace) -> (Language) -> (FnBody) -> (Volatility) -> Statement
CreateDomain :: (Annotation) -> (Name) -> (TypeName) -> (String) -> (MaybeBoolExpr) -> Statement
CreateLanguage :: (Annotation) -> (String) -> Statement
CreateTrigger :: (Annotation) -> (NameComponent) -> (TriggerWhen) -> (([TriggerEvent])) -> (Name) -> (TriggerFire) -> (Name) -> (ScalarExprList) -> Statement
DropFunction :: (Annotation) -> (IfExists) -> (NameTypeNameListPairList) -> (Cascade) -> Statement
DropSomething :: (Annotation) -> (DropType) -> (IfExists) -> (([Name])) -> (Cascade) -> Statement
DropTrigger :: (Annotation) -> (IfExists) -> (NameComponent) -> (Name) -> (Cascade) -> Statement
CreateDatabase :: (Annotation) -> (Name) -> Statement
Set :: (Annotation) -> (String) -> (([SetValue])) -> Statement
Notify :: (Annotation) -> (String) -> Statement
Into :: (Annotation) -> (Bool) -> (([Name])) -> (Statement) -> Statement
Assignment :: (Annotation) -> (Name) -> (ScalarExpr) -> Statement
Return :: (Annotation) -> (MaybeScalarExpr) -> Statement
ReturnNext :: (Annotation) -> (ScalarExpr) -> Statement
ReturnQuery :: (Annotation) -> (QueryExpr) -> Statement
Raise :: (Annotation) -> (RaiseType) -> (String) -> (ScalarExprList) -> Statement
NullStatement :: (Annotation) -> Statement
Perform :: (Annotation) -> (ScalarExpr) -> Statement
Execute :: (Annotation) -> (ScalarExpr) -> Statement
ForQueryStatement :: (Annotation) -> ((Maybe String)) -> (NameComponent) -> (QueryExpr) -> (StatementList) -> Statement
ForIntegerStatement :: (Annotation) -> ((Maybe String)) -> (NameComponent) -> (ScalarExpr) -> (ScalarExpr) -> (StatementList) -> Statement
LoopStatement :: (Annotation) -> ((Maybe String)) -> (StatementList) -> Statement
WhileStatement :: (Annotation) -> ((Maybe String)) -> (ScalarExpr) -> (StatementList) -> Statement
ContinueStatement :: (Annotation) -> ((Maybe String)) -> Statement
ExitStatement :: (Annotation) -> ((Maybe String)) -> Statement
CaseStatementSimple :: (Annotation) -> (ScalarExpr) -> (ScalarExprListStatementListTripleList) -> (StatementList) -> Statement
CaseStatement :: (Annotation) -> (ScalarExprListStatementListTripleList) -> (StatementList) -> Statement
If :: (Annotation) -> (ScalarExprStatementListPairList) -> (StatementList) -> Statement
Block :: (Annotation) -> ((Maybe String)) -> (VarDefList) -> (StatementList) -> Statement
AntiStatement :: (String) -> Statement
DeclareStatement :: (Annotation) -> (([(String, TypeName, Maybe ScalarExpr)])) -> Statement
ExecStatement :: (Annotation) -> (Name) -> (ScalarExprList) -> Statement
CreateIndexTSQL :: (Annotation) -> (NameComponent) -> (Name) -> (([NameComponent])) -> Statement
data CopyToSource
CopyTable :: Name -> [NameComponent] -> CopyToSource
CopyQuery :: QueryExpr -> CopyToSource
data CopyFromSource
CopyFilename :: String -> CopyFromSource
Stdin :: CopyFromSource
data CopyToOption
CopyToFormat :: String -> CopyToOption
CopyToDelimiter :: String -> CopyToOption
CopyToErrorLog :: String -> CopyToOption
CopyToErrorVerbosity :: Int -> CopyToOption
data CopyFromOption
CopyFromFormat :: String -> CopyFromOption
CopyFromDelimiter :: String -> CopyFromOption
CopyFromErrorLog :: String -> CopyFromOption
CopyFromErrorVerbosity :: Int -> CopyFromOption
CopyFromParsers :: String -> CopyFromOption
CopyFromDirectory :: CopyFromOption
CopyFromOffset :: Integer -> CopyFromOption
CopyFromLimit :: Integer -> CopyFromOption
CopyFromErrorThreshold :: Int -> CopyFromOption
CopyFromNewlineFormat :: String -> CopyFromOption
data SetClause
SetClause :: (Annotation) -> (NameComponent) -> (ScalarExpr) -> SetClause
MultiSetClause :: (Annotation) -> (([NameComponent])) -> (ScalarExpr) -> SetClause
data AttributeDef
AttributeDef :: (Annotation) -> (NameComponent) -> (TypeName) -> (MaybeScalarExpr) -> (RowConstraintList) -> AttributeDef
data RowConstraint
NullConstraint :: (Annotation) -> (String) -> RowConstraint
NotNullConstraint :: (Annotation) -> (String) -> RowConstraint
IdentityConstraint :: (Annotation) -> (String) -> (((Maybe (Integer, Integer)))) -> RowConstraint
RowCheckConstraint :: (Annotation) -> (String) -> (ScalarExpr) -> RowConstraint
RowUniqueConstraint :: (Annotation) -> (String) -> RowConstraint
RowPrimaryKeyConstraint :: (Annotation) -> (String) -> RowConstraint
RowReferenceConstraint :: (Annotation) -> (String) -> (Name) -> ((Maybe NameComponent)) -> (Cascade) -> (Cascade) -> RowConstraint
data Constraint
UniqueConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> Constraint
PrimaryKeyConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> Constraint
CheckConstraint :: (Annotation) -> (String) -> (ScalarExpr) -> Constraint
ReferenceConstraint :: (Annotation) -> (String) -> (([NameComponent])) -> (Name) -> (([NameComponent])) -> (Cascade) -> (Cascade) -> Constraint
data TablePartitionDef
TablePartitionDef :: (Annotation) -> (NameComponent) -> (Integer) -> (TablePartitionDateTimeInterval) -> TablePartitionDef
data TablePartitionDateTimeInterval
Year :: TablePartitionDateTimeInterval
Month :: TablePartitionDateTimeInterval
Day :: TablePartitionDateTimeInterval
Hour :: TablePartitionDateTimeInterval
Minute :: TablePartitionDateTimeInterval
Second :: TablePartitionDateTimeInterval
Millisecond :: TablePartitionDateTimeInterval
data TypeAttributeDef
TypeAttDef :: (Annotation) -> (NameComponent) -> (TypeName) -> TypeAttributeDef
data AlterDatabaseOperation
RenameDatabase :: (Annotation) -> (Name) -> AlterDatabaseOperation
data AlterSchemaOperation
AlterSchemaName :: (Annotation) -> (NameComponent) -> AlterSchemaOperation
AlterSchemaOwner :: (Annotation) -> (Name) -> AlterSchemaOperation
data AlterTableOperation
RenameTable :: (Annotation) -> (Name) -> AlterTableOperation
RenameColumn :: (Annotation) -> (NameComponent) -> (NameComponent) -> AlterTableOperation
AlterTableActions :: (Annotation) -> (AlterTableActionList) -> AlterTableOperation
data AlterTableAction
AddColumn :: (Annotation) -> (AttributeDef) -> AlterTableAction
DropColumn :: (Annotation) -> (NameComponent) -> AlterTableAction
AlterColumn :: (Annotation) -> (NameComponent) -> (AlterColumnAction) -> AlterTableAction
AddConstraint :: (Annotation) -> (Constraint) -> AlterTableAction
data AlterSequenceOperation
AlterSequenceOwned :: (Annotation) -> (Name) -> AlterSequenceOperation
AlterSequenceRename :: (Annotation) -> (Name) -> AlterSequenceOperation
AlterSequenceActions :: (Annotation) -> (AlterSequenceActionList) -> AlterSequenceOperation
data AlterSequenceAction
AlterSequenceIncrement :: (Annotation) -> (Integer) -> AlterSequenceAction
AlterSequenceMin :: (Annotation) -> ((Maybe Integer)) -> AlterSequenceAction
AlterSequenceMax :: (Annotation) -> ((Maybe Integer)) -> AlterSequenceAction
AlterSequenceStart :: (Annotation) -> (Integer) -> AlterSequenceAction
AlterSequenceRestart :: (Annotation) -> ((Maybe Integer)) -> AlterSequenceAction
AlterSequenceCache :: (Annotation) -> (Integer) -> AlterSequenceAction

-- | run canonicalizeTypeName on all the TypeName nodes in an ast
data AlterColumnAction
SetDataType :: (Annotation) -> (TypeName) -> AlterColumnAction
SetNotNull :: (Annotation) -> AlterColumnAction
DropNotNull :: (Annotation) -> AlterColumnAction
SetDefault :: (Annotation) -> (ScalarExpr) -> AlterColumnAction
DropDefault :: (Annotation) -> AlterColumnAction
data TriggerWhen
TriggerBefore :: TriggerWhen
TriggerAfter :: TriggerWhen
data TriggerEvent
TInsert :: TriggerEvent
TUpdate :: TriggerEvent
TDelete :: TriggerEvent
AntiTriggerEvent :: String -> TriggerEvent
data TriggerFire
EachRow :: TriggerFire
EachStatement :: TriggerFire
data DropType
Table :: DropType
Domain :: DropType
View :: DropType
Type :: DropType
Database :: DropType
User :: DropType
Login :: DropType
Schema :: DropType
data Cascade
Cascade :: Cascade
Restrict :: Cascade
data IfExists
Require :: IfExists
IfExists :: IfExists
data RestartIdentity
RestartIdentity :: RestartIdentity
ContinueIdentity :: RestartIdentity
data Replace
Replace :: Replace
NoReplace :: Replace
data Volatility
Volatile :: Volatility
Stable :: Volatility
Immutable :: Volatility
data Language
Sql :: Language
Plpgsql :: Language
data FnBody
SqlFnBody :: (Annotation) -> (StatementList) -> FnBody
PlpgsqlFnBody :: (Annotation) -> (Statement) -> FnBody
data ParamDef
ParamDef :: (Annotation) -> (NameComponent) -> (TypeName) -> ParamDef
ParamDefTp :: (Annotation) -> (TypeName) -> ParamDef
data VarDef
VarDef :: (Annotation) -> (NameComponent) -> (TypeName) -> ((Maybe ScalarExpr)) -> VarDef
ParamAlias :: (Annotation) -> (NameComponent) -> (Integer) -> VarDef
VarAlias :: (Annotation) -> (NameComponent) -> (Name) -> VarDef
data RaiseType
RNotice :: RaiseType
RException :: RaiseType
RError :: RaiseType
data SetValue
SetStr :: Annotation -> String -> SetValue
SetId :: Annotation -> String -> SetValue
SetNum :: Annotation -> Double -> SetValue

module Database.HsSqlPpp.Pretty

-- | Convert an ast back to valid SQL source.
prettyStatements :: PrettyFlags -> [Statement] -> Text

-- | pretty print a query expression
prettyQueryExpr :: PrettyFlags -> QueryExpr -> Text

-- | pretty print a scalar expression
prettyScalarExpr :: PrettyFlags -> ScalarExpr -> Text
data PrettyFlags
PrettyFlags :: Dialect -> PrettyFlags
[ppDialect] :: PrettyFlags -> Dialect
defaultPrettyFlags :: PrettyFlags
data Dialect
Dialect :: String -> SyntaxFlavour -> [(Text, [Text])] -> [Text] -> [Text] -> [Text] -> [(Text, Text)] -> Catalog -> Dialect
[diName] :: Dialect -> String
[diSyntaxFlavour] :: Dialect -> SyntaxFlavour
[diCanonicalTypeNames] :: Dialect -> [(Text, [Text])]
[diTextTypes] :: Dialect -> [Text]
[diDatetimeTypes] :: Dialect -> [Text]
[diNumberTypes] :: Dialect -> [Text]
[namesForAnsiTypes] :: Dialect -> [(Text, Text)]
[diDefaultCatalog] :: Dialect -> Catalog
ansiDialect :: Dialect


-- | Contains functions for typechecking sql asts.
module Database.HsSqlPpp.TypeCheck

-- | Typechecks the ast, and returns the updated catalog (which includes
--   changes from any ddl statements in the ast).
typeCheckStatements :: TypeCheckFlags -> Catalog -> [Statement] -> (Catalog, [Statement])

-- | Typecheck a query expr
typeCheckQueryExpr :: TypeCheckFlags -> Catalog -> QueryExpr -> QueryExpr

-- | Not working yet. Typechecks a statement possibly containing ?
--   placeholders. These are annotated with the 'inferred type', and the
--   stType annotation on the return value can be used to get this info
--   easily. Returns Left if the statement is not a query,insert,update or
--   delete statement
typeCheckScalarExpr :: TypeCheckFlags -> Catalog -> Environment -> ScalarExpr -> ScalarExpr

-- | some options when typechecking
data TypeCheckFlags
TypeCheckFlags :: Bool -> Bool -> Bool -> Bool -> Dialect -> TypeCheckFlags

-- | add qualifiers to unqualified ids where possible
[tcfAddQualifiers] :: TypeCheckFlags -> Bool

-- | add full aliases to every tableref and subselect
[tcfAddFullTablerefAliases] :: TypeCheckFlags -> Bool

-- | add explicit aliases to all select items
[tcfAddSelectItemAliases] :: TypeCheckFlags -> Bool

-- | expand stars in select lists to explicit list columns
[tcfExpandStars] :: TypeCheckFlags -> Bool
[tcfDialect] :: TypeCheckFlags -> Dialect
data Dialect
Dialect :: String -> SyntaxFlavour -> [(Text, [Text])] -> [Text] -> [Text] -> [Text] -> [(Text, Text)] -> Catalog -> Dialect
[diName] :: Dialect -> String
[diSyntaxFlavour] :: Dialect -> SyntaxFlavour
[diCanonicalTypeNames] :: Dialect -> [(Text, [Text])]
[diTextTypes] :: Dialect -> [Text]
[diDatetimeTypes] :: Dialect -> [Text]
[diNumberTypes] :: Dialect -> [Text]
[namesForAnsiTypes] :: Dialect -> [(Text, Text)]
[diDefaultCatalog] :: Dialect -> Catalog
ansiDialect :: Dialect

-- | reasonable defaults for type checking, doesn't add anything optional
defaultTypeCheckFlags :: TypeCheckFlags
emptyEnvironment :: Environment


-- | This module contains a collection of utility functions
module Database.HsSqlPpp.Utility

-- | replace all the annotations in a tree with <a>emptyAnnotation</a>
resetAnnotations :: Data a => a -> a

-- | Gets the type of the sql source passed in. Expects the string to
--   contain a query expr
queryType :: Catalog -> Text -> Maybe Type

-- | run on a typechecked tree. Finds all the places where an implicit cast
--   has been used in the typechecking and inserts an explicit cast
addExplicitCasts :: Data a => a -> a

-- | variation of the above, which uses ImplicitCast ctor
addImplicitCasts :: Data a => Catalog -> a -> a

-- | Gets some information useful for checking a typechecked tree returns
--   the type of the top level node, a list of type errors from the tree, a
--   list of the queryexpr nodes, and a list of the scalar exprs
--   respectively, which have their type as nothing which indicates that
--   the typechecking didn't complete successfully
tcTreeInfo :: Data a => a -> (Maybe TypeExtra, [([TypeError], Maybe SourcePosition)], [QueryExpr], [ScalarExpr])

-- | show a type error list in emacs format
emacsShowErrors :: [([TypeError], Maybe SourcePosition)] -> String


-- | Contains the annotation data types and a few auxiliary functions.
module Database.HsSqlPpp.Annotation

-- | Annotation type - one of these is attached to most of the data types
--   used in the ast. the fields in order are:
data Annotation
Annotation :: (Maybe SourcePosition) -> (Maybe TypeExtra) -> ([TypeError]) -> (Maybe TypeExtra) -> ([CatalogUpdate]) -> Annotation

-- | source position for this node
[anSrc] :: Annotation -> (Maybe SourcePosition)

-- | type of the node, <a>Nothing</a> if the tree hasn't been typechecked
--   or if a type error elsewhere prevents determining this node's type
[anType] :: Annotation -> (Maybe TypeExtra)

-- | any type errors
[anErrs] :: Annotation -> ([TypeError])

-- | if an implicit cast is needed between this node an its parent, this
--   the target type of cast. If no implicit cast is needed, this is
--   Nothing
[anImplicitCast] :: Annotation -> (Maybe TypeExtra)

-- | any catalog updates that a statement produces, used only for ddl
--   Statements
[anCatUpd] :: Annotation -> ([CatalogUpdate])

-- | Represents a source file position, usually set by the parser.
type SourcePosition = (FilePath, Int, Int)

-- | get the annotation for the root element of the tree passed
getAnnotation :: Data a => a -> Annotation

-- | Update the first annotation in a tree using the function supplied
updateAnnotation :: Data a => (Annotation -> Annotation) -> a -> a

-- | An annotation value with no information.
emptyAnnotation :: Annotation
