<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Database/HsSqlPpp/Internals/TypeChecking/TypeConversion/TypeConversion.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>


This file contains the functions for resolving types and
function/operator resolution (which is seriously crazy). See the pg
manual chapter 10:

http://www.postgresql.org/docs/8.4/interactive/typeconv.html

sql server todo: want to match sql server implicit cast rules better
when doing tsql type checking. Follows a completely different approach, possible info here:
http://msdn.microsoft.com/en-us/library/ms187928.aspx
http://msdn.microsoft.com/en-us/library/ms190309.aspx
linked from here:
http://blogs.msdn.com/b/craigfr/archive/2010/01/20/more-on-implicit-conversions.aspx


TODO: rewrite
Wrappers to zap:

tcAppLike
matchApp
matchAppExtra
resolveResultSetType
resolveResultSetTypeExtra
findcallmatch
resolveresultsettype
checkassignments

We should have one function for each of the resolvers (3 just like
postgres) all the nullability, precision, dialect and special hacks
should all be in one place.

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE OverloadedStrings, TupleSections, MultiWayIf,FlexibleInstances,ScopedTypeVariables #-}</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeChecking</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>(</span><span class='hs-varid'>matchApp</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-varid'>matchAppExtra</span>
<a name="line-5"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-varid'>tcAppLike</span>
<a name="line-6"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-varid'>resolveResultSetType</span>
<a name="line-7"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-varid'>resolveResultSetTypeExtra</span>
<a name="line-8"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-varid'>checkAssignmentValid</span>
<a name="line-9"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>,</span><span class='hs-conid'>MatchAppLiteralList</span> <span class='hs-comment'>-- (..)</span>
<a name="line-10"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-11"></a><span class='hs-varop'>&gt;</span>
<a name="line-12"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
<a name="line-13"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-14"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Either</span>
<a name="line-15"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Char</span>
<a name="line-16"></a><span class='hs-varop'>&gt;</span>
<a name="line-17"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypesInternal</span>
<a name="line-18"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Database.HsSqlPpp.Internals.Catalog.CatalogInternal</span>
<a name="line-19"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Catalog</span><span class='hs-varop'>.</span><span class='hs-conid'>CatalogTypes</span>
<a name="line-20"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Utils</span>
<a name="line-21"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-22"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span>
<a name="line-23"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Arrow</span>
</pre>
<pre><a name="line-24"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeChecking</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion</span><span class='hs-varop'>.</span><span class='hs-conid'>OldTypeConversion</span>
<a name="line-25"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Dialect</span>
<a name="line-26"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeChecking</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion</span><span class='hs-varop'>.</span><span class='hs-conid'>SqlTypeConversion</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TSQL</span>
<a name="line-27"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-conid'>()</span>
<a name="line-28"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-29"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Text</span><span class='hs-varop'>.</span><span class='hs-conid'>Printf</span>
<a name="line-30"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Debug.Trace</span>
</pre>
******************************************************************

matchApp: takes the function name and argument types, and returns the
matching operator/function

This needs a lot more tests

<pre><a name="line-31"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>MatchAppLiteralList</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
</pre>
<pre><a name="line-32"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dialect</span>
<a name="line-33"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Catalog</span>
<a name="line-34"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NameComponent</span><span class='hs-keyglyph'>]</span>
<a name="line-35"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-36"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchApp</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>nmcs</span> <span class='hs-keyglyph'>=</span>
<a name="line-38"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>ambiguityResolver</span> <span class='hs-varop'>$</span> <span class='hs-varid'>matchApp'</span> <span class='hs-varid'>d</span> <span class='hs-varid'>nmcs</span>
<a name="line-39"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-40"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- matchApp' a b c | trace (show (a,b,c)) False = undefined</span>
<a name="line-41"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- hack in support for sql server datediff function</span>
<a name="line-42"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- need to think of a better way to handle this when</span>
<a name="line-43"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- have a better idea of all the weird syntax used in</span>
<a name="line-44"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- tsql</span>
<a name="line-45"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- this is a todo since currently the sql server dialect uses</span>
<a name="line-46"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- postgresql type names, and this is about to be fixed</span>
<a name="line-47"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span>
<a name="line-49"></a><span class='hs-varop'>&gt;</span>                                  <span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span>
<a name="line-50"></a><span class='hs-varop'>&gt;</span>                                  <span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span>
<a name="line-51"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"datediff"</span> <span class='hs-keyglyph'>=</span>
<a name="line-52"></a><span class='hs-varop'>&gt;</span>       <span class='hs-comment'>-- check there are 3 args</span>
<a name="line-53"></a><span class='hs-varop'>&gt;</span>       <span class='hs-comment'>-- first is identifier from list</span>
<a name="line-54"></a><span class='hs-varop'>&gt;</span>       <span class='hs-comment'>-- other two are date types</span>
<a name="line-55"></a><span class='hs-varop'>&gt;</span>       <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span>
<a name="line-57"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"datepart"</span> <span class='hs-keyglyph'>=</span>
<a name="line-58"></a><span class='hs-varop'>&gt;</span>       <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-59"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-keyglyph'>]</span>
<a name="line-60"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"datepart"</span> <span class='hs-keyglyph'>=</span>
<a name="line-61"></a><span class='hs-varop'>&gt;</span>       <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>)</span>
</pre>

<pre><a name="line-62"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span>
<a name="line-63"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"dateadd"</span> <span class='hs-keyglyph'>=</span>
<a name="line-64"></a><span class='hs-varop'>&gt;</span>       <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"date"</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-65"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-keyglyph'>]</span>
<a name="line-66"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"dateadd"</span> <span class='hs-keyglyph'>=</span>
<a name="line-67"></a><span class='hs-varop'>&gt;</span>       <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-layout'>)</span>
</pre>
double hack: support oracle decode when in tsql mode:

<pre><a name="line-68"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>as</span>
<a name="line-69"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"decode"</span> <span class='hs-keyglyph'>=</span>
</pre>
decode is just syntax for simple case statement:
demand at least 3 arguments
get the type of the first argument: this is the test target

<pre><a name="line-70"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>case</span> <span class='hs-keyword'>as</span> <span class='hs-keyword'>of</span>
<a name="line-71"></a><span class='hs-varop'>&gt;</span>         <span class='hs-layout'>(</span><span class='hs-varid'>tt</span><span class='hs-conop'>:</span><span class='hs-varid'>as'</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
</pre>
for each pair of arguments following: check the first
one can be compared to the test target

collect all the second types
if there is a single trailing argument this is the else

<pre><a name="line-72"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>checkBranches</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>acc</span>
<a name="line-73"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>checkBranches</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>els</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>reverse</span> <span class='hs-layout'>(</span><span class='hs-varid'>els</span><span class='hs-conop'>:</span><span class='hs-varid'>acc</span><span class='hs-layout'>)</span>
<a name="line-74"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>checkBranches</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-75"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchApp'</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-str'>"="</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tt</span><span class='hs-layout'>,</span><span class='hs-varid'>w</span><span class='hs-keyglyph'>]</span>
<a name="line-76"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-varid'>checkBranches</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>acc</span><span class='hs-layout'>)</span>
<a name="line-77"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varid'>sndTypes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkBranches</span> <span class='hs-varid'>as'</span> <span class='hs-conid'>[]</span>
</pre>
check the seconds types + the else for type compatilibility
return this type
todo: add the implicit casting where needed

<pre><a name="line-78"></a><span class='hs-varop'>&gt;</span>             <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>resolveResultSetType</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>sndTypes</span>
</pre>

<pre><a name="line-79"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NoMatchingOperator</span> <span class='hs-layout'>(</span><span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varid'>dd</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span><span class='hs-keyglyph'>]</span>
</pre>


<pre><a name="line-80"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>matchApp'</span> <span class='hs-varid'>d'</span> <span class='hs-varid'>nmcs'</span> <span class='hs-varid'>pts</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-trace ("matchapp: " ++ show (d,nmcs,pts)) $ -}</span> <span class='hs-keyword'>do</span>
<a name="line-81"></a><span class='hs-varop'>&gt;</span>       <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>ps</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>d'</span> <span class='hs-keyword'>of</span>
<a name="line-82"></a><span class='hs-varop'>&gt;</span>                       <span class='hs-layout'>(</span><span class='hs-conid'>Dialect</span> <span class='hs-layout'>{</span><span class='hs-varid'>diSyntaxFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SqlServer</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TSQL</span><span class='hs-varop'>.</span><span class='hs-varid'>findCallMatch</span> <span class='hs-varid'>d'</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>nm</span> <span class='hs-varid'>pts</span>
<a name="line-83"></a><span class='hs-varop'>&gt;</span>                       <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>findCallMatch</span> <span class='hs-varid'>d'</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>nm</span> <span class='hs-varid'>pts</span>
<a name="line-84"></a><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ps</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-85"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-86"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>last</span> <span class='hs-varid'>nmcs'</span> <span class='hs-keyword'>of</span>
<a name="line-87"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>Nmc</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>n</span>
<a name="line-88"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>QNmc</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varid'>n</span>
<a name="line-89"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>AntiNameComponent</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- todo: use left instead of error</span>
<a name="line-90"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-varid'>error</span> <span class='hs-str'>"tried to find function matching an antinamecomponent"</span>
</pre>
hack to support literal arguments to overloaded functions
  currently, the problem arises only for date/datetime arguments
  the solution reflects this
for long argument lists with several literals, there can be a lot of variants generated, but
  this shouldn't slow down the execution because lazyness composes well with the functions used

<pre><a name="line-91"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>ambiguityResolver</span><span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-92"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-93"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>ambiguityResolver</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>let</span> <span class='hs-varid'>rs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-94"></a><span class='hs-varop'>&gt;</span>                               <span class='hs-varid'>rs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varop'>$</span> <span class='hs-varid'>expandList</span> <span class='hs-varid'>variants</span> <span class='hs-varid'>ts</span>
<a name="line-95"></a><span class='hs-varop'>&gt;</span>                           <span class='hs-comment'>-- this is needed in order to preserve the original error</span>
<a name="line-96"></a><span class='hs-varop'>&gt;</span>                           <span class='hs-comment'>--  in case when all the attempts fail</span>
<a name="line-97"></a><span class='hs-varop'>&gt;</span>                           <span class='hs-keyword'>in</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rights</span> <span class='hs-varid'>rs</span> <span class='hs-keyword'>of</span>
<a name="line-98"></a><span class='hs-varop'>&gt;</span>                                  <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>x</span>
<a name="line-99"></a><span class='hs-varop'>&gt;</span>                                  <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>head</span> <span class='hs-varid'>rs</span>
<a name="line-100"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-101"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>variants</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>t</span> <span class='hs-keyword'>of</span>
<a name="line-102"></a><span class='hs-varop'>&gt;</span>         <span class='hs-conid'>UnknownType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-conid'>ScalarType</span> <span class='hs-str'>"timestamp"</span><span class='hs-keyglyph'>]</span>
<a name="line-103"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-keyglyph'>]</span>
<a name="line-104"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- similar to handling of superaggregates</span>
<a name="line-105"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- ToDo: move to a general library</span>
<a name="line-106"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>expandList</span><span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-107"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>expandList</span> <span class='hs-varid'>f'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>liftM2</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>f'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>[]</span><span class='hs-keyglyph'>]</span>
</pre>
------------- precision and nullability of function application --------------

uses matchApp for inferring basic types

<pre><a name="line-108"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchAppExtra</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dialect</span>
<a name="line-109"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Catalog</span>
<a name="line-110"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NameComponent</span><span class='hs-keyglyph'>]</span>
<a name="line-111"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MatchAppLiteralList</span>
<a name="line-112"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span>
<a name="line-113"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span>
<a name="line-114"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchAppExtra</span> <span class='hs-varid'>dialect</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>nmcs</span> <span class='hs-varid'>lits</span> <span class='hs-varid'>tes</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-trace ("mae" ++ show (nmcs,tes)) $ -}</span> <span class='hs-keyword'>do</span>
<a name="line-115"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>(</span><span class='hs-varid'>ts'</span><span class='hs-layout'>,</span><span class='hs-varid'>t'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchApp</span> <span class='hs-varid'>dialect</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>nmcs</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>teType</span> <span class='hs-varid'>tes</span>
<a name="line-116"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>tes'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>joinArgsExtra</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>tes</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>addArgExtra</span> <span class='hs-varid'>tes</span> <span class='hs-varid'>ts'</span>
<a name="line-117"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tes'</span><span class='hs-layout'>,</span> <span class='hs-varid'>addResultExtra</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>tes'</span> <span class='hs-varid'>t'</span> <span class='hs-varid'>lits</span><span class='hs-layout'>)</span>
<a name="line-118"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-119"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>addArgExtra</span> <span class='hs-varid'>te</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>te</span> <span class='hs-layout'>{</span><span class='hs-varid'>teType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span><span class='hs-layout'>}</span>
<a name="line-120"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>appName</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>nmcs</span> <span class='hs-keyword'>of</span>
<a name="line-121"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span>
<a name="line-122"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>""</span>
</pre>
precision and nullability of the result

<pre><a name="line-123"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>addResultExtra</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MatchAppLiteralList</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-124"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>addResultExtra</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>tes</span> <span class='hs-varid'>t</span> <span class='hs-varid'>lits</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkPrecisionRelevance</span> <span class='hs-varop'>.</span> <span class='hs-varid'>checkResultPrecisionClass</span> <span class='hs-varid'>tesr</span>
<a name="line-125"></a><span class='hs-varop'>&gt;</span>                                 <span class='hs-varop'>$</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-varid'>jp</span> <span class='hs-varid'>js</span> <span class='hs-varid'>jn</span>
<a name="line-126"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-127"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>jp</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span>
<a name="line-128"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>==</span> <span class='hs-str'>"||"</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-varid'>tePrecision</span> <span class='hs-varid'>tesr</span>
<a name="line-129"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>==</span> <span class='hs-str'>"substring"</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-130"></a><span class='hs-varop'>&gt;</span>            <span class='hs-comment'>-- Substring is an interesting case. If we have both the</span>
<a name="line-131"></a><span class='hs-varop'>&gt;</span>            <span class='hs-comment'>-- start and length as literals, we can figure out the resulting precision</span>
<a name="line-132"></a><span class='hs-varop'>&gt;</span>            <span class='hs-comment'>-- Otherwise, treat as before with joinPrecision</span>
<a name="line-133"></a><span class='hs-varop'>&gt;</span>            <span class='hs-keyword'>let</span> <span class='hs-varid'>totalLen</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>joinPrecision</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tePrecision</span> <span class='hs-varid'>tesr</span>
<a name="line-134"></a><span class='hs-varop'>&gt;</span>            <span class='hs-keyword'>in</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>teType</span> <span class='hs-varid'>tesr</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-135"></a><span class='hs-varop'>&gt;</span>              <span class='hs-keyglyph'>[</span><span class='hs-conid'>ScalarType</span> <span class='hs-str'>"nvarchar"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>totalLen</span>
<a name="line-136"></a><span class='hs-varop'>&gt;</span>              <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-137"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-keyword'>case</span> <span class='hs-varid'>lits</span> <span class='hs-keyword'>of</span>
<a name="line-138"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-layout'>(</span><span class='hs-conid'>Nothing</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>startPos</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>len</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-139"></a><span class='hs-varop'>&gt;</span>                       <span class='hs-varid'>totalLen'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>totalLen</span>
<a name="line-140"></a><span class='hs-varop'>&gt;</span>                       <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>startPos</span> <span class='hs-varop'>+</span> <span class='hs-varid'>len</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>totalLen'</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>totalLen'</span> <span class='hs-comment'>-</span> <span class='hs-varid'>startPos</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>len</span>
<a name="line-141"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>totalLen</span>
</pre>
<pre><a name="line-142"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- precision of the result is unknown</span>
<a name="line-143"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"replace"</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- is actually known for 2-argument "replace"</span>
<a name="line-144"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-145"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-146"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>joinPrecision</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tePrecision</span> <span class='hs-varid'>tesr</span>
<a name="line-147"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>js</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>joinScale</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>teScale</span> <span class='hs-varid'>tesr</span>
<a name="line-148"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>jn</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span>
<a name="line-149"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span>
<a name="line-150"></a><span class='hs-varop'>&gt;</span>           <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"isnotnull"</span><span class='hs-layout'>,</span><span class='hs-str'>"isdate"</span><span class='hs-layout'>,</span><span class='hs-str'>"isnumeric"</span><span class='hs-keyglyph'>]</span>
<a name="line-151"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- standard "is null" expression</span>
<a name="line-152"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"isnull"</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tes</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span><span class='hs-keyglyph'>]</span>
<a name="line-153"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- currently, aggregate functions are handled as scalar functions</span>
<a name="line-154"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"count"</span><span class='hs-layout'>,</span><span class='hs-str'>"count_big"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-155"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-156"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span>
<a name="line-157"></a><span class='hs-varop'>&gt;</span>           <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"coalesce"</span><span class='hs-layout'>,</span><span class='hs-str'>"greatest"</span><span class='hs-layout'>,</span><span class='hs-str'>"least"</span><span class='hs-keyglyph'>]</span>
<a name="line-158"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- 2-argument function "isnull" of SqlServer</span>
<a name="line-159"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- ImplicitCastToDo: isnull has quite complex cast rules,</span>
<a name="line-160"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>--    not really reflected here and in the cast of arguments</span>
<a name="line-161"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"isnull"</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tes</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span>
<a name="line-162"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- nullability of corresponding SqlServer function "charindex"</span>
<a name="line-163"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>--  may or may not differ, depending on database compatibility level</span>
<a name="line-164"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- I implement the level above 70, so it goes to the default case</span>
<a name="line-165"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"strpos"</span><span class='hs-layout'>,</span><span class='hs-str'>"position"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-166"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>tesr</span>
<a name="line-167"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- can produce null independently on the nullability of the arguments</span>
<a name="line-168"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- ImplicitCastToDo: check again: doesn't it depend on the presence of "else" part</span>
<a name="line-169"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"case"</span><span class='hs-layout'>,</span><span class='hs-str'>"decode"</span><span class='hs-layout'>,</span><span class='hs-str'>"nullif"</span><span class='hs-layout'>,</span><span class='hs-str'>"replicate"</span><span class='hs-keyglyph'>]</span>
<a name="line-170"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-171"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- the default</span>
<a name="line-172"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"substr"</span><span class='hs-layout'>,</span><span class='hs-str'>"substring"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>any</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>tes</span>
<a name="line-173"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>joinNullability</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>tesr</span>
<a name="line-174"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- arguments that participate in the inference of the result type</span>
<a name="line-175"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>tesr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>appName</span> <span class='hs-keyword'>of</span>
<a name="line-176"></a><span class='hs-varop'>&gt;</span>       <span class='hs-str'>"decode"</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>caseResultTypes</span> <span class='hs-varid'>tes</span>
<a name="line-177"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- only the first argument influences precision and nullability</span>
<a name="line-178"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"nullif"</span><span class='hs-layout'>,</span><span class='hs-str'>"substr"</span><span class='hs-layout'>,</span><span class='hs-str'>"substring"</span><span class='hs-layout'>,</span><span class='hs-str'>"left"</span><span class='hs-layout'>,</span><span class='hs-str'>"right"</span><span class='hs-layout'>,</span><span class='hs-str'>"ltrim"</span><span class='hs-layout'>,</span><span class='hs-str'>"rtrim"</span><span class='hs-layout'>,</span><span class='hs-str'>"replicate"</span><span class='hs-layout'>,</span><span class='hs-str'>"translate"</span><span class='hs-layout'>,</span><span class='hs-str'>"like"</span><span class='hs-layout'>,</span><span class='hs-str'>"notlike"</span><span class='hs-layout'>,</span><span class='hs-str'>"rlike"</span><span class='hs-keyglyph'>]</span>
<a name="line-179"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>take</span> <span class='hs-num'>1</span> <span class='hs-varid'>tes</span>
<a name="line-180"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- the first two arguments influence</span>
<a name="line-181"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"charindex"</span><span class='hs-keyglyph'>]</span>
<a name="line-182"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>take</span> <span class='hs-num'>2</span> <span class='hs-varid'>tes</span>
<a name="line-183"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- the first argument doesn't influence</span>
<a name="line-184"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"datepart"</span><span class='hs-layout'>,</span><span class='hs-str'>"datediff"</span><span class='hs-keyglyph'>]</span>
<a name="line-185"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>drop</span> <span class='hs-num'>1</span> <span class='hs-varid'>tes</span>
<a name="line-186"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- the first two arguments don't influence</span>
<a name="line-187"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"dateadd"</span><span class='hs-keyglyph'>]</span>
<a name="line-188"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>drop</span> <span class='hs-num'>2</span> <span class='hs-varid'>tes</span>
<a name="line-189"></a><span class='hs-varop'>&gt;</span>       <span class='hs-comment'>-- the default case</span>
<a name="line-190"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tes</span>
<a name="line-191"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- tail is safe here because matchApp did all the checks</span>
<a name="line-192"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>caseResultTypes</span> <span class='hs-varid'>tes'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>caseResultTypes'</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-varid'>tes'</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-193"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-194"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>caseResultTypes'</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>acc</span>
<a name="line-195"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>caseResultTypes'</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>els</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>els</span><span class='hs-conop'>:</span><span class='hs-varid'>acc</span>
<a name="line-196"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>caseResultTypes'</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>t'</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>caseResultTypes'</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>t'</span><span class='hs-conop'>:</span><span class='hs-varid'>acc</span><span class='hs-layout'>)</span>
</pre>
------------- cast of arguments --------------

Bring relevant arguments of a function to common precision and nullability.
The meaning of "relevant" is complicated:
  - the list of arguments is split into partitions;
  - precision and nullability is partition-wise joined;
  - the results are broadcast back to the arguments that constituted partitions.
The algorithm follows this outline.
Examples:
  - for binary operators, like "=", both arguments constitute a single partition;
  - for some functions, like "substr", each argument belongs to its own partition;
  - arguments of "case" and "decode" form two partitions which, except for the analyzed value
    and the 'else' argument, are intervened with one another.
Actually, partitions for precision and partitions for nullability can be different.
Example:
  "||": both arguments must be brought to common nullability, but remain with same precision.
Additionaly:
  Before splitting onto partitions, check each argument for:
    - precision class of the original (before matchApp) argument;
    - precision relevance.
  After splitting onto partitions, check each precision partition:
    - all arguments must have same precision class (return an error if they don't).

What the is this function doing? What is it for?

<pre><a name="line-197"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>joinArgsExtra</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span>
<a name="line-198"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>joinArgsExtra</span> <span class='hs-str'>"!odbc-left"</span> <span class='hs-sel'>_t0</span> <span class='hs-varid'>t1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>t1</span>
<a name="line-199"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>joinArgsExtra</span> <span class='hs-str'>"!odbc-timestampdiff"</span> <span class='hs-sel'>_t0</span> <span class='hs-varid'>t1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>t1</span>
<a name="line-200"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>joinArgsExtra</span> <span class='hs-str'>"!odbc-timestampadd"</span> <span class='hs-sel'>_t0</span> <span class='hs-varid'>t1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>t1</span>
</pre>
<pre><a name="line-201"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>joinArgsExtra</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>tes0</span> <span class='hs-varid'>tes1</span>
<a name="line-202"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zipWith3</span> <span class='hs-varid'>combine</span> <span class='hs-varid'>tes</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>uncurry</span> <span class='hs-layout'>(</span><span class='hs-varid'>liftM2</span> <span class='hs-conid'>(,)</span><span class='hs-layout'>)</span>
<a name="line-203"></a><span class='hs-varop'>&gt;</span>       <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>joinDim</span> <span class='hs-varid'>joinPrec</span> <span class='hs-varid'>partitionPrec</span> <span class='hs-varop'>&amp;&amp;&amp;</span> <span class='hs-varid'>joinDim</span> <span class='hs-varid'>joinNull</span> <span class='hs-varid'>partitionNull</span><span class='hs-layout'>)</span> <span class='hs-varid'>tes</span>
<a name="line-204"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-205"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- checks and adjustments before partitioning</span>
<a name="line-206"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>tes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>checkPrecisionRelevance</span>
<a name="line-207"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>$</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>adjust</span> <span class='hs-varid'>tes0</span>
<a name="line-208"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>$</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>checkPrecisionClass</span> <span class='hs-varid'>tes0</span> <span class='hs-varid'>tes1</span>
<a name="line-209"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-210"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>adjust</span> <span class='hs-varid'>te0</span> <span class='hs-varid'>te1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>te1</span><span class='hs-layout'>{</span><span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>head</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjustStringCastPrec</span> <span class='hs-layout'>(</span><span class='hs-varid'>teType</span> <span class='hs-varid'>te1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>te0</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>}</span>
<a name="line-211"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- checks after partitioning</span>
<a name="line-212"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>checkPartition</span> <span class='hs-varid'>ptes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>nub</span> <span class='hs-varid'>ppcs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>1</span>
<a name="line-213"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>then</span> <span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InternalError</span> <span class='hs-varop'>$</span> <span class='hs-varid'>printf</span> <span class='hs-str'>"implicit cast: arguments of '%s' that belong to same partition are of different precision classes: %s -&gt; %s"</span> <span class='hs-varid'>appName</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>ptes</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>ppcs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-214"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>ptes</span>
<a name="line-215"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-216"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>ppcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>precisionClass</span> <span class='hs-varop'>.</span> <span class='hs-varid'>teType</span><span class='hs-layout'>)</span> <span class='hs-varid'>ptes</span>
<a name="line-217"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- the algorithm for a single partitioning dimension</span>
<a name="line-218"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>joinDim</span><span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-219"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span>
<a name="line-220"></a><span class='hs-varop'>&gt;</span>                                         <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-221"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span>
<a name="line-222"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>joinDim</span> <span class='hs-varid'>join'</span> <span class='hs-varid'>partitionArgs'</span>
<a name="line-223"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-layout'>(</span><span class='hs-varop'>$</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>second</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>join'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>partitionArgs'</span>
<a name="line-224"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- combine results for precision and nullability</span>
<a name="line-225"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>combine</span> <span class='hs-varid'>te</span> <span class='hs-varid'>tePrec</span> <span class='hs-varid'>teNull</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>te</span> <span class='hs-layout'>{</span>
<a name="line-226"></a><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tePrecision</span> <span class='hs-varid'>tePrec</span><span class='hs-layout'>,</span>
<a name="line-227"></a><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>teScale</span> <span class='hs-varid'>tePrec</span><span class='hs-layout'>,</span>
<a name="line-228"></a><span class='hs-varop'>&gt;</span>       <span class='hs-varid'>teNullable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>teNull</span>
<a name="line-229"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>}</span>
<a name="line-230"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- joins of precision and nullability partitions</span>
<a name="line-231"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>joinPrec</span> <span class='hs-varid'>tes'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>promote</span> <span class='hs-varid'>tes'</span>
<a name="line-232"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-233"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>promote</span> <span class='hs-layout'>(</span><span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>p'</span> <span class='hs-varop'>`mplus`</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>s'</span> <span class='hs-varop'>`mplus`</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span>
<a name="line-234"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>p'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>joinPrecision</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>tePrecision</span> <span class='hs-varid'>tes</span>
<a name="line-235"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>s'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>joinScale</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>teScale</span> <span class='hs-varid'>tes</span>
<a name="line-236"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>joinNull</span> <span class='hs-varid'>tes'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>promote</span> <span class='hs-varid'>tes'</span>
<a name="line-237"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>where</span>
<a name="line-238"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>promote</span> <span class='hs-layout'>(</span><span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-varid'>p</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-varid'>n'</span> <span class='hs-varop'>||</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-239"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>n'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>joinNullability</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>tes</span>
<a name="line-240"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- the partitioning functions return partitions paired with a function</span>
<a name="line-241"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>--    that puts them back into their places</span>
<a name="line-242"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- because, in many cases, partitions for precision and for nullability are the same,</span>
<a name="line-243"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>--    the partitioning code for such cases is factored out</span>
<a name="line-244"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>partitionArgs</span><span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-245"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>partitionArgs</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-246"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- functions whose arguments are independent</span>
<a name="line-247"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>--  instead of splitting into partitions, just return the original list</span>
<a name="line-248"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span>
<a name="line-249"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"datepart"</span><span class='hs-layout'>,</span><span class='hs-str'>"dateadd"</span><span class='hs-keyglyph'>]</span>
<a name="line-250"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"substr"</span><span class='hs-layout'>,</span><span class='hs-str'>"substring"</span><span class='hs-layout'>,</span><span class='hs-str'>"left"</span><span class='hs-layout'>,</span><span class='hs-str'>"right"</span><span class='hs-layout'>,</span><span class='hs-str'>"ltrim"</span><span class='hs-layout'>,</span><span class='hs-str'>"rtrim"</span><span class='hs-keyglyph'>]</span>
<a name="line-251"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"replicate"</span><span class='hs-layout'>,</span><span class='hs-str'>"like"</span><span class='hs-layout'>,</span><span class='hs-str'>"notlike"</span><span class='hs-layout'>,</span><span class='hs-str'>"rlike"</span><span class='hs-keyglyph'>]</span>
<a name="line-252"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"strpos"</span><span class='hs-layout'>,</span><span class='hs-str'>"position"</span><span class='hs-layout'>,</span><span class='hs-str'>"replace"</span><span class='hs-keyglyph'>]</span>
<a name="line-253"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-comment'>-- Oracle joins the datatypes (needed for the comparison)</span>
<a name="line-254"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"nullif"</span><span class='hs-keyglyph'>]</span>
<a name="line-255"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- SQream specific regex functions</span>
<a name="line-256"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"regexp_substr"</span><span class='hs-layout'>,</span><span class='hs-str'>"regexp_count"</span><span class='hs-layout'>,</span><span class='hs-str'>"regexp_instr"</span><span class='hs-keyglyph'>]</span>
<a name="line-257"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"string_agg"</span><span class='hs-keyglyph'>]</span>
<a name="line-258"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>)</span>
<a name="line-259"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-260"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- first argument is special, the rest are processed together</span>
<a name="line-261"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"datediff"</span><span class='hs-keyglyph'>]</span>
<a name="line-262"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairToList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>splitAt</span> <span class='hs-num'>1</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-263"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"decode"</span><span class='hs-keyglyph'>]</span>
<a name="line-264"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ws</span><span class='hs-layout'>,</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decomposeDecodeTail</span> <span class='hs-layout'>(</span><span class='hs-varid'>tail</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-265"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>composeDecodePartitions</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>head</span> <span class='hs-keyword'>as</span> <span class='hs-conop'>:</span><span class='hs-varid'>ws</span><span class='hs-layout'>,</span> <span class='hs-varid'>ts</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-266"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- the default is to return a single partition</span>
<a name="line-267"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>as</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-268"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>partitionPrec</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>secondM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mapM</span> <span class='hs-varid'>checkPartition</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-269"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- independent arguments</span>
<a name="line-270"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"||"</span><span class='hs-layout'>,</span><span class='hs-str'>"concat"</span><span class='hs-layout'>,</span><span class='hs-str'>"translate"</span><span class='hs-layout'>,</span><span class='hs-str'>"charindex"</span><span class='hs-keyglyph'>]</span>
<a name="line-271"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-272"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- single partition</span>
<a name="line-273"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span>
<a name="line-274"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"coalesce"</span><span class='hs-layout'>,</span><span class='hs-str'>"greatest"</span><span class='hs-layout'>,</span><span class='hs-str'>"least"</span><span class='hs-keyglyph'>]</span>
<a name="line-275"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-comment'>-- ImplicitCastToDo: think how to handle this properly</span>
<a name="line-276"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"isnull"</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span>
<a name="line-277"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>)</span>
<a name="line-278"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>as</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-279"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>partitionArgs</span> <span class='hs-keyword'>as</span>
<a name="line-280"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>partitionNull</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-281"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span>
<a name="line-282"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"coalesce"</span><span class='hs-layout'>,</span><span class='hs-str'>"greatest"</span><span class='hs-layout'>,</span><span class='hs-str'>"least"</span><span class='hs-keyglyph'>]</span>
<a name="line-283"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"isnull"</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span>
<a name="line-284"></a><span class='hs-varop'>&gt;</span>               <span class='hs-layout'>)</span>
<a name="line-285"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-286"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>appName</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"charindex"</span><span class='hs-keyglyph'>]</span>
<a name="line-287"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairToList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>splitAt</span> <span class='hs-num'>2</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-288"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>partitionArgs</span> <span class='hs-keyword'>as</span>
<a name="line-289"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- utility</span>
<a name="line-290"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>pairToList</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span>
<a name="line-291"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>decomposeDecodeTail</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span><span class='hs-varop'>***</span><span class='hs-varid'>reverse</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span>
<a name="line-292"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>decomposeDecodeTail</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>els</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span><span class='hs-varop'>.</span><span class='hs-layout'>(</span><span class='hs-varid'>els</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span><span class='hs-varop'>***</span><span class='hs-varid'>reverse</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span>
<a name="line-293"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>decomposeDecodeTail</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decomposeDecodeTail</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>w</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span><span class='hs-varop'>***</span><span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span>
<a name="line-294"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>composeDecodePartitions</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span><span class='hs-varid'>ws</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-conop'>:</span> <span class='hs-varid'>concat</span> <span class='hs-layout'>(</span><span class='hs-varid'>transpose</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span><span class='hs-varid'>ws</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-295"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- redundant</span>
<a name="line-296"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>composeDecodePartitions</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concat</span> <span class='hs-varid'>xs</span>
</pre>
------------- precision class --------------

This is a small library for checking whether inference of precision does make sense.
It is used both in inference of precision of arguments and result of a function.

It is theoretically possible that types belong to different precision classes,
    but inference of precision still makes sense (consider, for instance,
    conversion between string and decimal).
  Such cases must be handled specially.

<pre><a name="line-297"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>PrecisionClass</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Number</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FlexiblePrecisionClass</span>
<a name="line-298"></a><span class='hs-varop'>&gt;</span>       <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span><span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<a name="line-299"></a><span class='hs-varop'>&gt;</span>
<a name="line-300"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>precisionClass</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>PrecisionClass</span>
<a name="line-301"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>precisionClass</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScalarType</span> <span class='hs-varid'>tn</span><span class='hs-layout'>)</span>
<a name="line-302"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tn</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"text"</span><span class='hs-layout'>,</span><span class='hs-str'>"varchar"</span><span class='hs-layout'>,</span><span class='hs-str'>"nvarchar"</span><span class='hs-layout'>,</span><span class='hs-str'>"char"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>String</span>
<a name="line-303"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tn</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"int1"</span><span class='hs-layout'>,</span><span class='hs-str'>"int2"</span><span class='hs-layout'>,</span><span class='hs-str'>"int4"</span><span class='hs-layout'>,</span><span class='hs-str'>"int8"</span><span class='hs-layout'>,</span><span class='hs-str'>"float4"</span><span class='hs-layout'>,</span><span class='hs-str'>"float8"</span><span class='hs-layout'>,</span><span class='hs-str'>"numeric"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>Number</span>
<a name="line-304"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-305"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>precisionClass</span> <span class='hs-conid'>UnknownType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>FlexiblePrecisionClass</span>
<a name="line-306"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>precisionClass</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
</pre>
Do original and new type have compatible precision classes?
Note: this function is not commutative.

<pre><a name="line-307"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>infix</span> <span class='hs-num'>4</span> <span class='hs-varop'>.~&gt;.</span>
<a name="line-308"></a><span class='hs-varop'>&gt;</span> <span class='hs-layout'>(</span><span class='hs-varop'>.~&gt;.</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-309"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>t0</span> <span class='hs-varop'>.~&gt;.</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>FlexiblePrecisionClass</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>pc0</span><span class='hs-layout'>,</span><span class='hs-varid'>pc</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>||</span> <span class='hs-varid'>pc0</span> <span class='hs-varop'>==</span> <span class='hs-varid'>pc</span>
<a name="line-310"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-311"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>[</span><span class='hs-varid'>pc0</span><span class='hs-layout'>,</span><span class='hs-varid'>pc</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>precisionClass</span> <span class='hs-varop'>.</span> <span class='hs-varid'>teType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t0</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-keyglyph'>]</span>
</pre>
retreat to default when original and new type are incompatible

<pre><a name="line-312"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkPrecisionClass</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-313"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkPrecisionClass</span> <span class='hs-varid'>t0</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>t0</span> <span class='hs-varop'>.~&gt;.</span> <span class='hs-varid'>t</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>t</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>t</span><span class='hs-layout'>{</span><span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>}</span>
</pre>
check precision class of result against precision classes of arguments

<pre><a name="line-314"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkResultPrecisionClass</span><span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-315"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkResultPrecisionClass</span> <span class='hs-varid'>tes</span> <span class='hs-varid'>t</span>
<a name="line-316"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>and</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varop'>.~&gt;.</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>tes</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>t</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>t</span><span class='hs-layout'>{</span><span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>}</span>
</pre>
check whether precision/scale is relevant for a type (consider "round").

<pre><a name="line-317"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkPrecisionRelevance</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-318"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>checkPrecisionRelevance</span> <span class='hs-varid'>te</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span>
<a name="line-319"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pc</span>
<a name="line-320"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>te</span><span class='hs-layout'>{</span><span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>}</span>
<a name="line-321"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>FlexiblePrecisionClass</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pc</span>
<a name="line-322"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>te</span>
<a name="line-323"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ScalarType</span> <span class='hs-varid'>tn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>t</span><span class='hs-layout'>,</span> <span class='hs-varid'>tn</span> <span class='hs-varop'>==</span> <span class='hs-str'>"numeric"</span>
<a name="line-324"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>te</span>
<a name="line-325"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-326"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>te</span><span class='hs-layout'>{</span><span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>}</span>
<a name="line-327"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-328"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>teType</span> <span class='hs-varid'>te</span>
<a name="line-329"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>pc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>precisionClass</span> <span class='hs-varid'>t</span>
</pre>

The purpose of the tcapplike wrapper is to partially fix up the
keyword 'enums' in some of the ms style functions (like
datepart). This is a horrible hack and will be fixed.

<pre><a name="line-330"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dialect</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Catalog</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NameComponent</span><span class='hs-keyglyph'>]</span>
<a name="line-331"></a><span class='hs-varop'>&gt;</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span>
<a name="line-332"></a><span class='hs-varop'>&gt;</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-333"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>lits</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-334"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"datediff"</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-335"></a><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- dodgy hack for datediff</span>
<a name="line-336"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-337"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>typeInt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>ScalarType</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span>
<a name="line-338"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-varid'>ansiTypeNameToDialect</span> <span class='hs-varid'>d</span> <span class='hs-str'>"int"</span><span class='hs-layout'>)</span>
<a name="line-339"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>let</span> <span class='hs-comment'>--Name _ ns = anm</span>
<a name="line-340"></a><span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-varid'>lits</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTypeExtraNN</span> <span class='hs-varid'>typeInt</span> <span class='hs-conop'>:</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-341"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
<a name="line-342"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>lits</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>a0</span><span class='hs-keyglyph'>]</span>
<a name="line-343"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"datepart"</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-344"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a0</span><span class='hs-keyglyph'>]</span>
<a name="line-345"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>typeInt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>ScalarType</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span>
<a name="line-346"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-varid'>ansiTypeNameToDialect</span> <span class='hs-varid'>d</span> <span class='hs-str'>"int"</span><span class='hs-layout'>)</span>
<a name="line-347"></a><span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-varid'>lits</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTypeExtraNN</span> <span class='hs-varid'>typeInt</span> <span class='hs-conop'>:</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-348"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
<a name="line-349"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>lits</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-350"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"dateadd"</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-351"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-352"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>typeInt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>ScalarType</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span>
<a name="line-353"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-varid'>ansiTypeNameToDialect</span> <span class='hs-varid'>d</span> <span class='hs-str'>"int"</span><span class='hs-layout'>)</span>
<a name="line-354"></a><span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-varid'>lits</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTypeExtraNN</span> <span class='hs-varid'>typeInt</span> <span class='hs-conop'>:</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-355"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-356"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--tcAppLike d cat anm@(Name _ [Nmc dd]) a b</span>
<a name="line-357"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--    |  trace ("xz: " ++ show (a,b)) False = undefined</span>
</pre>
<pre><a name="line-358"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ts</span>
<a name="line-359"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>==</span> <span class='hs-str'>"!odbc-convert"</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-360"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-layout'>(</span><span class='hs-varid'>tys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-361"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-comment'>--let Name _ ns = anm</span>
<a name="line-362"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>tys</span>
<a name="line-363"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-364"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Nmc</span> <span class='hs-varid'>dd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-365"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>dd</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"!odbc-timestampadd"</span><span class='hs-layout'>,</span><span class='hs-str'>"!odbc-timestampdiff"</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-366"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a0</span><span class='hs-layout'>,</span><span class='hs-varid'>a1</span><span class='hs-keyglyph'>]</span>
<a name="line-367"></a><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>--let Name _ ns = anm</span>
<a name="line-368"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>typeInt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>ScalarType</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span>
<a name="line-369"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-varid'>ansiTypeNameToDialect</span> <span class='hs-varid'>d</span> <span class='hs-str'>"int"</span><span class='hs-layout'>)</span>
<a name="line-370"></a><span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTypeExtraNN</span> <span class='hs-varid'>typeInt</span> <span class='hs-conop'>:</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-371"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
</pre>
<pre><a name="line-372"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>tcAppLike</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-varid'>lits</span> <span class='hs-varid'>teArgs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-373"></a><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- get the types of the arguments</span>
<a name="line-374"></a><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>-- then lookup in TypeConversion.matchAppExtra</span>
<a name="line-375"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-conid'>Right</span><span class='hs-layout'>)</span> <span class='hs-varid'>teArgs</span>
<a name="line-376"></a><span class='hs-varop'>&gt;</span>   <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchAppExtra</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>anm</span> <span class='hs-varid'>lits</span> <span class='hs-varid'>tys</span>
<a name="line-377"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ats</span><span class='hs-layout'>,</span><span class='hs-varid'>rt</span><span class='hs-layout'>)</span>
</pre>

******************************************************************

 findCallMatch :: Catalog -> String -> [Type] ->  Either [TypeError] OperatorPrototype
 findCallMatch cat fnName' argsType =

code interspersed with text cut and pasted from postgresql manual
10.3. Functions

Function Type Resolution

Select the functions to be considered from the pg_proc system
catalog. If a non-schema-qualified function name was used, the
functions considered are those with the matching name and argument
count that are visible in the current search path (see Section
5.7.3). If a qualified function name was given, only functions in the
specified schema are considered.

[HsSqlPpp doesn't support schema stuff yet, so just get a list of all
the functions with a matching name]

<pre><a name="line-378"></a><span class='hs-varop'>&gt;</span>   <span class='hs-comment'>{-let matchingNames = catGetOpsMatchingName cat nmcs
<a name="line-379"></a>&gt;       exactMatches = filter (\(_,ts,_,_) -&gt; ts == pts) matchingNames
<a name="line-380"></a>&gt;   case exactMatches of
<a name="line-381"></a>&gt;     [(_,tys,rt,_)] -&gt; return (tys, rt)
<a name="line-382"></a>&gt;     [] -&gt; error $ "no matching fn: " ++ show nmcs
<a name="line-383"></a>&gt;                   ++ "(" ++ intercalate "," (map show pts) ++ ")"
<a name="line-384"></a>&gt;     _xs -&gt; error "ambiguous"-}</span>
</pre>


If the search path finds multiple functions of identical argument
types, only the one appearing earliest in the path is
considered. Functions of different argument types are considered on an
equal footing regardless of search path position.

If a function is declared with a VARIADIC array parameter, and the
call does not use the VARIADIC keyword, then the function is treated
as if the array parameter were replaced by one or more occurrences of
its element type, as needed to match the call. After such expansion
the function might have effective argument types identical to some
non-variadic function. In that case the function appearing earlier in
the search path is used, or if the two functions are in the same
schema, the non-variadic one is preferred.

Functions that have default values for parameters are considered to
match any call that omits zero or more of the defaultable parameter
positions. If more than one such function matches a call, the one
appearing earliest in the search path is used. If there are two or
more such functions in the same schema with identical parameter types
in the non-defaulted positions (which is possible if they have
different sets of defaultable parameters), the system will not be able
to determine which to prefer, and so an "ambiguous function call"
error will result if no better match to the call can be found.

Check for a function accepting exactly the input argument types. If
one exists (there can be only one exact match in the set of functions
considered), use it. (Cases involving unknown will never find a match
at this step.)

If no exact match is found, see if the function call appears to be a
special type conversion request. This happens if the function call has
just one argument and the function name is the same as the (internal)
name of some data type. Furthermore, the function argument must be
either an unknown-type literal, or a type that is binary-coercible to
the named data type, or a type that could be converted to the named
data type by applying that type's I/O functions (that is, the
conversion is either to or from one of the standard string
types). When these conditions are met, the function call is treated as
a form of CAST specification. [1]

Look for the best match.

Discard candidate functions for which the input types do not match and
cannot be converted (using an implicit conversion) to match. unknown
literals are assumed to be convertible to anything for this
purpose. If only one candidate remains, use it; else continue to the
next step.

Run through all candidates and keep those with the most exact matches
on input types. (Domains are considered the same as their base type
for this purpose.) Keep all candidates if none have exact matches. If
only one candidate remains, use it; else continue to the next step.

Run through all candidates and keep those that accept preferred types
(of the input data type's type category) at the most positions where
type conversion will be required. Keep all candidates if none accept
preferred types. If only one candidate remains, use it; else continue
to the next step.

If any input arguments are unknown, check the type categories accepted
at those argument positions by the remaining candidates. At each
position, select the string category if any candidate accepts that
category. (This bias towards string is appropriate since an
unknown-type literal looks like a string.) Otherwise, if all the
remaining candidates accept the same type category, select that
category; otherwise fail because the correct choice cannot be deduced
without more clues. Now discard candidates that do not accept the
selected type category. Furthermore, if any candidate accepts a
preferred type in that category, discard candidates that accept
non-preferred types for that argument.

If only one candidate remains, use it. If no candidate or more than
one candidate remains, then fail.




exact match
binop1unknownmatch
polymorphic matches
reachable
mostexactmatches
filteredforpreferred
unknownmatchesbycat



TODO: do a log monad, which can record the tests and then return this
process along with the resolved function


--------------------------------
todo:

<pre><a name="line-385"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-resolveResultSetType :: Catalog -&gt; [Type] -&gt; Either [TypeError] Type
<a name="line-386"></a>&gt; resolveResultSetType _cat [] = error "resolveResultSetType: empty type set"
<a name="line-387"></a>&gt; resolveResultSetType _cat (t:ts) =
<a name="line-388"></a>&gt;   if all (==t) ts
<a name="line-389"></a>&gt;   then Right t
<a name="line-390"></a>&gt;   else Left [IncompatibleTypeSet (t:ts)]-}</span>
</pre>
todo:

assignmentCheck
</body>
</html>
