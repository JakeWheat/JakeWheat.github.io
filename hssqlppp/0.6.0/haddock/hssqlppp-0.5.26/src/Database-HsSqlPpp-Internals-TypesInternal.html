<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Database/HsSqlPpp/Internals/TypesInternal.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>


Type identifiers and anonymous types

Basic type identified by name
These can be quoted or unquoted, and with or without schema

unknown type: this is used for the types of literals in a kind of poor
mans type inference, modelled on postgresql's behaviour. Dialects can
choose not to use this approach and give a literal a type based only
on its syntax (and thus the dialect would never use the unknown
type. (The direct unknown typing isn't quite implemented yet).

any types

these are used to implement a kind of poor man's polymorphism. based
on the any types in postgresql. These are used for polymorphic
udfs. This is separate to overloading functions.

anonymous composite type

this represents a tuple of types, all, some or none of which can have
field names. This is used for composite types which are created on the
fly and don't have a name in the catalog or environment. Maybe this
should be changed so they are given a temporary name to reduce the
special cases

tref type

this is an internal type used by the typechecker (todo: can this be
hidden?) Maybe could add optional correlation names to the field names
in anonymous composite type and reuse that?

setof?
record?
void?

typeextra

ugly way to add nullability and precision to a type. This should get a
big rethink

step 1 todo:
combine composite and anonymous composite types
combine scalartype, domaintype, enum, named composite type

get rid of explicit array types and figure out a better way to handle
them

Split the errors into another module, and in the public api
The errors should contain not contain 'Type's.

figure out a better way of handling nullability, precision, scale than
the typeextra

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE FlexibleInstances,DeriveDataTypeable,OverloadedStrings #-}</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypesInternal</span> <span class='hs-keyword'>where</span>
<a name="line-4"></a><span class='hs-varop'>&gt;</span>
<a name="line-5"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Data</span>
<a name="line-6"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Data.Generics.Uniplate.Data</span>
<a name="line-7"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Data.Char</span>
<a name="line-8"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span>
<a name="line-9"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import qualified Data.Text as T</span>
<a name="line-10"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Database.HsSqlPpp.Internals.Dialect</span>
<a name="line-11"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Data.List</span>
<a name="line-12"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Debug.Trace</span>
</pre>
<pre><a name="line-13"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Control.Monad.Error</span>
<a name="line-14"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Control.Monad.Except</span>
<a name="line-15"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Control.Monad.Trans.Except</span>
</pre>
where should precision and nullability go?


TODO:
rename UnknownType to ScalarType "!unknown" ? or something else?
do we need separate entries for domain and enums?
think of a better way to implement array types - get rid of the
  special casing which is based on a postgresql implementation detail
get rid of pseudo types, maybe use ScalarType or SpecialType String
  which is dialect specific?

Maybe there should be a concept of a typeid, and a typedescription?
So the typeid is used everywhere and is just a string or something,
and the typedescription is got from the catalog/environment when
needed in the typechecking?


<pre><a name="line-16"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- | Standard types of things. This covers all the usual postgres types</span>
<a name="line-17"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- plus some extra ones added for use by the hssqlppp typechecker</span>
<a name="line-18"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- | basic type of a scalar value. These are either built in types</span>
<a name="line-19"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- in postgres, or implemented in C or similar</span>
<a name="line-20"></a><span class='hs-varop'>&gt;</span>             <span class='hs-conid'>ScalarType</span> <span class='hs-conid'>Text</span>
<a name="line-21"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | a domain type is used for a constraint on a table column which</span>
<a name="line-22"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- would used on multiple columns on a table or in multiple tables,</span>
<a name="line-23"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- using a domain type is a way of just writing the constraint once</span>
<a name="line-24"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DomainType</span> <span class='hs-conid'>Text</span>
<a name="line-25"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | enum type, not really supported in hssqlppp yet</span>
<a name="line-26"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EnumType</span> <span class='hs-conid'>Text</span>
<a name="line-27"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | String literals in postgres have an unknown type. The effective</span>
<a name="line-28"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- type is determined using what seems to amount to some simple ad hoc rules</span>
<a name="line-29"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- based on the context of the string literal. Hssqlppp also treats</span>
<a name="line-30"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- ? placeholders and nulls the same way, so they have UnknownType,</span>
<a name="line-31"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- not sure how closely this matches postgres</span>
<a name="line-32"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnknownType</span>
<a name="line-33"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | postgres automatically creates an array type for every scalar type</span>
<a name="line-34"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- (plus some other types?) If there is no array type for a type in the</span>
<a name="line-35"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- catalog, then you can't work with arrays of that type</span>
<a name="line-36"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArrayType</span> <span class='hs-conid'>Type</span>
<a name="line-37"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | refer to composite type in catalog by name. not sure if this needs</span>
<a name="line-38"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- to exist along with CompositeType</span>
<a name="line-39"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NamedCompositeType</span> <span class='hs-conid'>Text</span>
<a name="line-40"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | refer to composite type by structure</span>
<a name="line-41"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CompositeType</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-42"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | CompositeTypeExtra [(Text,TypeExtra)]</span>
<a name="line-43"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | hack to support the environment for a tref</span>
<a name="line-44"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TrefType</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>,</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-45"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | the fields are anonymous as well as the type itself</span>
<a name="line-46"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnonymousCompositeType</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-47"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- | The pseudo type is used for types which only appear</span>
<a name="line-48"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- as argument or return types in function definitions and/or</span>
<a name="line-49"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- are used only in plpgsql and not regular sql. hssqlppp also</span>
<a name="line-50"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- follows this usage for the types used in hssqlppp which don't</span>
<a name="line-51"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- have an exact counterpart in postgres</span>
<a name="line-52"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Pseudo</span> <span class='hs-conid'>PseudoType</span>
<a name="line-53"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span><span class='hs-conid'>Ord</span><span class='hs-layout'>,</span><span class='hs-conid'>Typeable</span><span class='hs-layout'>,</span><span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-varop'>&gt;</span>
</pre>
<pre><a name="line-55"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- | Quick fix to add precision and nullable information to the</span>
<a name="line-56"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- annotation types. This approach should be revisited, maybe this</span>
<a name="line-57"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- information should be in the Type type?</span>
<a name="line-58"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-layout'>{</span><span class='hs-varid'>teType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span>
<a name="line-59"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-layout'>,</span><span class='hs-varid'>tePrecision</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<a name="line-60"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-layout'>,</span><span class='hs-varid'>teScale</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<a name="line-61"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-layout'>,</span><span class='hs-varid'>teNullable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>}</span>
<a name="line-62"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span><span class='hs-conid'>Ord</span><span class='hs-layout'>,</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span><span class='hs-conid'>Typeable</span><span class='hs-layout'>,</span><span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-63"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkTypeExtra</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-64"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkTypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>True</span>
<a name="line-65"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkTypeExtraNN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-66"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkTypeExtraNN</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>t</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>False</span>
<a name="line-67"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkNullable</span><span class='hs-keyglyph'>::</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeExtra</span>
<a name="line-68"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>mkNullable</span> <span class='hs-varid'>te</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>te</span><span class='hs-layout'>{</span><span class='hs-varid'>teNullable</span><span class='hs-keyglyph'>=</span><span class='hs-conid'>True</span><span class='hs-layout'>}</span>
</pre>
<pre><a name="line-69"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- | Pseudo types: mainly used for the argument and return types of</span>
<a name="line-70"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- functions. The weird undocumented types are just used to represent</span>
<a name="line-71"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- functions with those types which are in the postgres default catalog</span>
<a name="line-72"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>PseudoType</span> <span class='hs-keyglyph'>=</span>
<a name="line-73"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- | setof is used for set returning functions</span>
<a name="line-74"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-conid'>SetOfType</span> <span class='hs-conid'>Type</span>
<a name="line-75"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- | used to represent polymorphic functions, all the</span>
<a name="line-76"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- AnyElement parameters and the return type if</span>
<a name="line-77"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- AnyElement must be the same type for a given function</span>
<a name="line-78"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- call invocation.</span>
<a name="line-79"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnyElement</span>
<a name="line-80"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- | like AnyElement, but the type must be an array type</span>
<a name="line-81"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnyArray</span>
<a name="line-82"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- | like AnyElement, but the type must be an enum type</span>
<a name="line-83"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnyEnum</span>
<a name="line-84"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- | like AnyElement, but the type must be a non array type</span>
<a name="line-85"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnyNonArray</span>
<a name="line-86"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnyRange</span>
<a name="line-87"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- | Any drops the restriction that all the Any types must</span>
<a name="line-88"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-comment'>-- be the same type</span>
<a name="line-89"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Any</span>
<a name="line-90"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- | record types are used in plpgsql for a sort of dynamic</span>
<a name="line-91"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- typing or rough polymorphism substitute. They can refer to</span>
<a name="line-92"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- values of named composite type, composite type or</span>
<a name="line-93"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- anonymous composite type, not sure if non composite types as well.</span>
<a name="line-94"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Record</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-95"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- | presumably used for the types of OLD and NEW in a trigger</span>
<a name="line-96"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- function. Hssqlppp will probably use the Record type above</span>
<a name="line-97"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- for these.</span>
<a name="line-98"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | TriggerRecord</span>
<a name="line-99"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | Trigger</span>
<a name="line-100"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- | cstring - a C string</span>
<a name="line-101"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | Cstring</span>
<a name="line-102"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- | represents the return type of a function which doesn't return</span>
<a name="line-103"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>-- anything. Not sure if it is used anywhere else</span>
<a name="line-104"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Void</span>
<a name="line-105"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | Internal</span>
<a name="line-106"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | LanguageHandler</span>
<a name="line-107"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | Opaque</span>
<a name="line-108"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-comment'>--  | FdwHandler</span>
<a name="line-109"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span><span class='hs-conid'>Ord</span><span class='hs-layout'>,</span><span class='hs-conid'>Typeable</span><span class='hs-layout'>,</span><span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
</pre>
TODO idea

<pre><a name="line-110"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-data Type = -- | A normal type identified by name. Includes scalar
<a name="line-111"></a>&gt;             -- types, domain types, enums, (non-anonymous)
<a name="line-112"></a>&gt;             -- structured types
<a name="line-113"></a>&gt;             Type (Maybe Text,Text)
<a name="line-114"></a>&gt;              -- | represents a unknown type like in postgres. Used
<a name="line-115"></a>&gt;              -- for literals in some dialects and a few other places
<a name="line-116"></a>&gt;           | UnknownType
<a name="line-117"></a>&gt;           | ArrayType Type
<a name="line-118"></a>&gt;           | CompositeType [(Text,TypeExtra)]
<a name="line-119"></a>&gt;           -- | hack to support the environment for a tref
<a name="line-120"></a>&gt;           | TrefType [((Text,Text),TypeExtra)]
<a name="line-121"></a>&gt;           -- | the fields are anonymous as well as the type itself
<a name="line-122"></a>&gt;           | AnonymousCompositeType [Type]
<a name="line-123"></a>&gt;           | SetOfType Type
<a name="line-124"></a>&gt;             -- | record types are used in plpgsql for a sort of dynamic
<a name="line-125"></a>&gt;             -- typing or rough polymorphism substitute. They can refer to
<a name="line-126"></a>&gt;             -- values of named composite type, composite type or
<a name="line-127"></a>&gt;             -- anonymous composite type, not sure if non composite types as well.
<a name="line-128"></a>&gt;           | Record (Maybe Type)
<a name="line-129"></a>&gt;             deriving (Eq,Show,Ord,Typeable,Data)-}</span>
</pre>

The possible type errors. This is a bit unorganised, at some point if
better error messages are wanted, then a lot more information could be
added.

<pre><a name="line-130"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>TypeError</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-
<a name="line-131"></a>&gt;                | UnknownTypeError Type
<a name="line-132"></a>&gt;                | UnknownTypeName String
<a name="line-133"></a>&gt;                | NoMatchingOperator String [Type]
<a name="line-134"></a>&gt;                | TypelessEmptyArray
<a name="line-135"></a>&gt;                | IncompatibleTypeSet [Type]
<a name="line-136"></a>&gt;                | IncompatibleTypes Type Type
<a name="line-137"></a>&gt;                | ValuesListsMustBeSameLength
<a name="line-138"></a>&gt;                | NoRowsGivenForValues
<a name="line-139"></a>&gt;                | UnrecognisedIdentifier String
<a name="line-140"></a>&gt;                | UnrecognisedRelation String
<a name="line-141"></a>&gt;                | UnrecognisedCorrelationName String
<a name="line-142"></a>&gt;                | BadStarExpand
<a name="line-143"></a>&gt;                | ContextError String
<a name="line-144"></a>&gt;                | MissingJoinAttribute
<a name="line-145"></a>&gt;                | ExpressionMustBeBool
<a name="line-146"></a>&gt;                | WrongNumberOfColumns
<a name="line-147"></a>&gt;                | ExpectedDomainType Type
<a name="line-148"></a>&gt;                | BadCatalogUpdate String
<a name="line-149"></a>&gt;                | TypeAlreadyExists Type
<a name="line-150"></a>&gt;                | AnyAllError String
<a name="line-151"></a>&gt;                | InternalError String
<a name="line-152"></a>&gt;                | FromToTypesNotSame Type Type
<a name="line-153"></a>&gt;                | WrongNumberOfAliasCols Int Int
<a name="line-154"></a></span>
</pre>
type conversion errors

<pre><a name="line-154"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-comment'>-</span><span class='hs-layout'>}</span> <span class='hs-conid'>NoMatchingOperator</span> <span class='hs-conid'>Text</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-155"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AmbiguousOperator</span> <span class='hs-conid'>Text</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-156"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TypelessEmptyArray</span>
<a name="line-157"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IncompatibleTypeSet</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-158"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IncompatibleTypes</span> <span class='hs-conid'>Type</span> <span class='hs-conid'>Type</span>
<a name="line-159"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>WrongNumberOfColumns</span>
<a name="line-160"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>WrongTypes</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-161"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IncompatibleUnionTypes</span> <span class='hs-conid'>Type</span> <span class='hs-conid'>Type</span>
</pre>

old catalog type errors: to be replaced when the catalog code is
gutted and rewritten

<pre><a name="line-162"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TypeAlreadyExists</span> <span class='hs-conid'>Type</span>
<a name="line-163"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SchemaAlreadyExists</span> <span class='hs-conid'>Text</span>
<a name="line-164"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BadCatalogUpdate</span> <span class='hs-conid'>Text</span>
<a name="line-165"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnrecognisedRelation</span> <span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>,</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span>
<a name="line-166"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DomainDefNotFound</span> <span class='hs-conid'>Type</span>
<a name="line-167"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TypeNotKnown</span> <span class='hs-conid'>Type</span>
<a name="line-168"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnknownTypeName</span> <span class='hs-conid'>Text</span>
<a name="line-169"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnrecognisedIdentifier</span> <span class='hs-conid'>Text</span>
<a name="line-170"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnrecognisedCorrelationName</span> <span class='hs-conid'>Text</span>
<a name="line-171"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SchemadColumnName</span> <span class='hs-conid'>Text</span>
<a name="line-172"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DbSchemadColumnName</span> <span class='hs-conid'>Text</span>
<a name="line-173"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BadStarExpand</span>
<a name="line-174"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InternalError</span> <span class='hs-conid'>String</span>
<a name="line-175"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AmbiguousIdentifier</span> <span class='hs-conid'>Text</span>
<a name="line-176"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OdbcFuncBadContent</span>
<a name="line-177"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DuplicateColumnName</span> <span class='hs-conid'>Text</span>
<a name="line-178"></a><span class='hs-varop'>&gt;</span>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TooManyColumnsInInsert</span>
<a name="line-179"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span><span class='hs-conid'>Ord</span><span class='hs-layout'>,</span><span class='hs-conid'>Typeable</span><span class='hs-layout'>,</span><span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-180"></a><span class='hs-varop'>&gt;</span>
</pre></body>
</html>
