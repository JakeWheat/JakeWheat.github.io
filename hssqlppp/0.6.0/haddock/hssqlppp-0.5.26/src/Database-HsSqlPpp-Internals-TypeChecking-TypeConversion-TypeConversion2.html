<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Database/HsSqlPpp/Internals/TypeChecking/TypeConversion/TypeConversion2.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>


TODO: most of this code will move to the internals type conversion.
rewrite the code to be nice and literate explaining everything

<pre><a name="line-1"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE OverloadedStrings,LambdaCase,MultiWayIf,PatternGuards #-}</span>
<a name="line-2"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeChecking</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion</span><span class='hs-varop'>.</span><span class='hs-conid'>TypeConversion2</span>
<a name="line-3"></a><span class='hs-varop'>&gt;</span>        <span class='hs-layout'>(</span><span class='hs-varid'>matchApp</span><span class='hs-layout'>,</span><span class='hs-conid'>LitArg</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
</pre>
TODO: explicit imports

<pre><a name="line-4"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>
<a name="line-5"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Control.Applicative</span>
<a name="line-6"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Control.Arrow</span>
</pre>
<pre><a name="line-7"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-conid'>()</span>
<a name="line-8"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-9"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
<a name="line-10"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-11"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Either</span>
<a name="line-12"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Char</span>
<a name="line-13"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Arrow</span>
</pre>
<pre><a name="line-14"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Text</span><span class='hs-varop'>.</span><span class='hs-conid'>Show</span><span class='hs-varop'>.</span><span class='hs-conid'>Pretty</span>
<a name="line-15"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Debug</span><span class='hs-varop'>.</span><span class='hs-conid'>Trace</span>
</pre>
<pre><a name="line-16"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>TypesInternal</span>
<a name="line-17"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Catalog</span><span class='hs-varop'>.</span><span class='hs-conid'>CatalogInternal</span>
<a name="line-18"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Catalog</span><span class='hs-varop'>.</span><span class='hs-conid'>CatalogTypes</span>
<a name="line-19"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Database.HsSqlPpp.Internals.Catalog.DefaultTemplate1Catalog</span>
<a name="line-20"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--import Database.HsSqlPpp.Utils.Utils</span>
</pre>
<pre><a name="line-21"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- import Database.HsSqlPpp.Internals.TypeChecking.OldTypeConversion</span>
<a name="line-22"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Database</span><span class='hs-varop'>.</span><span class='hs-conid'>HsSqlPpp</span><span class='hs-varop'>.</span><span class='hs-conid'>Internals</span><span class='hs-varop'>.</span><span class='hs-conid'>Dialect</span>
<a name="line-23"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- import qualified Database.HsSqlPpp.Internals.TypeChecking.SqlTypeConversion as TSQL</span>
</pre>

three kinds of type conversion where we might have to insert implicit
casts:

function overload resolution
result set type resolution
is assignment valid

The arg types take a LitArg since we want to say the result type of e.g.
substring(x from 2 for 3) as varchar(3), but if we get
substring(x from a for b) then we don't know the precision from the
for part (but it can't be bigger than the x)

It also supports stuff like odbc convert whose return type depends on
the identifier in the second parameter.

for the special cases for null and precision, have a map of functions
from the function name to the special case transform function which
modifies the return type. Then can try to isolate the special cases a
little bit -> probably need some other special cases, add hooks and
maps of functions for these too

<pre><a name="line-24"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>LitArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NumLitArg</span> <span class='hs-conid'>String</span>
<a name="line-25"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StringLitArg</span> <span class='hs-conid'>String</span>
<a name="line-26"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NullLitArg</span>
<a name="line-27"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BooleanLitArg</span> <span class='hs-conid'>Bool</span>
<a name="line-28"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-29"></a><span class='hs-varop'>&gt;</span>               <span class='hs-comment'>-- todo: add other literals if needed</span>
</pre>

<pre><a name="line-30"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>MyFunType</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>CatName</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
</pre>
match app matches a function + argument types, and determines (using a
bunch of hacks and special cases) the precision, scale and nullability
of the result type also.

<pre><a name="line-31"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dialect</span>
<a name="line-32"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Catalog</span>
<a name="line-33"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NameComponent</span><span class='hs-keyglyph'>]</span>
<a name="line-34"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>LitArg</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-35"></a><span class='hs-varop'>&gt;</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>matchApp</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>argTypes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-37"></a><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findMatchingApp</span> <span class='hs-varid'>d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>appName</span>
<a name="line-38"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span> <span class='hs-varid'>teType</span><span class='hs-layout'>)</span> <span class='hs-varid'>argTypes</span><span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-varop'>&gt;</span>      <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fixNP</span> <span class='hs-varid'>x</span>
<a name="line-40"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
</pre>
todo: fix nulls and precision

precision and scale:

default is to match the precision and scale of any matching input args
or to choose the default for that type

for nulls: default is to assume function produces nullable if any
input args are nullable, and doesn't produce nullable otherwise

<pre><a name="line-41"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>fixNP</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MyFunType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeExtra</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>TypeExtra</span><span class='hs-layout'>)</span>
<a name="line-42"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>fixNP</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-43"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>let</span> <span class='hs-varid'>anyInputsNull</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>$</span> <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-varid'>teNullable</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>argTypes</span>
<a name="line-44"></a><span class='hs-varop'>&gt;</span>             <span class='hs-comment'>-- copy nullability of input types</span>
<a name="line-45"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varid'>carryNulls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lt</span> <span class='hs-varid'>b</span> <span class='hs-varop'>$</span> <span class='hs-varid'>teNullable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-varop'>&gt;</span>                          <span class='hs-varid'>argTypes</span> <span class='hs-varid'>ts</span>
<a name="line-47"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>carryNulls</span><span class='hs-layout'>,</span> <span class='hs-varid'>lt</span> <span class='hs-varid'>r</span> <span class='hs-varid'>anyInputsNull</span><span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>lt</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TypeExtra</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>n</span>
</pre>

find matching app is the code which matches a function prototype to a
list of input argument types, dealing with implicit casts and
overloaded functions. It is based on the algorithm in postgresql.

<pre><a name="line-49"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>findMatchingApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Dialect</span>
<a name="line-50"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Catalog</span>
<a name="line-51"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NameComponent</span><span class='hs-keyglyph'>]</span>
<a name="line-52"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>LitArg</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-53"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>CatName</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>findMatchingApp</span> <span class='hs-sel'>_d</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>appName</span> <span class='hs-varid'>argTypes</span> <span class='hs-keyglyph'>=</span>
<a name="line-55"></a><span class='hs-varop'>&gt;</span>     <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-56"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- represents a short cut error</span>
<a name="line-57"></a><span class='hs-varop'>&gt;</span>         <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>e</span>
<a name="line-58"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- represents a short cut valid result</span>
<a name="line-59"></a><span class='hs-varop'>&gt;</span>         <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>r</span>
<a name="line-60"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- represents a normal result at the end</span>
<a name="line-61"></a><span class='hs-varop'>&gt;</span>         <span class='hs-conid'>Right</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-62"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span>
</pre>
1. get all the candidates - matching by name


todo: variadic stuff, default stuff
todo: if there are multiple matches with different schemas
     only keep the matches in the first schema in the search path

todo: deal with case and with schemas

todo: polymorphic

<pre><a name="line-63"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>nameMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-64"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>nameMatches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>catLookupFns</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>appName'</span>
<a name="line-65"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- create a map from arg types to prototype</span>
<a name="line-66"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>nameMatchMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>MyFunType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-67"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>nameMatchMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span><span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>nameMatches</span>
<a name="line-68"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>-- the raw input types to match against</span>
<a name="line-69"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>rawArgTypes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>argTypes</span>
</pre>
2. if there is one candidate with the exact args - choose it

<pre><a name="line-70"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>exactMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-71"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>exactMatches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>nameMatchMap</span>
<a name="line-72"></a><span class='hs-varop'>&gt;</span>                                       <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-varid'>rawArgTypes</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span>
</pre>
if this is a binary operator, and one of the types is unknown and the
other is known, and there is onne exact match if the unknown is made
to match the known type, then select it

<pre><a name="line-73"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneKnown</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rawArgTypes</span> <span class='hs-keyword'>of</span>
<a name="line-74"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyglyph'>[</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>,</span><span class='hs-conid'>UnknownType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-75"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyglyph'>[</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>t</span>
<a name="line-76"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span><span class='hs-conid'>UnknownType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>t</span>
<a name="line-77"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-78"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>binaryOpKnownUnknownMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-79"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>binaryOpKnownUnknownMatches</span> <span class='hs-keyglyph'>=</span>
<a name="line-80"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-81"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isOperatorName</span> <span class='hs-varid'>appName'</span>
<a name="line-82"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>oneKnown</span>
<a name="line-83"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>nameMatchMap</span>
<a name="line-84"></a><span class='hs-varop'>&gt;</span>                                       <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>t</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span>
<a name="line-85"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
</pre>
2.5 check for type conversion function?: function name is name of type
    only has one argument, this type is unknown or castable to target

<pre><a name="line-86"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>typeConversionMatch</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-87"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>typeConversionMatch</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>appName'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rawArgTypes</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-88"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span> <span class='hs-comment'>-- todo</span>
</pre>
3. discard candidates which cannot be reached by implicit casts
   convert domains to base types
   keep only candidates which have the most exact matches
     if one: use it
     if none: still consider them all

<pre><a name="line-89"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>reachableViaImplicitCasts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-90"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>reachableViaImplicitCasts</span> <span class='hs-keyglyph'>=</span>
<a name="line-91"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>candReachableViaImplicitCasts</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span>
<a name="line-92"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-varid'>length</span> <span class='hs-varid'>rawArgTypes</span> <span class='hs-varop'>==</span> <span class='hs-varid'>length</span> <span class='hs-keyword'>as</span>
<a name="line-93"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>and</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>canImplicitCastOrSame</span> <span class='hs-varid'>rawArgTypes</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-94"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>nameMatchMap</span>
<a name="line-95"></a><span class='hs-varop'>&gt;</span>                <span class='hs-layout'>(</span><span class='hs-varid'>candReachableViaImplicitCasts</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span>
</pre>
4. keep candidates which accept the most preferred types where type
   conversion is needed: if one, use it
   else continue with all

<pre><a name="line-96"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>acceptsMostPreferredTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-97"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>acceptsMostPreferredTypes</span> <span class='hs-keyglyph'>=</span>
<a name="line-98"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>preferredTypeCounts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span><span class='hs-conid'>MyFunType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-99"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>preferredTypeCounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>map</span> <span class='hs-varid'>reachableViaImplicitCasts</span>
<a name="line-100"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>v</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-101"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>id</span> <span class='hs-varop'>$</span>
<a name="line-102"></a><span class='hs-varop'>&gt;</span>                             <span class='hs-varid'>zipWith</span> <span class='hs-varid'>isCastToPreferred</span> <span class='hs-varid'>rawArgTypes</span> <span class='hs-keyword'>as</span>
<a name="line-103"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-layout'>,</span><span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-104"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>maxCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maximum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>preferredTypeCounts</span>
<a name="line-105"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-varid'>maxCount</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span><span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>preferredTypeCounts</span>
</pre>
Keep all candidates if none accept preferred types. If only one
candidate remains, use it; else continue to the next step.

<pre><a name="line-106"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>acceptsMostPreferredNextStep</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-107"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>acceptsMostPreferredNextStep</span> <span class='hs-keyglyph'>=</span>
<a name="line-108"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>acceptsMostPreferredTypes</span>
<a name="line-109"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>then</span> <span class='hs-varid'>reachableViaImplicitCasts</span>
<a name="line-110"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>else</span> <span class='hs-varid'>acceptsMostPreferredTypes</span>
</pre>
5. if any input types are unknown:
for each unknown

a) select string cat for each position if any cands accept string in
that position

b) if all the cands accept the same category for that position, choose
it, otherwise fail

discard any candidates not matching the selected category (this can
only happen if string was chosen for an unknown)

for each unknown, if any cands accept the preferred type in that
position, drop all the ones which don't accept that type in that
position
if one left: use it
else: keep all for next


transpose the arguments
calculate the category for each argument:
  will be just string if any strings
  will be just cat if all the same cat
  otherwise nothing

This doesn't take into account which positions are unknown in the
input arg list yet.

<pre><a name="line-111"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>transposedCandidateArgs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transpose</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-112"></a><span class='hs-varop'>&gt;</span>                                   <span class='hs-varid'>acceptsMostPreferredNextStep</span>
</pre>
<pre><a name="line-113"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>argumentCategories</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span>
<a name="line-114"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>argumentCategories</span> <span class='hs-keyglyph'>=</span>
<a name="line-115"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>resolveTypeSetCat</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span>
<a name="line-116"></a><span class='hs-varop'>&gt;</span>                     <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-117"></a><span class='hs-varop'>&gt;</span>                      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-str'>"unk"</span>
<a name="line-118"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>catTypeCategory</span> <span class='hs-varid'>cat</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-119"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-layout'>,</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varid'>cs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>c</span>
<a name="line-120"></a><span class='hs-varop'>&gt;</span>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-121"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-varid'>map</span> <span class='hs-varid'>resolveTypeSetCat</span> <span class='hs-varid'>transposedCandidateArgs</span>
</pre>
then: zip with the unknown positions
  if we get any pairs of unknown + nothing for the cat:
  fail with ambiguous error

<pre><a name="line-122"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>chooseCat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span>
<a name="line-123"></a><span class='hs-varop'>&gt;</span>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span>
<a name="line-124"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>chooseCat</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-125"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>,</span><span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span><span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AmbiguousOperator</span> <span class='hs-varid'>appName'</span> <span class='hs-varid'>rawArgTypes</span><span class='hs-keyglyph'>]</span>
<a name="line-126"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>,</span><span class='hs-conid'>Just</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-127"></a><span class='hs-varop'>&gt;</span>              <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-conid'>Nothing</span>
<a name="line-128"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span> <span class='hs-sel'>_argumentCategoriesNeeded</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeError</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span>
<a name="line-129"></a><span class='hs-varop'>&gt;</span>         <span class='hs-sel'>_argumentCategoriesNeeded</span> <span class='hs-keyglyph'>=</span>
<a name="line-130"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varid'>zipWithM</span> <span class='hs-varid'>chooseCat</span> <span class='hs-varid'>rawArgTypes</span> <span class='hs-varid'>argumentCategories</span>
</pre>
TODO: filter the cands by argument categories needed
keep the left, if we need to use bestPreferredMatches then the left
escapes

<pre><a name="line-131"></a><span class='hs-varop'>&gt;</span>         <span class='hs-comment'>{-matchesPreferredCategories =
<a name="line-132"></a>&gt;             let candMatches (_,ts,_,_) cn =
<a name="line-133"></a>&gt;                     catTypeCategory-}</span>
</pre>
then:
  convert the list of just cat to a list of preferred types
  do another transpose of the remaining functions and
  zip with the preferred type
  keep the preferred type as just if any cands match this preferred
   type, otherwise set to nothing

<pre><a name="line-134"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span> <span class='hs-varid'>myIsPreferred</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-135"></a><span class='hs-varop'>&gt;</span>                            <span class='hs-varop'>$</span> <span class='hs-varid'>catPreferredType</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>ty</span>
<a name="line-136"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>choosePreferredType</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span>
<a name="line-137"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>choosePreferredType</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span>
<a name="line-138"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>pts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>myIsPreferred</span> <span class='hs-varid'>ts</span>
<a name="line-139"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>pts</span> <span class='hs-keyword'>of</span>
<a name="line-140"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>t</span>
<a name="line-141"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
</pre>
<pre><a name="line-142"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>preferredTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-143"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>preferredTypes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>choosePreferredType</span> <span class='hs-varid'>transposedCandidateArgs</span>
</pre>

now have a list of just/nothings with justs for the types which have
to match

filter the cands using this just list
now have the final best prefered match list and can
  either return one if there is one
  return ambiguous if there is more than one ?is this possible
  or return ambiguous with the previous list if none get through this
    filter

<pre><a name="line-144"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>matchesPreferred</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>ts</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-145"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-146"></a><span class='hs-varop'>&gt;</span>                 <span class='hs-varid'>f</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>pt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-varop'>==</span> <span class='hs-varid'>pt</span>
<a name="line-147"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-varid'>and</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ts</span> <span class='hs-varid'>preferredTypes</span>
<a name="line-148"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>bestPreferredMatches</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-149"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>bestPreferredMatches</span> <span class='hs-keyglyph'>=</span>
<a name="line-150"></a><span class='hs-varop'>&gt;</span>             <span class='hs-varid'>filter</span> <span class='hs-varid'>matchesPreferred</span> <span class='hs-varid'>acceptsMostPreferredNextStep</span>
</pre>
<pre><a name="line-151"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>bestPreferredMatchesNextStep</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-152"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>bestPreferredMatchesNextStep</span> <span class='hs-keyglyph'>=</span>
<a name="line-153"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bestPreferredMatches</span>
<a name="line-154"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>then</span> <span class='hs-varid'>acceptsMostPreferredTypes</span>
<a name="line-155"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>else</span> <span class='hs-varid'>bestPreferredMatches</span>
</pre>
6. if there are unknown and known, and all the knowns are the same,
assume the unknowns to be this type. If there is one match, use it

<pre><a name="line-156"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>hasUnknown</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>$</span> <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>)</span> <span class='hs-varid'>rawArgTypes</span>
<a name="line-157"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>allKnownsType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span>
<a name="line-158"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>allKnownsType</span> <span class='hs-keyglyph'>=</span>
<a name="line-159"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>let</span> <span class='hs-varid'>allNonUnknowns</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varop'>/=</span><span class='hs-conid'>UnknownType</span><span class='hs-layout'>)</span> <span class='hs-varid'>rawArgTypes</span>
<a name="line-160"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyword'>in</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>allNonUnknowns</span> <span class='hs-keyword'>of</span>
<a name="line-161"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-162"></a><span class='hs-varop'>&gt;</span>                    <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span>
<a name="line-163"></a><span class='hs-varop'>&gt;</span>                           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-164"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>allUnknownsMatchAllKnowns</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>MyFunType</span><span class='hs-keyglyph'>]</span>
<a name="line-165"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>allUnknownsMatchAllKnowns</span> <span class='hs-keyglyph'>=</span>
<a name="line-166"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>[</span><span class='hs-varid'>c</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>c</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>as</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bestPreferredMatchesNextStep</span>
<a name="line-167"></a><span class='hs-varop'>&gt;</span>             <span class='hs-layout'>,</span> <span class='hs-varid'>hasUnknown</span>
<a name="line-168"></a><span class='hs-varop'>&gt;</span>             <span class='hs-layout'>,</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>maybeToList</span> <span class='hs-varid'>allKnownsType</span>
<a name="line-169"></a><span class='hs-varop'>&gt;</span>             <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>of</span>
<a name="line-170"></a><span class='hs-varop'>&gt;</span>                              <span class='hs-conid'>UnknownType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>t</span>
<a name="line-171"></a><span class='hs-varop'>&gt;</span>                              <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>rawArgTypes</span>
<a name="line-172"></a><span class='hs-varop'>&gt;</span>             <span class='hs-layout'>,</span> <span class='hs-keyword'>as</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tys</span>
<a name="line-173"></a><span class='hs-varop'>&gt;</span>             <span class='hs-keyglyph'>]</span>
</pre>
<pre><a name="line-174"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>l</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-str'>"\n"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ppShow</span> <span class='hs-varid'>l</span>
<a name="line-175"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span> <span class='hs-sel'>_showProcess</span> <span class='hs-keyglyph'>=</span>
<a name="line-176"></a><span class='hs-varop'>&gt;</span>           <span class='hs-str'>"Name matches: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>nameMatches</span>
<a name="line-177"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nRaw arg types: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ppShow</span> <span class='hs-varid'>rawArgTypes</span>
<a name="line-178"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nexactMatches: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>exactMatches</span>
<a name="line-179"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nbinaryOpKnownUnknownMatches: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>binaryOpKnownUnknownMatches</span>
<a name="line-180"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\ntypeConversionMatches: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>typeConversionMatch</span>
<a name="line-181"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nreachableViaImplicitCasts: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>reachableViaImplicitCasts</span>
<a name="line-182"></a><span class='hs-varop'>&gt;</span>           <span class='hs-comment'>-- ++ "\n\npreferredTypeCounts: " ++ showl preferredTypeCounts</span>
<a name="line-183"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nacceptsMostPreferredTypes: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>acceptsMostPreferredTypes</span>
<a name="line-184"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nbestPreferredMatches: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>bestPreferredMatches</span>
<a name="line-185"></a><span class='hs-varop'>&gt;</span>           <span class='hs-varop'>++</span> <span class='hs-str'>"\n\nallUnknownsMatchAllKnowns: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showl</span> <span class='hs-varid'>allUnknownsMatchAllKnowns</span>
</pre>
2. exact matches
2.1 binary operator known/unknown special case
2.5 typeConversion matches
4. candidate which accepts most preferred types
5. candidate matching preferred types
6. unknowns match knowns

<pre><a name="line-186"></a><span class='hs-varop'>&gt;</span>     <span class='hs-keyword'>let</span> <span class='hs-varid'>zeroOrOne</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>of</span>
<a name="line-187"></a><span class='hs-varop'>&gt;</span>               <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-conid'>()</span>
<a name="line-188"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-189"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AmbiguousOperator</span> <span class='hs-varid'>appName'</span> <span class='hs-varid'>rawArgTypes</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-190"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>of</span>
<a name="line-191"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-192"></a><span class='hs-varop'>&gt;</span>               <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-conid'>()</span>
<a name="line-193"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>trace</span> <span class='hs-layout'>(</span><span class='hs-sel'>_showProcess</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-194"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>zeroOrOne</span> <span class='hs-varid'>exactMatches</span>
<a name="line-195"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>zeroOrOne</span> <span class='hs-varid'>typeConversionMatch</span>
<a name="line-196"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>binaryOpKnownUnknownMatches</span>
<a name="line-197"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>reachableViaImplicitCasts</span>
<a name="line-198"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>acceptsMostPreferredTypes</span>
<a name="line-199"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>bestPreferredMatches</span>
<a name="line-200"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>oneOrContinue</span> <span class='hs-varid'>allUnknownsMatchAllKnowns</span>
</pre>
otherwise fail

TODO:

When the matching errors, what are the possibilities in user
understandable terms?

1. no functions with that name match
(could return functions with a similar name + show types)

2. have functions which match the name, but the number of args is
wrong:

list the functions + show types
should this show similarly named functions? (what about highlighting
ones with matching arg types?)

3. have functions which have the right # args, but aren't reachable
via implicit casts

could list all the functions, does it make sense to highlight the ones
which can be reached by explicit casts (or are there basically
explicit casts for nearly all pairs of types?)
should this show similarly named functions?
should this show name matches with the wrong number of args

4. I think the only other one that matters is that there are functions
which match via implicit casts, but the system cannot pick a particlar
one
should it also list the other possibilities as above?

Fix the error to contain this information.

<pre><a name="line-201"></a><span class='hs-varop'>&gt;</span>         <span class='hs-conid'>Left</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NoMatchingOperator</span> <span class='hs-varid'>appName'</span> <span class='hs-varid'>rawArgTypes</span><span class='hs-keyglyph'>]</span>
</pre>

<pre><a name="line-202"></a><span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>where</span>
<a name="line-203"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- don't use last</span>
<a name="line-204"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- check for empty list</span>
<a name="line-205"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>appName'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>last</span> <span class='hs-varid'>appName</span> <span class='hs-keyword'>of</span>
<a name="line-206"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>Nmc</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>toLower</span> <span class='hs-varid'>n</span>
<a name="line-207"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>QNmc</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varid'>n</span>
<a name="line-208"></a><span class='hs-varop'>&gt;</span>                <span class='hs-conid'>AntiNameComponent</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- todo: use left instead of error</span>
<a name="line-209"></a><span class='hs-varop'>&gt;</span>                  <span class='hs-varid'>error</span> <span class='hs-str'>"tried to find function matching an antinamecomponent"</span>
<a name="line-210"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>canImplicitCastOrSame</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-211"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>canImplicitCastOrSame</span> <span class='hs-varid'>from</span> <span class='hs-varid'>to</span> <span class='hs-keyglyph'>=</span>
<a name="line-212"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>from</span> <span class='hs-varop'>==</span> <span class='hs-varid'>to</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isRight</span> <span class='hs-layout'>(</span><span class='hs-varid'>catCast</span> <span class='hs-varid'>cat</span> <span class='hs-conid'>ImplicitCastContext</span> <span class='hs-varid'>from</span> <span class='hs-varid'>to</span><span class='hs-layout'>)</span>
<a name="line-213"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- check if casting type 'from' to type 'to' is casting</span>
<a name="line-214"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- to the 'from' type's prefered type in the 'from' type's</span>
<a name="line-215"></a><span class='hs-varop'>&gt;</span>     <span class='hs-comment'>-- category</span>
<a name="line-216"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>isCastToPreferred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-217"></a><span class='hs-varop'>&gt;</span>     <span class='hs-varid'>isCastToPreferred</span> <span class='hs-varid'>from</span> <span class='hs-varid'>to</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe</span> <span class='hs-conid'>False</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-218"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>from</span> <span class='hs-varop'>==</span> <span class='hs-varid'>to</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-219"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isLeft</span> <span class='hs-layout'>(</span><span class='hs-varid'>catPreferredType</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>to</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-220"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>t1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span> <span class='hs-conid'>Just</span>
<a name="line-221"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varop'>$</span> <span class='hs-varid'>catTypeCategory</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>from</span>
<a name="line-222"></a><span class='hs-varop'>&gt;</span>         <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span> <span class='hs-conid'>Just</span>
<a name="line-223"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varop'>$</span> <span class='hs-varid'>catTypeCategory</span> <span class='hs-varid'>cat</span> <span class='hs-varid'>to</span>
<a name="line-224"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyword'>if</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>t2</span>
<a name="line-225"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>()</span>
<a name="line-226"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span>
</pre>
what are all the special cases currently:
special cases for precision
special cases for result null
in OldTypeConverion.findCallMatch:
   between, not between, greatest, least
   rowctor
   .
   comparisons for composite/set types
more stuff in TypeConversion.matchApp
  sql server date stuff
  decode
  something to do with datetimes?
  string precisions?:
    ||, substring, replace
  some nullability special cases?
  jesus, more bullshit, no idea what it is all for
    no tests and documentation as per usual
SqlTypeConversions: special case for implicit casts from text types to
  numeric (see if can handle in rule system)
ScalarExprs.ag
  needs implicit cast
  implicit cast type
  check the types (e.g. cast syntax should use this typeconversion
   machinery)
  tcAppLike: more mssql date shit

  getmaybeintsfromliterals: also suggests only need to support int
    literals in the matchapp function here

on the way out:

we have to add implicit casts for possible nullability and precision
adjustments and work out the result type precision and nullability

dealing with nullable: assume functions are strict, and never return
null if none of the inputs are null. Every function which doesn't work
this way will be special cased here.

precision
precision and scale apply to the following types:
array-style types (will we need 2d arrays?)
numeric
strings
byte arrays

for numeric, the precision and scale for a result are always -1 which
represents the text equivalent for numeric: unlimited scale and
precision.

the precision on a float is fake, and represents a weird short hand to
one of two fixed types, float4 and float8

the precision of char and varchar is the sum of all the precisions of
these in the input by default, lots of special cases here. Also have
literals to deal with.


<pre><a name="line-227"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--resolveResultSetType :: Catalog -&gt; [TypeExtra] -&gt; Either [TypeError] TypeExtra</span>
<a name="line-228"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--resolveResultSetType cat tys = undefined</span>
</pre>

<pre><a name="line-229"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--checkAssignmentValid :: Catalog -&gt; Type -&gt; Type -&gt; Either [TypeError] ()</span>
<a name="line-230"></a><span class='hs-varop'>&gt;</span> <span class='hs-comment'>--checkAssignmentValid cat from to = undefined</span>
</pre>

resolve result set types:
numeric
text
domains
time
precision
nullability

used for union, intersect, except, case, array, values, greatest,
least, join keys


If all inputs are of the same type, and it is not unknown, resolve as
that type.

If any input is of a domain type, treat it as being of the domain's
base type for all subsequent steps. [1]

If all inputs are of type unknown, resolve as type text (the preferred
type of the string category). Otherwise, unknown inputs are ignored.

If the non-unknown inputs are not all of the same type category, fail.

Choose the first non-unknown input type which is a preferred type in
that category, if there is one.

Otherwise, choose the last non-unknown input type that allows all the
preceding non-unknown inputs to be implicitly converted to it. (There
always is such a type, since at least the first type in the list must
satisfy this condition.)

Convert all inputs to the selected type. Fail if there is not a
conversion from a given input to the selected type.



checkassignmentvalid:





also:
text encoding, char set + collations, what else?


TODO: get the list of all the hacks sqream does at the
typechecking sql layer and move it here
</body>
</html>
