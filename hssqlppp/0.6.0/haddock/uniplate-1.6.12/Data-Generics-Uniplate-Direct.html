<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Generics.Uniplate.Direct</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Generics-Uniplate-Direct.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Data-Generics-Uniplate-Direct.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">uniplate-1.6.12: Help writing simple, concise and fast generic operations.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Generics.Uniplate.Direct</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The Combinators</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module supplies a method for writing <code><a href="Data-Generics-Uniplate-Operations.html#t:Uniplate">Uniplate</a></code> and <code><a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a></code> instances.
    This moulde gives the highest performance, but requires many instance definitions. The
    instances can be generated using Derive: <a href="http://community.haskell.org/~ndm/derive/">http://community.haskell.org/~ndm/derive/</a>.</p><p>To take an example:</p><pre>data Expr = Var Int | Pos Expr String | Neg Expr | Add Expr Expr
data Stmt = Seq [Stmt] | Sel [Expr] | Let String Expr

instance Uniplate Expr where
    uniplate (Var x  ) = plate Var |- x
    uniplate (Pos x y) = plate Pos |* x |- y
    uniplate (Neg x  ) = plate Neg |* x
    uniplate (Add x y) = plate Add |* x |* y

instance Biplate Expr Expr where
    biplate = plateSelf

instance Uniplate Stmt where
    uniplate (Seq x  ) = plate Seq ||* x
    uniplate (Sel x  ) = plate Sel ||+ x
    uniplate (Let x y) = plate Let |-  x |- y

instance Biplate Stmt Stmt where
    biplate = plateSelf

instance Biplate Stmt Expr where
    biplate (Seq x  ) = plate Seq ||+ x
    biplate (Sel x  ) = plate Sel ||* x
    biplate (Let x y) = plate Let |-  x |* y</pre><p>To define instances for abstract data types, such as <code>Map</code> or <code>Set</code> from the <code>containers</code> package,
    use <code><a href="Data-Generics-Uniplate-Direct.html#v:plateProject">plateProject</a></code>.</p><p>This module provides a few monomorphic instances of <code><a href="Data-Generics-Uniplate-Operations.html#t:Uniplate">Uniplate</a></code> / <code><a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a></code>
    for common types available in the base library, but does not provide any polymorphic
    instances. Given only monomorphic instances it is trivial to ensure that all instances
    are disjoint, making it easier to add your own instances.</p><p>When defining polymorphic instances, be carefully to mention all potential children.
    Consider <code>Biplate Int (Int, a)</code> - this instance cannot be correct because it will fail
    to return both <code>Int</code> values on <code>(Int,Int)</code>. There are some legitimate polymorphic instances,
    such as <code>Biplate a [a]</code> and <code>Biplate a a</code>, but take care to avoid overlapping instances.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="Data-Generics-Uniplate-Operations.html">Data.Generics.Uniplate.Operations</a></li><li class="src short"><a href="#v:plate">plate</a> :: from -&gt; Type from to</li><li class="src short"><a href="#v:plateSelf">plateSelf</a> :: to -&gt; Type to to</li><li class="src short"><a href="#v:-124--43-">(|+)</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; Type (item -&gt; from) to -&gt; item -&gt; Type from to</li><li class="src short"><a href="#v:-124--45-">(|-)</a> :: Type (item -&gt; from) to -&gt; item -&gt; Type from to</li><li class="src short"><a href="#v:-124--42-">(|*)</a> :: Type (to -&gt; from) to -&gt; to -&gt; Type from to</li><li class="src short"><a href="#v:-124--124--43-">(||+)</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; Type ([item] -&gt; from) to -&gt; [item] -&gt; Type from to</li><li class="src short"><a href="#v:-124--124--42-">(||*)</a> :: Type ([to] -&gt; from) to -&gt; [to] -&gt; Type from to</li><li class="src short"><a href="#v:plateProject">plateProject</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; (from -&gt; item) -&gt; (item -&gt; from) -&gt; from -&gt; Type from to</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src">module <a href="Data-Generics-Uniplate-Operations.html">Data.Generics.Uniplate.Operations</a></p></div><h1 id="g:1">The Combinators</h1><div class="top"><p class="src"><a name="v:plate" class="def">plate</a> :: from -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#plate" class="link">Source</a></p><div class="doc"><p>The main combinator used to start the chain.</p><p>The following rule can be used for optimisation:</p><pre>plate Ctor |- x == plate (Ctor x)</pre></div></div><div class="top"><p class="src"><a name="v:plateSelf" class="def">plateSelf</a> :: to -&gt; Type to to <a href="src/Data-Generics-Uniplate-Direct.html#plateSelf" class="link">Source</a></p><div class="doc"><p>Used for <code><a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a></code> definitions where both types are the same.</p></div></div><div class="top"><p class="src"><a name="v:-124--43-" class="def">(|+)</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; Type (item -&gt; from) to -&gt; item -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#%7C%2B" class="link">Source</a></p><div class="doc"><p>The field to the right may contain the target.</p></div></div><div class="top"><p class="src"><a name="v:-124--45-" class="def">(|-)</a> :: Type (item -&gt; from) to -&gt; item -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#%7C-" class="link">Source</a></p><div class="doc"><p>The field to the right <em>does not</em> contain the target.</p></div></div><div class="top"><p class="src"><a name="v:-124--42-" class="def">(|*)</a> :: Type (to -&gt; from) to -&gt; to -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#%7C%2A" class="link">Source</a></p><div class="doc"><p>The field to the right is the target.</p></div></div><div class="top"><p class="src"><a name="v:-124--124--43-" class="def">(||+)</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; Type ([item] -&gt; from) to -&gt; [item] -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#%7C%7C%2B" class="link">Source</a></p><div class="doc"><p>The field to the right is a list of types which may contain the target</p></div></div><div class="top"><p class="src"><a name="v:-124--124--42-" class="def">(||*)</a> :: Type ([to] -&gt; from) to -&gt; [to] -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#%7C%7C%2A" class="link">Source</a></p><div class="doc"><p>The field to the right is a list of the type of the target</p></div></div><div class="top"><p class="src"><a name="v:plateProject" class="def">plateProject</a> :: <a href="Data-Generics-Uniplate-Operations.html#t:Biplate">Biplate</a> item to =&gt; (from -&gt; item) -&gt; (item -&gt; from) -&gt; from -&gt; Type from to <a href="src/Data-Generics-Uniplate-Direct.html#plateProject" class="link">Source</a></p><div class="doc"><p>Write an instance in terms of a projection/injection pair. Usually used to define instances
   for abstract containers such as Map:</p><pre>instance Biplate (Map.Map [Char] Int) Char where
    biplate = plateProject Map.toList Map.fromList</pre><p>If the types ensure that no operations will not change the keys
   we can use the <code>fromDistictAscList</code> function to reconstruct the Map:</p><pre>instance Biplate (Map.Map [Char] Int) Int where
    biplate = plateProject Map.toAscList Map.fromDistinctAscList</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>