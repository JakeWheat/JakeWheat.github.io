<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>simple-sql-parser examples/test cases - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="main.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#parsertest">parserTest</a><ul>
<li><a href="#valueexprtests">valueExprTests</a><ul>
<li><a href="#literals">literals</a></li>
<li><a href="#identifiers">identifiers</a></li>
<li><a href="#star">star</a></li>
<li><a href="#parameter">parameter</a></li>
<li><a href="#dot">dot</a></li>
<li><a href="#app">app</a></li>
<li><a href="#caseexp">caseexp</a></li>
<li><a href="#operators">operators</a></li>
<li><a href="#parens">parens</a></li>
<li><a href="#unaryoperators-2">unaryOperators</a></li>
<li><a href="#aggregates">aggregates</a></li>
<li><a href="#windowfunctions">windowFunctions</a></li>
</ul></li>
<li><a href="#queryexprcomponenttests">queryExprComponentTests</a><ul>
<li><a href="#duplicates">duplicates</a></li>
<li><a href="#selectlists">selectLists</a></li>
<li><a href="#whereclause">whereClause</a></li>
<li><a href="#having">having</a></li>
<li><a href="#orderby">orderBy</a></li>
<li><a href="#offsetfetch">offsetFetch</a></li>
<li><a href="#combos">combos</a></li>
<li><a href="#with-queries">with queries</a></li>
<li><a href="#values">values</a></li>
<li><a href="#tables">tables</a></li>
</ul></li>
<li><a href="#query-exprs">query exprs</a></li>
<li><a href="#tablereftests">tableRefTests</a></li>
<li><a href="#groupbytests">groupByTests</a><ul>
<li><a href="#simplegroupby">simpleGroupBy</a></li>
<li><a href="#newgroupby">newGroupBy</a></li>
<li><a href="#randomgroupby">randomGroupBy</a></li>
</ul></li>
<li><a href="#queries">queries</a></li>
<li><a href="#postgrestests">postgresTests</a></li>
<li><a href="#parse-tpch">parse tpch</a></li>
<li><a href="#sql-2011-tests">sql 2011 tests</a><ul>
<li><a href="#literals-1">literals</a></li>
<li><a href="#identifiers-1">identifiers</a></li>
<li><a href="#type-names">type names</a></li>
<li><a href="#field-definition">field definition</a></li>
<li><a href="#value-expressions">value expressions</a></li>
<li><a href="#query-expressions">query expressions</a></li>
<li><a href="#scalar-subquery">scalar subquery</a></li>
<li><a href="#predicates">predicates</a></li>
<li><a href="#interval-qualifier">interval qualifier</a></li>
<li><a href="#collate-clause">collate clause</a></li>
<li><a href="#aggregate-function">aggregate function</a></li>
<li><a href="#sort-specification-list">sort specification list</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="parsertest"><a href="#parsertest">parserTest</a></h1>
<h2 id="valueexprtests"><a href="#valueexprtests">valueExprTests</a></h2>
<h3 id="literals"><a href="#literals">literals</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dv">3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dv">3</span>.</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3.&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3.3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3.3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">.<span class="dv">3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;.3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3.e3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3.e3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3.3e3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3.3e3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">.<span class="fl">3e3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;.3e3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3e3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3e3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3e+3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3e+3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">3e-3</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;3e-3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;string&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;string&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;string with a </span><span class="ch">&#39;&#39;</span><span class="st"> quote&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;string with a &#39; quote&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;1&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;1&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;3&#39;</span> <span class="dt">day</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;3&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;3&#39;</span> <span class="dt">day</span> (<span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;3&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> (<span class="kw">Just</span> (<span class="dv">3</span>, <span class="kw">Nothing</span>)), ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;3 weeks&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;interval&quot;</span>]) <span class="st">&quot;3 weeks&quot;</span></code></pre>
</td></tr>
</table>
<h3 id="identifiers"><a href="#identifiers">identifiers</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">iden1</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;iden1&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ot">&quot;quoted identifier&quot;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">QName</span> <span class="st">&quot;quoted identifier&quot;</span>]</code></pre>
</td></tr>
</table>
<h3 id="star"><a href="#star">star</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">*</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Star</span></code></pre>
</td></tr>
</table>
<h3 id="parameter"><a href="#parameter">parameter</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">?</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parameter</span></code></pre>
</td></tr>
</table>
<h3 id="dot"><a href="#dot">dot</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">t.a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">t.*</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a.b.c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ROW</span>(t.*,<span class="dv">42</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
  [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span>, <span class="dt">NumLit</span> <span class="st">&quot;42&quot;</span>]</code></pre>
</td></tr>
</table>
<h3 id="app"><a href="#app">app</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">f()</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>] []</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">f(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">f(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
</table>
<h3 id="caseexp"><a href="#caseexp">caseexp</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">case</span> a <span class="kw">when</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">2</span> <span class="kw">end</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
     caseWhens <span class="fu">=</span> [([<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)], caseElse <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">case</span> a <span class="kw">when</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">2</span> <span class="kw">when</span> <span class="dv">3</span> <span class="kw">then</span> <span class="dv">4</span> <span class="kw">end</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
     caseWhens <span class="fu">=</span>
       [([<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>), ([<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>)],
     caseElse <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">case</span> a <span class="kw">when</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">2</span> <span class="kw">when</span> <span class="dv">3</span> <span class="kw">then</span> <span class="dv">4</span> <span class="kw">else</span> <span class="dv">5</span> <span class="kw">end</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
     caseWhens <span class="fu">=</span>
       [([<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>), ([<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>)],
     caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">case</span> <span class="kw">when</span> a=<span class="dv">1</span> <span class="kw">then</span> <span class="dv">2</span> <span class="kw">when</span> a=<span class="dv">3</span> <span class="kw">then</span> <span class="dv">4</span> <span class="kw">else</span> <span class="dv">5</span> <span class="kw">end</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Nothing</span>,
     caseWhens <span class="fu">=</span>
       [([<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>)], <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>),
        ([<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>)], <span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>)],
     caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">case</span> a <span class="kw">when</span> <span class="dv">1</span>,<span class="dv">2</span> <span class="kw">then</span> <span class="dv">10</span> <span class="kw">when</span> <span class="dv">3</span>,<span class="dv">4</span> <span class="kw">then</span> <span class="dv">20</span> <span class="kw">end</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
     caseWhens <span class="fu">=</span>
       [([<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>),
        ([<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;20&quot;</span>)],
     caseElse <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="operators"><a href="#operators">operators</a></h3>
<h4 id="binaryoperators"><a href="#binaryoperators">binaryOperators</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a + b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a + b * c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
  (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a * b + c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))
  [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="unaryoperators"><a href="#unaryoperators">unaryOperators</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">not</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">not</span> <span class="kw">not</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>] (<span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="operators-1"><a href="#operators-1">operators</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;1&#39;</span> <span class="kw">as</span> <span class="dt">int</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;1&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">int</span> <span class="st">&#39;3&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) <span class="st">&quot;3&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;1&#39;</span> <span class="kw">as</span> <span class="dt">double</span> <span class="dt">precision</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;1&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;1&#39;</span> <span class="kw">as</span> <span class="dt">float</span>(<span class="dv">8</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;1&quot;</span>) (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>] <span class="dv">8</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;1&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;1&quot;</span>) (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">double</span> <span class="dt">precision</span> <span class="st">&#39;3&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) <span class="st">&quot;3&quot;</span></code></pre>
</td></tr>
</table>
<h4 id="unaryoperators-1"><a href="#unaryoperators-1">unaryOperators</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">in</span> (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])
  (<span class="dt">InList</span> [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">null</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is null&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">null</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not null&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is true&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not true&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">false</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is false&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">false</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not false&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> unknown</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is unknown&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> unknown</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not unknown&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">distinct</span> <span class="kw">from</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;is distinct from&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">distinct</span> <span class="kw">from</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;is not distinct from&quot;</span>]
  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">like</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">not</span> <span class="kw">like</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;not like&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> similar <span class="kw">to</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;is similar to&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> similar <span class="kw">to</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;is not similar to&quot;</span>]
  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">overlaps</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;overlaps&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">between</span> b <span class="kw">and</span> c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
  [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">not</span> <span class="kw">between</span> b <span class="kw">and</span> c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;not between&quot;</span>]
  [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">extract</span>(<span class="dt">day</span> <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;extract&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;day&quot;</span>]))
  [(<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">substring(x <span class="kw">from</span> <span class="dv">1</span> <span class="kw">for</span> <span class="dv">2</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]))
  [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>), (<span class="st">&quot;for&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">substring(x <span class="kw">from</span> <span class="dv">1</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]))
  [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>)]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">substring(x <span class="kw">for</span> <span class="dv">2</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]))
  [(<span class="st">&quot;for&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">substring(x <span class="kw">from</span> <span class="dv">1</span> <span class="kw">for</span> <span class="dv">2</span> collate C)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]))
  [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>), (<span class="st">&quot;for&quot;</span>, <span class="dt">Collate</span> (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;C&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">POSITION( string1 <span class="kw">IN</span> string2 )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;position&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;string1&quot;</span>]))
  [(<span class="st">&quot;in&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;string2&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">CONVERT</span>(char_value <span class="kw">USING</span> conversion_char_name)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;convert&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;char_value&quot;</span>]))
  [(<span class="st">&quot;using&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;conversion_char_name&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">TRANSLATE</span>(char_value <span class="kw">USING</span> translation_name)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;translate&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;char_value&quot;</span>]))
  [(<span class="st">&quot;using&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;translation_name&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">OVERLAY(string PLACING embedded_string <span class="kw">FROM</span> <span class="kw">start</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;overlay&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;string&quot;</span>]))
  [(<span class="st">&quot;placing&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;embedded_string&quot;</span>]),
   (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;start&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">OVERLAY(string PLACING embedded_string <span class="kw">FROM</span> <span class="kw">start</span> <span class="kw">FOR</span> <span class="fu">length</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;overlay&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;string&quot;</span>]))
  [(<span class="st">&quot;placing&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;embedded_string&quot;</span>]),
   (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;start&quot;</span>]), (<span class="st">&quot;for&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;length&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;both&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot; &quot;</span>), (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">leading</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;leading&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot; &quot;</span>), (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">trailing</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;trailing&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot; &quot;</span>),
   (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">both</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;both&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot; &quot;</span>), (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">leading</span> <span class="st">&#39;x&#39;</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;leading&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;x&quot;</span>), (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">trailing</span> <span class="st">&#39;y&#39;</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;trailing&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;y&quot;</span>),
   (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">both</span> <span class="st">&#39;z&#39;</span> <span class="kw">from</span> target_string collate C)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;both&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;z&quot;</span>),
   (<span class="st">&quot;from&quot;</span>, <span class="dt">Collate</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;C&quot;</span>])]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">trim</span>(<span class="kw">leading</span> <span class="kw">from</span> target_string)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;trim&quot;</span>] <span class="kw">Nothing</span>
  [(<span class="st">&quot;leading&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot; &quot;</span>), (<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;target_string&quot;</span>])]</code></pre>
</td></tr>
</table>
<h3 id="parens"><a href="#parens">parens</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parens</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a + b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parens</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))</code></pre>
</td></tr>
</table>
<h3 id="unaryoperators-2"><a href="#unaryoperators-2">unaryOperators</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">exists</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">in</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])
  (<span class="dt">InQueryExpr</span>
     (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
             qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
             qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
             qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">not</span> <span class="kw">in</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">In</span> <span class="kw">False</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])
  (<span class="dt">InQueryExpr</span>
     (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
             qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
             qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
             qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &gt; <span class="kw">all</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] <span class="dt">CPAll</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a = <span class="kw">some</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] <span class="dt">CPSome</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &lt;= <span class="kw">any</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>] <span class="dt">CPAny</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h3 id="aggregates"><a href="#aggregates">aggregates</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(*)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a <span class="kw">order</span> <span class="kw">by</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
             aggOrderBy <span class="fu">=</span>
               [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
             aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(<span class="kw">all</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">All</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="windowfunctions"><a href="#windowfunctions">windowFunctions</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">max</span>(a) <span class="kw">over</span> ()</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [], wnOrderBy <span class="fu">=</span> [], wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(*) <span class="kw">over</span> ()</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Star</span>],
          wnPartition <span class="fu">=</span> [], wnOrderBy <span class="fu">=</span> [], wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">max</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], wnOrderBy <span class="fu">=</span> [], wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">max</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]], wnOrderBy <span class="fu">=</span> [],
          wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">order</span> <span class="kw">by</span> b <span class="kw">desc</span>,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c <span class="kw">range</span> <span class="kw">unbounded</span> <span class="kw">preceding</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">FrameFrom</span> <span class="dt">FrameRange</span> <span class="dt">UnboundedPreceding</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c <span class="kw">range</span> <span class="dv">5</span> <span class="kw">preceding</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">FrameFrom</span> <span class="dt">FrameRange</span> (<span class="dt">Preceding</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c <span class="kw">range</span> <span class="kw">current</span> <span class="kw">row</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">FrameFrom</span> <span class="dt">FrameRange</span> <span class="dt">Current</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c <span class="kw">rows</span> <span class="dv">5</span> <span class="kw">following</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">FrameFrom</span> <span class="dt">FrameRows</span> (<span class="dt">Following</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c <span class="kw">range</span> <span class="kw">unbounded</span> <span class="kw">following</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">FrameFrom</span> <span class="dt">FrameRange</span> <span class="dt">UnboundedFollowing</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> b <span class="kw">order</span> <span class="kw">by</span> c 
<span class="kw">range</span> <span class="kw">between</span> <span class="dv">5</span> <span class="kw">preceding</span> <span class="kw">and</span> <span class="dv">5</span> <span class="kw">following</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WindowApp</span>{wnName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], wnArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
          wnPartition <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
          wnOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          wnFrame <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">FrameBetween</span> <span class="dt">FrameRange</span> (<span class="dt">Preceding</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))
                 (<span class="dt">Following</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)))}</code></pre>
</td></tr>
</table>
<h2 id="queryexprcomponenttests"><a href="#queryexprcomponenttests">queryExprComponentTests</a></h2>
<h3 id="duplicates"><a href="#duplicates">duplicates</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="kw">all</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="kw">distinct</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">Distinct</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="selectlists"><a href="#selectlists">selectLists</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="dv">1</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="dv">1+2</span>,<span class="dv">3+4</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>), <span class="kw">Nothing</span>),
          (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>), <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">as</span> a, <span class="co">/*comment*/</span> b <span class="kw">as</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>)),
          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>))],
       qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a a, b b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>)),
          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>))],
       qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a + b * c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])),
           <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="whereclause"><a href="#whereclause">whereClause</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">where</span> a = <span class="dv">5</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="having"><a href="#having">having</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,<span class="fu">sum</span>(b) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a <span class="kw">having</span> <span class="fu">sum</span>(b) &gt; <span class="dv">5</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
       qeHaving <span class="fu">=</span>
         <span class="kw">Just</span>
           (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
              (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="orderby"><a href="#orderby">orderBy</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a, b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a <span class="kw">asc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Asc</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a <span class="kw">desc</span>, b <span class="kw">desc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a <span class="kw">desc</span> <span class="kw">nulls</span> <span class="fu">first</span>, b <span class="kw">desc</span> <span class="kw">nulls</span> <span class="fu">last</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsFirst</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsLast</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="offsetfetch"><a href="#offsetfetch">offsetFetch</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t offset <span class="dv">5</span> <span class="kw">rows</span> fetch <span class="kw">next</span> <span class="dv">10</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>),
       qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t offset <span class="dv">5</span> <span class="kw">rows</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>),
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t fetch <span class="kw">next</span> <span class="dv">10</span> <span class="kw">row</span> <span class="kw">only</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t offset <span class="dv">5</span> <span class="kw">row</span> fetch <span class="fu">first</span> <span class="dv">10</span> <span class="kw">row</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>),
       qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>)}</code></pre>
</td></tr>
</table>
<h3 id="combos"><a href="#combos">combos</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">union</span> <span class="kw">select</span> b <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                 qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                 qe1 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">intersect</span> <span class="kw">select</span> b <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                 qeCombOp <span class="fu">=</span> <span class="dt">Intersect</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                 qe1 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">except</span> <span class="kw">all</span> <span class="kw">select</span> b <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                 qeCombOp <span class="fu">=</span> <span class="dt">Except</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                 qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                 qe1 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">union</span> <span class="kw">distinct</span> corresponding <span class="kw">select</span> b <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                 qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">Distinct</span>,
                 qeCorresponding <span class="fu">=</span> <span class="dt">Corresponding</span>,
                 qe1 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">union</span> <span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">union</span> <span class="kw">select</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                   <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                 qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                 qe1 <span class="fu">=</span>
                   <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                                      <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                             qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                                             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                             qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                             qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                                    qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                    qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                                    qe1 <span class="fu">=</span>
                                      <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                             qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                                             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                             qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                             qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}}</code></pre>
</td></tr>
</table>
<h3 id="with-queries"><a href="#with-queries">with queries</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">with</span> u <span class="kw">as</span> (<span class="kw">select</span> a <span class="kw">from</span> t) <span class="kw">select</span> a <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
     qeViews <span class="fu">=</span>
       [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>,
         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
     qeQueryExpression <span class="fu">=</span>
       <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
              qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
              qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
              qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
              qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">with</span> u(b) <span class="kw">as</span> (<span class="kw">select</span> a <span class="kw">from</span> t) <span class="kw">select</span> a <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
     qeViews <span class="fu">=</span>
       [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
     qeQueryExpression <span class="fu">=</span>
       <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
              qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
              qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
              qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
              qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">with</span> x <span class="kw">as</span> (<span class="kw">select</span> a <span class="kw">from</span> t),
     u <span class="kw">as</span> (<span class="kw">select</span> a <span class="kw">from</span> x)
<span class="kw">select</span> a <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
     qeViews <span class="fu">=</span>
       [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>) <span class="kw">Nothing</span>,
         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}),
        (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>,
         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
     qeQueryExpression <span class="fu">=</span>
       <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
              qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
              qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
              qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
              qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">with</span> recursive u <span class="kw">as</span> (<span class="kw">select</span> a <span class="kw">from</span> t) <span class="kw">select</span> a <span class="kw">from</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
     qeViews <span class="fu">=</span>
       [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>,
         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
     qeQueryExpression <span class="fu">=</span>
       <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
              qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
              qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
              qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
              qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}</code></pre>
</td></tr>
</table>
<h3 id="values"><a href="#values">values</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">values</span> (<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">4</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Values</span> [[<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>], [<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>]]</code></pre>
</td></tr>
</table>
<h3 id="tables"><a href="#tables">tables</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">table</span> tbl</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Table</span> [<span class="dt">Name</span> <span class="st">&quot;tbl&quot;</span>]</code></pre>
</td></tr>
</table>
<h2 id="query-exprs"><a href="#query-exprs">query exprs</a></h2>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="dv">1</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="dv">1</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="dv">1</span>;<span class="kw">select</span> <span class="dv">1</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
 <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"> <span class="kw">select</span> <span class="dv">1</span>;<span class="kw">select</span> <span class="dv">1</span>; </code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
 <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
        qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
        qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
        qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}]</code></pre>
</td></tr>
</table>
<h2 id="tablereftests"><a href="#tablereftests">tableRefTests</a></h2>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> f(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t,u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> s.t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> lateral a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> lateral a,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> a, lateral b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">join</span> lateral b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JInner</span>
            (<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> lateral a <span class="kw">natural</span> <span class="kw">join</span> lateral b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])) <span class="kw">True</span> <span class="dt">JInner</span>
            (<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">inner</span> <span class="kw">join</span> u <span class="kw">on</span> expr</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;expr&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">join</span> u <span class="kw">on</span> expr</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;expr&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">left</span> <span class="kw">join</span> u <span class="kw">on</span> expr</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;expr&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">right</span> <span class="kw">join</span> u <span class="kw">on</span> expr</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JRight</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;expr&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">full</span> <span class="kw">join</span> u <span class="kw">on</span> expr</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JFull</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;expr&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">cross</span> <span class="kw">join</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JCross</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">natural</span> <span class="kw">inner</span> <span class="kw">join</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">True</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">inner</span> <span class="kw">join</span> u <span class="kw">using</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRQueryExpr</span>
            (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                    qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
                    qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                    qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                    qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">as</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t u(b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>])
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> (t <span class="kw">cross</span> <span class="kw">join</span> u) <span class="kw">as</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span>
            (<span class="dt">TRParens</span>
               (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JCross</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
                  <span class="kw">Nothing</span>))
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">cross</span> <span class="kw">join</span> u <span class="kw">cross</span> <span class="kw">join</span> v</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span>
            (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) <span class="kw">False</span> <span class="dt">JCross</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>])
               <span class="kw">Nothing</span>)
            <span class="kw">False</span>
            <span class="dt">JCross</span>
            (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;v&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h2 id="groupbytests"><a href="#groupbytests">groupByTests</a></h2>
<h3 id="simplegroupby"><a href="#simplegroupby">simpleGroupBy</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,<span class="fu">sum</span>(b) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b,<span class="fu">sum</span>(c) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="newgroupby"><a href="#newgroupby">newGroupBy</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> ()</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [<span class="dt">GroupingParens</span> []],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="fu">grouping</span> sets ((), (a))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">GroupingSets</span>
            [<span class="dt">GroupingParens</span> [],
             <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])]]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="kw">cube</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">Cube</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="kw">rollup</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">Rollup</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="randomgroupby"><a href="#randomgroupby">randomGroupBy</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span> [<span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> a,b,c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b),
(a),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(b,a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((b,a),
(b),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">CUBE</span>(a,b,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c),
(a,b),
(a,c),
(b,c),
(a),
(b),
(c),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(Province, County, City)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;City&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(Province, (County, City))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;City&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(Province, (County, City))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;City&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((Province, County, City),
(Province),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;City&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((Province, County, City),
(Province, County),
(Province),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;City&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;County&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Province&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> a, <span class="kw">ROLLUP</span>(b,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c),
(a,b),
(a) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> a, b, <span class="kw">ROLLUP</span>(c,d)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c,d),
(a,b,c),
(a,b) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(a), <span class="kw">ROLLUP</span>(b,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c),
(a,b),
(a),
(b,c),
(b),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(a), <span class="kw">CUBE</span>(b,c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
             <span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c),
(a,b),
(a,c),
(a),
(b,c),
(b),
(c),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">CUBE</span>(a,b), <span class="kw">ROLLUP</span>(c,d)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b,c,d),
(a,b,c),
(a,b),
(a,c,d),
(a,c),
(a),
(b,c,d),
(b,c),
(b),
(c,d),
(c),
() )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> a, <span class="kw">ROLLUP</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]),
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS((a,b),
(a) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
                <span class="dt">GroupingParens</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> Region,
<span class="kw">ROLLUP</span>(Sales_Person, WEEK(Sales_Date)),
<span class="kw">CUBE</span>(<span class="dt">YEAR</span>(Sales_Date), <span class="dt">MONTH</span> (Sales_Date))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Region&quot;</span>]),
             <span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Person&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]])],
             <span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;YEAR&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span> (Region, Sales_Person, WEEK(Sales_Date),
<span class="dt">YEAR</span>(Sales_Date), <span class="dt">MONTH</span>(Sales_Date) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Region&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Person&quot;</span>]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;YEAR&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;Sales_Date&quot;</span>]])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
SALES_PERSON, <span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">WHERE</span> WEEK(SALES_DATE) = <span class="dv">13</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, SALES_PERSON</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;13&quot;</span>)),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
             <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
SALES_PERSON, <span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">WHERE</span> WEEK(SALES_DATE) = <span class="dv">13</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS ( (WEEK(SALES_DATE), SALES_PERSON),
(DAYOFWEEK(SALES_DATE), SALES_PERSON))
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, SALES_PERSON</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;13&quot;</span>)),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>])],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
SALES_PERSON, <span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">WHERE</span> WEEK(SALES_DATE) = <span class="dv">13</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span> ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, SALES_PERSON</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;13&quot;</span>)),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
SALES_PERSON, <span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">WHERE</span> WEEK(SALES_DATE) = <span class="dv">13</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">CUBE</span> ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE), SALES_PERSON )
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, SALES_PERSON</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;13&quot;</span>)),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> SALES_PERSON,
<span class="dt">MONTH</span>(SALES_DATE) <span class="kw">AS</span> <span class="dt">MONTH</span>,
<span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS ( (SALES_PERSON, <span class="dt">MONTH</span>(SALES_DATE)),
()
)
<span class="kw">ORDER</span> <span class="kw">BY</span> SALES_PERSON, <span class="dt">MONTH</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]])],
                <span class="dt">GroupingParens</span> []]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_PERSON&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
<span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span> ( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) )
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="dt">MONTH</span>(SALES_DATE) <span class="kw">AS</span> <span class="dt">MONTH</span>,
REGION,
<span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span> ( <span class="dt">MONTH</span>(SALES_DATE), REGION )
<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">MONTH</span>, REGION</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Rollup</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
<span class="dt">MONTH</span>(SALES_DATE) <span class="kw">AS</span> <span class="dt">MONTH</span>,
REGION,
<span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS ( <span class="kw">ROLLUP</span>( WEEK(SALES_DATE), DAYOFWEEK(SALES_DATE) ),
<span class="kw">ROLLUP</span>( <span class="dt">MONTH</span>(SALES_DATE), REGION ) )
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, <span class="dt">MONTH</span>, REGION</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">Rollup</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]])],
                <span class="dt">Rollup</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                   <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>])]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> R1, R2,
WEEK(SALES_DATE) <span class="kw">AS</span> WEEK,
DAYOFWEEK(SALES_DATE) <span class="kw">AS</span> DAY_WEEK,
<span class="dt">MONTH</span>(SALES_DATE) <span class="kw">AS</span> <span class="dt">MONTH</span>,
REGION, <span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD
<span class="kw">FROM</span> SALES,(<span class="kw">VALUES</span>(<span class="st">&#39;GROUP 1&#39;</span>,<span class="st">&#39;GROUP 2&#39;</span>)) <span class="kw">AS</span> X(R1,R2)
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">GROUPING</span> SETS ((R1, <span class="kw">ROLLUP</span>(WEEK(SALES_DATE),
DAYOFWEEK(SALES_DATE))),
(R2,<span class="kw">ROLLUP</span>( <span class="dt">MONTH</span>(SALES_DATE), REGION ) ))
<span class="kw">ORDER</span> <span class="kw">BY</span> WEEK, DAY_WEEK, <span class="dt">MONTH</span>, REGION</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;R1&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;R2&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>],
             <span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span> (<span class="dt">Values</span> [[<span class="dt">StringLit</span> <span class="st">&quot;GROUP 1&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;GROUP 2&quot;</span>]]))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;X&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;R1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;R2&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">GroupingSets</span>
               [<span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;R1&quot;</span>]),
                   <span class="dt">Rollup</span>
                     [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                      <span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DAYOFWEEK&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]])]],
                <span class="dt">GroupingParens</span>
                  [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;R2&quot;</span>]),
                   <span class="dt">Rollup</span>
                     [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                      <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>])]]]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;DAY_WEEK&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="dt">MONTH</span>(SALES_DATE) <span class="kw">AS</span> <span class="dt">MONTH</span>,
REGION,
<span class="fu">SUM</span>(SALES) <span class="kw">AS</span> UNITS_SOLD,
<span class="fu">MAX</span>(SALES) <span class="kw">AS</span> BEST_SALE,
<span class="fu">CAST</span>(<span class="fu">ROUND</span>(<span class="fu">AVG</span>(DECIMALx(SALES)),<span class="dv">2</span>) <span class="kw">AS</span> <span class="dt">DECIMAL</span>(<span class="dv">5</span>,<span class="dv">2</span>)) <span class="kw">AS</span> AVG_UNITS_SOLD
<span class="kw">FROM</span> SALES
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">CUBE</span>(<span class="dt">MONTH</span>(SALES_DATE),REGION)
<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">MONTH</span>, REGION</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;UNITS_SOLD&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MAX&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;BEST_SALE&quot;</span>)),
             (<span class="dt">Cast</span>
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROUND&quot;</span>]
                   [<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;AVG&quot;</span>] [<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;DECIMALx&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]]],
                    <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>])
                (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">5</span> <span class="dv">2</span>),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;AVG_UNITS_SOLD&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;SALES&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">Cube</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SALES_DATE&quot;</span>]]),
                <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>])]],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;MONTH&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;REGION&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h2 id="queries"><a href="#queries">queries</a></h2>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="fu">count</span>(*) <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a, <span class="fu">sum</span>(c+d) <span class="kw">as</span> s
  <span class="kw">from</span> t,u
  <span class="kw">where</span> a &gt; <span class="dv">5</span>
  <span class="kw">group</span> <span class="kw">by</span> a
  <span class="kw">having</span> <span class="fu">count</span>(<span class="dv">1</span>) &gt; <span class="dv">5</span>
  <span class="kw">order</span> <span class="kw">by</span> s</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
             [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>])],
           <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>))],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
       qeHaving <span class="fu">=</span>
         <span class="kw">Just</span>
           (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h2 id="postgrestests"><a href="#postgrestests">postgresTests</a></h2>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> name, (<span class="kw">SELECT</span> <span class="fu">max</span>(pop) <span class="kw">FROM</span> cities
 <span class="kw">WHERE</span> cities.state = states.name)
    <span class="kw">FROM</span> states;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                        qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;pop&quot;</span>]], <span class="kw">Nothing</span>)],
                        qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;cities&quot;</span>]],
                        qeWhere <span class="fu">=</span>
                          <span class="kw">Just</span>
                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cities&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;state&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;states&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>])),
                        qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                        qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}),
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;states&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">ROW</span>(<span class="dv">1</span>,<span class="fl">2.5</span>,<span class="st">&#39;this is a test&#39;</span>);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2.5&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;this is a test&quot;</span>],
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">ROW</span>(t.*, <span class="dv">42</span>) <span class="kw">FROM</span> t;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span>, <span class="dt">NumLit</span> <span class="st">&quot;42&quot;</span>],
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">ROW</span>(t.f1, t.f2, <span class="dv">42</span>) <span class="kw">FROM</span> t;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;f1&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;f2&quot;</span>],
                 <span class="dt">NumLit</span> <span class="st">&quot;42&quot;</span>],
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> getf1(<span class="fu">CAST</span>(<span class="kw">ROW</span>(<span class="dv">11</span>,<span class="st">&#39;this is a test&#39;</span>,<span class="fl">2.5</span>) <span class="kw">AS</span> myrowtype));</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;getf1&quot;</span>]
                [<span class="dt">Cast</span>
                   (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                      [<span class="dt">NumLit</span> <span class="st">&quot;11&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;this is a test&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2.5&quot;</span>])
                   (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;myrowtype&quot;</span>])],
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">ROW</span>(<span class="dv">1</span>,<span class="fl">2.5</span>,<span class="st">&#39;this is a test&#39;</span>) = <span class="kw">ROW</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="st">&#39;not the same&#39;</span>);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span>
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                   [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2.5&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;this is a test&quot;</span>])
                [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>]
                   [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;not the same&quot;</span>]),
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">ROW</span>(tablex.*) <span class="kw">IS</span> <span class="kw">NULL</span> <span class="kw">FROM</span> tablex;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is null&quot;</span>]
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>] [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tablex&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span>]),
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;tablex&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">true</span> <span class="kw">OR</span> somefunc();</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;somefunc&quot;</span>] []),
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> somefunc() <span class="kw">OR</span> <span class="kw">true</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;somefunc&quot;</span>] []) [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>]),
              <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">CROSS</span> <span class="kw">JOIN</span> t2;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JCross</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               <span class="kw">Nothing</span>],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">INNER</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">INNER</span> <span class="kw">JOIN</span> t2 <span class="kw">USING</span> (num);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">NATURAL</span> <span class="kw">INNER</span> <span class="kw">JOIN</span> t2;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">True</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               <span class="kw">Nothing</span>],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">LEFT</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">LEFT</span> <span class="kw">JOIN</span> t2 <span class="kw">USING</span> (num);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">RIGHT</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JRight</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">FULL</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JFull</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">LEFT</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num <span class="kw">AND</span> t2.value = <span class="st">&#39;xxx&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span>
                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                           (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))
                        [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;value&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                           (<span class="dt">StringLit</span> <span class="st">&quot;xxx&quot;</span>)))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">LEFT</span> <span class="kw">JOIN</span> t2 <span class="kw">ON</span> t1.num = t2.num <span class="kw">WHERE</span> t2.value = <span class="st">&#39;xxx&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>])
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;value&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">StringLit</span> <span class="st">&quot;xxx&quot;</span>)),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> some_very_long_table_name s
<span class="kw">JOIN</span> another_fairly_long_name a <span class="kw">ON</span> s.id = a.num;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;some_very_long_table_name&quot;</span>])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JInner</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;another_fairly_long_name&quot;</span>])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>) <span class="kw">Nothing</span>))
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;num&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> people <span class="kw">AS</span> mother <span class="kw">JOIN</span> people <span class="kw">AS</span> <span class="kw">child</span>
 <span class="kw">ON</span> mother.id = child.mother_id;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;people&quot;</span>])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;mother&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JInner</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;people&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;child&quot;</span>) <span class="kw">Nothing</span>))
               (<span class="kw">Just</span>
                  (<span class="dt">JoinOn</span>
                     (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;mother&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;child&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;mother_id&quot;</span>]))))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> my_table <span class="kw">AS</span> a <span class="kw">CROSS</span> <span class="kw">JOIN</span> my_table <span class="kw">AS</span> b;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;my_table&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JCross</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;my_table&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">Nothing</span>],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> (my_table <span class="kw">AS</span> a <span class="kw">CROSS</span> <span class="kw">JOIN</span> my_table) <span class="kw">AS</span> b;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRParens</span>
                  (<span class="dt">TRJoin</span>
                     (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;my_table&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>) <span class="kw">Nothing</span>))
                     <span class="kw">False</span>
                     <span class="dt">JCross</span>
                     (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;my_table&quot;</span>])
                     <span class="kw">Nothing</span>))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> getfoo(<span class="dv">1</span>) <span class="kw">AS</span> t1;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span> (<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;getfoo&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>])
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> foo
    <span class="kw">WHERE</span> foosubid <span class="kw">IN</span> (
                        <span class="kw">SELECT</span> foosubid
                        <span class="kw">FROM</span> getfoo(foo.fooid) z
                        <span class="kw">WHERE</span> z.fooid = foo.fooid
                      );</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foosubid&quot;</span>])
                 (<span class="dt">InQueryExpr</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foosubid&quot;</span>], <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span>
                              [<span class="dt">TRAlias</span>
                                 (<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;getfoo&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;fooid&quot;</span>]])
                                 (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;z&quot;</span>) <span class="kw">Nothing</span>)],
                            qeWhere <span class="fu">=</span>
                              <span class="kw">Just</span>
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;z&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;fooid&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;fooid&quot;</span>])),
                            qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                            qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> foo, LATERAL (<span class="kw">SELECT</span> * <span class="kw">FROM</span> bar <span class="kw">WHERE</span> bar.id = foo.bar_id) ss;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>],
             <span class="dt">TRLateral</span>
               (<span class="dt">TRAlias</span>
                  (<span class="dt">TRQueryExpr</span>
                     (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                             qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;bar&quot;</span>]],
                             qeWhere <span class="fu">=</span>
                               <span class="kw">Just</span>
                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;bar&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;bar_id&quot;</span>])),
                             qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                             qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;ss&quot;</span>) <span class="kw">Nothing</span>))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> foo, bar <span class="kw">WHERE</span> bar.id = foo.bar_id;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;bar&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;bar&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;foo&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;bar_id&quot;</span>])),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> m.name
<span class="kw">FROM</span> manufacturers m <span class="kw">LEFT</span> <span class="kw">JOIN</span> LATERAL get_product_names(m.id) pname <span class="kw">ON</span> <span class="kw">true</span>
<span class="kw">WHERE</span> pname <span class="kw">IS</span> <span class="kw">NULL</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;manufacturers&quot;</span>])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JLeft</span>
               (<span class="dt">TRLateral</span>
                  (<span class="dt">TRAlias</span>
                     (<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;get_product_names&quot;</span>]
                        [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]])
                     (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>) <span class="kw">Nothing</span>)))
               (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
          qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is null&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>])),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> c1 &gt; <span class="dv">5</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> c1 <span class="kw">IN</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>])
                 (<span class="dt">InList</span> [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>])),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> c1 <span class="kw">IN</span> (<span class="kw">SELECT</span> c1 <span class="kw">FROM</span> t2)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>])
                 (<span class="dt">InQueryExpr</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>], <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                            qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                            qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> c1 <span class="kw">IN</span> (<span class="kw">SELECT</span> c3 <span class="kw">FROM</span> t2 <span class="kw">WHERE</span> c2 = fdt.c1 + <span class="dv">10</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>])
                 (<span class="dt">InQueryExpr</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c3&quot;</span>], <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>]],
                            qeWhere <span class="fu">=</span>
                              <span class="kw">Just</span>
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c2&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>))),
                            qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                            qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> c1 <span class="kw">BETWEEN</span> 
    (<span class="kw">SELECT</span> c3 <span class="kw">FROM</span> t2 <span class="kw">WHERE</span> c2 = fdt.c1 + <span class="dv">10</span>) <span class="kw">AND</span> <span class="dv">100</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                 [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>],
                  <span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c3&quot;</span>], <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>]],
                            qeWhere <span class="fu">=</span>
                              <span class="kw">Just</span>
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c2&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>))),
                            qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                            qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}),
                  <span class="dt">NumLit</span> <span class="st">&quot;100&quot;</span>]),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> fdt <span class="kw">WHERE</span> <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> c1 <span class="kw">FROM</span> t2 <span class="kw">WHERE</span> c2 &gt; fdt.c1)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
                 (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                         qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>], <span class="kw">Nothing</span>)],
                         qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t2&quot;</span>]],
                         qeWhere <span class="fu">=</span>
                           <span class="kw">Just</span>
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c2&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;fdt&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c1&quot;</span>])),
                         qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                         qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> test1;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;test1&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> x <span class="kw">FROM</span> test1 <span class="kw">GROUP</span> <span class="kw">BY</span> x;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;test1&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>])], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> x, <span class="fu">sum</span>(y) <span class="kw">FROM</span> test1 <span class="kw">GROUP</span> <span class="kw">BY</span> x;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;y&quot;</span>]], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;test1&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>])], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> product_id, p.name, (<span class="fu">sum</span>(s.units) * p.price) <span class="kw">AS</span> sales
    <span class="kw">FROM</span> products p <span class="kw">LEFT</span> <span class="kw">JOIN</span> sales s <span class="kw">USING</span> (product_id)
    <span class="kw">GROUP</span> <span class="kw">BY</span> product_id, p.name, p.price;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Parens</span>
                (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;units&quot;</span>]])
                   [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;price&quot;</span>])),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sales&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;products&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JLeft</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;sales&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>) <span class="kw">Nothing</span>))
               (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;price&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> x, <span class="fu">sum</span>(y) <span class="kw">FROM</span> test1 <span class="kw">GROUP</span> <span class="kw">BY</span> x <span class="kw">HAVING</span> <span class="fu">sum</span>(y) &gt; <span class="dv">3</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;y&quot;</span>]], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;test1&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>])],
          qeHaving <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;y&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>)),
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> x, <span class="fu">sum</span>(y) <span class="kw">FROM</span> test1 <span class="kw">GROUP</span> <span class="kw">BY</span> x <span class="kw">HAVING</span> x &lt; <span class="st">&#39;c&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;y&quot;</span>]], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;test1&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>])],
          qeHaving <span class="fu">=</span>
            <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;c&quot;</span>)),
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> product_id, p.name, (<span class="fu">sum</span>(s.units) * (p.price - p.cost)) <span class="kw">AS</span> profit
    <span class="kw">FROM</span> products p <span class="kw">LEFT</span> <span class="kw">JOIN</span> sales s <span class="kw">USING</span> (product_id)
    <span class="kw">WHERE</span> s.datex &gt; <span class="fu">CURRENT_DATE</span> - <span class="dt">INTERVAL</span> <span class="st">&#39;4 weeks&#39;</span>
    <span class="kw">GROUP</span> <span class="kw">BY</span> product_id, p.name, p.price, p.cost
    <span class="kw">HAVING</span> <span class="fu">sum</span>(p.price * s.units) &gt; <span class="dv">5000</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Parens</span>
                (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;units&quot;</span>]])
                   [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;price&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>]
                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;cost&quot;</span>])))),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;profit&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;products&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JLeft</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;sales&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>) <span class="kw">Nothing</span>))
               (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>]))],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;datex&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;CURRENT_DATE&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>]
                    (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;interval&quot;</span>]) <span class="st">&quot;4 weeks&quot;</span>))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product_id&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;price&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;cost&quot;</span>])],
          qeHaving <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                    [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;price&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;units&quot;</span>])])
                 [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                 (<span class="dt">NumLit</span> <span class="st">&quot;5000&quot;</span>)),
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> a, b, c <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> tbl1.a, tbl2.a, tbl1.b <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tbl1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tbl2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tbl1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> tbl1.*, tbl2.a <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tbl1&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span>, <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;tbl2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> a <span class="kw">AS</span> <span class="fu">value</span>, b + c <span class="kw">AS</span> <span class="fu">sum</span> <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;value&quot;</span>)),
             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> a <span class="ot">&quot;value&quot;</span>, b + c <span class="kw">AS</span> <span class="fu">sum</span> <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">QName</span> <span class="st">&quot;value&quot;</span>)),
             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">DISTINCT</span> select_list t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">Distinct</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;select_list&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>))],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">VALUES</span> (<span class="dv">1</span>, <span class="st">&#39;one&#39;</span>), (<span class="dv">2</span>, <span class="st">&#39;two&#39;</span>), (<span class="dv">3</span>, <span class="st">&#39;three&#39;</span>);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Values</span>
     [[<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;one&quot;</span>], [<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;two&quot;</span>],
      [<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;three&quot;</span>]])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> column1, <span class="st">&#39;one&#39;</span> <span class="kw">AS</span> column2
<span class="kw">UNION</span> <span class="kw">ALL</span>
<span class="kw">SELECT</span> <span class="dv">2</span>, <span class="st">&#39;two&#39;</span>
<span class="kw">UNION</span> <span class="kw">ALL</span>
<span class="kw">SELECT</span> <span class="dv">3</span>, <span class="st">&#39;three&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                      <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                             qeSelectList <span class="fu">=</span>
                               [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;column1&quot;</span>)),
                                (<span class="dt">StringLit</span> <span class="st">&quot;one&quot;</span>, <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;column2&quot;</span>))],
                             qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                             qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                    qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                    qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                    qe1 <span class="fu">=</span>
                      <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                                         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                                qeSelectList <span class="fu">=</span>
                                                  [(<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="kw">Nothing</span>),
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;two&quot;</span>, <span class="kw">Nothing</span>)],
                                                qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                                                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                                qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                                       qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                                       qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                                       qe1 <span class="fu">=</span>
                                         <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                                qeSelectList <span class="fu">=</span>
                                                  [(<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="kw">Nothing</span>),
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;three&quot;</span>, <span class="kw">Nothing</span>)],
                                                qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                                                qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                                qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> (<span class="kw">VALUES</span> (<span class="dv">1</span>, <span class="st">&#39;one&#39;</span>), (<span class="dv">2</span>, <span class="st">&#39;two&#39;</span>), (<span class="dv">3</span>, <span class="st">&#39;three&#39;</span>)) <span class="kw">AS</span> t (num,letter);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Values</span>
                     [[<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;one&quot;</span>], [<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;two&quot;</span>],
                      [<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;three&quot;</span>]]))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;num&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;letter&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> regional_sales <span class="kw">AS</span> (
        <span class="kw">SELECT</span> region, <span class="fu">SUM</span>(amount) <span class="kw">AS</span> total_sales
        <span class="kw">FROM</span> orders
        <span class="kw">GROUP</span> <span class="kw">BY</span> region
     ), top_regions <span class="kw">AS</span> (
        <span class="kw">SELECT</span> region
        <span class="kw">FROM</span> regional_sales
        <span class="kw">WHERE</span> total_sales &gt; (<span class="kw">SELECT</span> <span class="fu">SUM</span>(total_sales)/<span class="dv">10</span> <span class="kw">FROM</span> regional_sales)
     )
<span class="kw">SELECT</span> region,
       product,
       <span class="fu">SUM</span>(quantity) <span class="kw">AS</span> product_units,
       <span class="fu">SUM</span>(amount) <span class="kw">AS</span> product_sales
<span class="kw">FROM</span> orders
<span class="kw">WHERE</span> region <span class="kw">IN</span> (<span class="kw">SELECT</span> region <span class="kw">FROM</span> top_regions)
<span class="kw">GROUP</span> <span class="kw">BY</span> region, product;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;regional_sales&quot;</span>) <span class="kw">Nothing</span>,
            <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                   qeSelectList <span class="fu">=</span>
                     [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>], <span class="kw">Nothing</span>),
                      (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;amount&quot;</span>]],
                       <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;total_sales&quot;</span>))],
                   qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                   qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>])],
                   qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                   qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}),
           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;top_regions&quot;</span>) <span class="kw">Nothing</span>,
            <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                   qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>], <span class="kw">Nothing</span>)],
                   qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;regional_sales&quot;</span>]],
                   qeWhere <span class="fu">=</span>
                     <span class="kw">Just</span>
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;total_sales&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                          (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                             (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                     qeSelectList <span class="fu">=</span>
                                       [(<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;total_sales&quot;</span>]])
                                           [<span class="dt">Name</span> <span class="st">&quot;/&quot;</span>]
                                           (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>),
                                         <span class="kw">Nothing</span>)],
                                     qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;regional_sales&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                     qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                     qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
                   qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                   qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span>
                   [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;quantity&quot;</span>]],
                     <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;product_units&quot;</span>)),
                    (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;amount&quot;</span>]],
                     <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;product_sales&quot;</span>))],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>]],
                 qeWhere <span class="fu">=</span>
                   <span class="kw">Just</span>
                     (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>])
                        (<span class="dt">InQueryExpr</span>
                           (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                   qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>], <span class="kw">Nothing</span>)],
                                   qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;top_regions&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                   qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                   qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
                 qeGroupBy <span class="fu">=</span>
                   [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>]),
                    <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;product&quot;</span>])],
                 qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> RECURSIVE t(n) <span class="kw">AS</span> (
    <span class="kw">VALUES</span> (<span class="dv">1</span>)
  <span class="kw">UNION</span> <span class="kw">ALL</span>
    <span class="kw">SELECT</span> n<span class="dv">+1</span> <span class="kw">FROM</span> t <span class="kw">WHERE</span> n &lt; <span class="dv">100</span>
)
<span class="kw">SELECT</span> <span class="fu">sum</span>(n) <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]),
            <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span> <span class="dt">Values</span> [[<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>]], qeCombOp <span class="fu">=</span> <span class="dt">Union</span>,
                             qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>, qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                             qe1 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>),
                                          <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;100&quot;</span>)),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]], <span class="kw">Nothing</span>)],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                 qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> RECURSIVE included_parts(sub_part, part, quantity) <span class="kw">AS</span> (
    <span class="kw">SELECT</span> sub_part, part, quantity <span class="kw">FROM</span> parts <span class="kw">WHERE</span> part = <span class="st">&#39;our_product&#39;</span>
  <span class="kw">UNION</span> <span class="kw">ALL</span>
    <span class="kw">SELECT</span> p.sub_part, p.part, p.quantity
    <span class="kw">FROM</span> included_parts pr, parts p
    <span class="kw">WHERE</span> p.part = pr.sub_part
  )
<span class="kw">SELECT</span> sub_part, <span class="fu">SUM</span>(quantity) <span class="kw">as</span> total_quantity
<span class="kw">FROM</span> included_parts
<span class="kw">GROUP</span> <span class="kw">BY</span> sub_part</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;included_parts&quot;</span>)
              (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;part&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;quantity&quot;</span>]),
            <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;quantity&quot;</span>], <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;parts&quot;</span>]],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span>
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">StringLit</span> <span class="st">&quot;our_product&quot;</span>)),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                             qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                             qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                             qe1 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;part&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;quantity&quot;</span>], <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span>
                                        [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;included_parts&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;pr&quot;</span>) <span class="kw">Nothing</span>),
                                         <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;parts&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>) <span class="kw">Nothing</span>)],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span>
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;pr&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>])),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span>
                   [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;quantity&quot;</span>]],
                     <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;total_quantity&quot;</span>))],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;included_parts&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;sub_part&quot;</span>])],
                 qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> RECURSIVE search_graph(<span class="kw">id</span>, <span class="kw">link</span>, <span class="kw">data</span>, <span class="fu">depth</span>) <span class="kw">AS</span> (
        <span class="kw">SELECT</span> g.id, g.link, g.data, <span class="dv">1</span>
        <span class="kw">FROM</span> graph g
      <span class="kw">UNION</span> <span class="kw">ALL</span>
        <span class="kw">SELECT</span> g.id, g.link, g.data, sg.depth + <span class="dv">1</span>
        <span class="kw">FROM</span> graph g, search_graph sg
        <span class="kw">WHERE</span> g.id = sg.link
)
<span class="kw">SELECT</span> * <span class="kw">FROM</span> search_graph;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;search_graph&quot;</span>)
              (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;id&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;link&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;data&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;depth&quot;</span>]),
            <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;link&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;data&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span>
                                        [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;graph&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>) <span class="kw">Nothing</span>)],
                                      qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                                      qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                             qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                             qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                             qe1 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;link&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;data&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;sg&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;depth&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                                            (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>),
                                          <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span>
                                        [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;graph&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>) <span class="kw">Nothing</span>),
                                         <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;search_graph&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;sg&quot;</span>) <span class="kw">Nothing</span>)],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span>
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;g&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;sg&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;link&quot;</span>])),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;search_graph&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                 qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> RECURSIVE t(n) <span class="kw">AS</span> (
    <span class="kw">SELECT</span> <span class="dv">1</span>
  <span class="kw">UNION</span> <span class="kw">ALL</span>
    <span class="kw">SELECT</span> n<span class="dv">+1</span> <span class="kw">FROM</span> t
)
<span class="kw">SELECT</span> n <span class="kw">FROM</span> t <span class="co">--LIMIT 100;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]),
            <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span> [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [],
                                      qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                                      qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                             qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                             qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                             qe1 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>),
                                          <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n&quot;</span>], <span class="kw">Nothing</span>)],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
                 qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> f.title, f.did, d.name, f.date_prod, f.kind
    <span class="kw">FROM</span> distributors d, films f
    <span class="kw">WHERE</span> f.did = d.did</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;title&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;did&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;date_prod&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;kind&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>])
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>) <span class="kw">Nothing</span>),
             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;films&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;did&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                 (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;did&quot;</span>])),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> kind, <span class="fu">sum</span>(len) <span class="kw">AS</span> total
    <span class="kw">FROM</span> films
    <span class="kw">GROUP</span> <span class="kw">BY</span> kind
    <span class="kw">HAVING</span> <span class="fu">sum</span>(len) &lt; <span class="dt">interval</span> <span class="st">&#39;5 hours&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;kind&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;len&quot;</span>]], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;total&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;films&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;kind&quot;</span>])],
          qeHaving <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;len&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                 (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;interval&quot;</span>]) <span class="st">&quot;5 hours&quot;</span>)),
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> distributors <span class="kw">ORDER</span> <span class="kw">BY</span> name;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;name&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> distributors <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dv">2</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [<span class="dt">SortSpec</span> (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> distributors.name
    <span class="kw">FROM</span> distributors
    <span class="kw">WHERE</span> distributors.name <span class="kw">LIKE</span> <span class="st">&#39;W%&#39;</span>
<span class="kw">UNION</span>
<span class="kw">SELECT</span> actors.name
    <span class="kw">FROM</span> actors
    <span class="kw">WHERE</span> actors.name <span class="kw">LIKE</span> <span class="st">&#39;W%&#39;</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                      <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                             qeSelectList <span class="fu">=</span>
                               [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>)],
                             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>]],
                             qeWhere <span class="fu">=</span>
                               <span class="kw">Just</span>
                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;distributors&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                    (<span class="dt">StringLit</span> <span class="st">&quot;W%&quot;</span>)),
                             qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                             qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                    qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                    qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                    qe1 <span class="fu">=</span>
                      <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                             qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;actors&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Nothing</span>)],
                             qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;actors&quot;</span>]],
                             qeWhere <span class="fu">=</span>
                               <span class="kw">Just</span>
                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;actors&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                    (<span class="dt">StringLit</span> <span class="st">&quot;W%&quot;</span>)),
                             qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                             qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> t <span class="kw">AS</span> (
    <span class="kw">SELECT</span> <span class="kw">random</span>() <span class="kw">as</span> x <span class="kw">FROM</span> generate_series(<span class="dv">1</span>, <span class="dv">3</span>)
  )
<span class="kw">SELECT</span> * <span class="kw">FROM</span> t
<span class="kw">UNION</span> <span class="kw">ALL</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>) <span class="kw">Nothing</span>,
            <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                   qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;random&quot;</span>] [], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>))],
                   qeFrom <span class="fu">=</span>
                     [<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;generate_series&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>]],
                   qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                   qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                             <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                    qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                                    qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                    qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                    qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                           qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                           qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                           qe1 <span class="fu">=</span>
                             <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                    qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                                    qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                    qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                    qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">WITH</span> RECURSIVE employee_recursive(distance, employee_name, manager_name) <span class="kw">AS</span> (
    <span class="kw">SELECT</span> <span class="dv">1</span>, employee_name, manager_name
    <span class="kw">FROM</span> employee
    <span class="kw">WHERE</span> manager_name = <span class="st">&#39;Mary&#39;</span>
  <span class="kw">UNION</span> <span class="kw">ALL</span>
    <span class="kw">SELECT</span> er.distance + <span class="dv">1</span>, e.employee_name, e.manager_name
    <span class="kw">FROM</span> employee_recursive er, employee e
    <span class="kw">WHERE</span> er.employee_name = e.manager_name
  )
<span class="kw">SELECT</span> distance, employee_name <span class="kw">FROM</span> employee_recursive;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">True</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;employee_recursive&quot;</span>)
              (<span class="kw">Just</span>
                 [<span class="dt">Name</span> <span class="st">&quot;distance&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;employee_name&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;manager_name&quot;</span>]),
            <span class="dt">CombineQueryExpr</span>{qe0 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;employee_name&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;manager_name&quot;</span>], <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;employee&quot;</span>]],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span>
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;manager_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">StringLit</span> <span class="st">&quot;Mary&quot;</span>)),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>},
                             qeCombOp <span class="fu">=</span> <span class="dt">Union</span>, qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
                             qeCorresponding <span class="fu">=</span> <span class="dt">Respectively</span>,
                             qe1 <span class="fu">=</span>
                               <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;er&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;distance&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                                            (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>),
                                          <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;e&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;employee_name&quot;</span>], <span class="kw">Nothing</span>),
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;e&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;manager_name&quot;</span>], <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span>
                                        [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;employee_recursive&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;er&quot;</span>) <span class="kw">Nothing</span>),
                                         <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;employee&quot;</span>])
                                           (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;e&quot;</span>) <span class="kw">Nothing</span>)],
                                      qeWhere <span class="fu">=</span>
                                        <span class="kw">Just</span>
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;er&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;employee_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;e&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;manager_name&quot;</span>])),
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span>
                   [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;distance&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;employee_name&quot;</span>], <span class="kw">Nothing</span>)],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;employee_recursive&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                 qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> m.name <span class="kw">AS</span> mname, pname
<span class="kw">FROM</span> manufacturers m, LATERAL get_product_names(m.id) pname;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;mname&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;manufacturers&quot;</span>])
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>) <span class="kw">Nothing</span>),
             <span class="dt">TRLateral</span>
               (<span class="dt">TRAlias</span>
                  (<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;get_product_names&quot;</span>]
                     [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>) <span class="kw">Nothing</span>))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> m.name <span class="kw">AS</span> mname, pname
<span class="kw">FROM</span> manufacturers m <span class="kw">LEFT</span> <span class="kw">JOIN</span> LATERAL get_product_names(m.id) pname <span class="kw">ON</span> <span class="kw">true</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;mname&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRJoin</span>
               (<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;manufacturers&quot;</span>])
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>) <span class="kw">Nothing</span>))
               <span class="kw">False</span>
               <span class="dt">JLeft</span>
               (<span class="dt">TRLateral</span>
                  (<span class="dt">TRAlias</span>
                     (<span class="dt">TRFunction</span> [<span class="dt">Name</span> <span class="st">&quot;get_product_names&quot;</span>]
                        [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;m&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;id&quot;</span>]])
                     (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;pname&quot;</span>) <span class="kw">Nothing</span>)))
               (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="dv">2+2</span>;</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>), <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h2 id="parse-tpch"><a href="#parse-tpch">parse tpch</a></h2>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
<span class="kw">select</span>
        l_returnflag,
        l_linestatus,
        <span class="fu">sum</span>(l_quantity) <span class="kw">as</span> sum_qty,
        <span class="fu">sum</span>(l_extendedprice) <span class="kw">as</span> sum_base_price,
        <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> sum_disc_price,
        <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount) * (<span class="dv">1</span> + l_tax)) <span class="kw">as</span> sum_charge,
        <span class="fu">avg</span>(l_quantity) <span class="kw">as</span> avg_qty,
        <span class="fu">avg</span>(l_extendedprice) <span class="kw">as</span> avg_price,
        <span class="fu">avg</span>(l_discount) <span class="kw">as</span> avg_disc,
        <span class="fu">count</span>(*) <span class="kw">as</span> count_order
<span class="kw">from</span>
        lineitem
<span class="kw">where</span>
        l_shipdate &lt;= <span class="dt">date</span> <span class="st">&#39;1998-12-01&#39;</span> - <span class="dt">interval</span> <span class="st">&#39;63&#39;</span> <span class="dt">day</span> (<span class="dv">3</span>)
<span class="kw">group</span> <span class="kw">by</span>
        l_returnflag,
        l_linestatus
<span class="kw">order</span> <span class="kw">by</span>
        l_returnflag,
        l_linestatus</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_returnflag&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_linestatus&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum_qty&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum_base_price&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum_disc_price&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span>
                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                      (<span class="dt">Parens</span>
                         (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]))))
                   [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span> (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_tax&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum_charge&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;avg_qty&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;avg_price&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;avg_disc&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;count_order&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1998-12-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>]
                    (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;63&quot;</span>,
                                 ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> (<span class="kw">Just</span> (<span class="dv">3</span>, <span class="kw">Nothing</span>)), ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_returnflag&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_linestatus&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_returnflag&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_linestatus&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
<span class="kw">select</span>
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
<span class="kw">from</span>
        part,
        supplier,
        partsupp,
        nation,
        region
<span class="kw">where</span>
        p_partkey = ps_partkey
        <span class="kw">and</span> s_suppkey = ps_suppkey
        <span class="kw">and</span> p_size = <span class="dv">15</span>
        <span class="kw">and</span> p_type <span class="kw">like</span> <span class="st">&#39;%BRASS&#39;</span>
        <span class="kw">and</span> s_nationkey = n_nationkey
        <span class="kw">and</span> n_regionkey = r_regionkey
        <span class="kw">and</span> r_name = <span class="st">&#39;EUROPE&#39;</span>
        <span class="kw">and</span> ps_supplycost = (
                <span class="kw">select</span>
                        <span class="fu">min</span>(ps_supplycost)
                <span class="kw">from</span>
                        partsupp,
                        supplier,
                        nation,
                        region
                <span class="kw">where</span>
                        p_partkey = ps_partkey
                        <span class="kw">and</span> s_suppkey = ps_suppkey
                        <span class="kw">and</span> s_nationkey = n_nationkey
                        <span class="kw">and</span> n_regionkey = r_regionkey
                        <span class="kw">and</span> r_name = <span class="st">&#39;EUROPE&#39;</span>
        )
<span class="kw">order</span> <span class="kw">by</span>
        s_acctbal <span class="kw">desc</span>,
        n_name,
        s_name,
        p_partkey
fetch <span class="fu">first</span> <span class="dv">100</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_acctbal&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_mfgr&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_address&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_phone&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_comment&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>]))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>])))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;15&quot;</span>)))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;%BRASS&quot;</span>)))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_regionkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_regionkey&quot;</span>])))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;EUROPE&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                    (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                       (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                               qeSelectList <span class="fu">=</span>
                                 [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;min&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]], <span class="kw">Nothing</span>)],
                               qeFrom <span class="fu">=</span>
                                 [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
                                  <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>]],
                               qeWhere <span class="fu">=</span>
                                 <span class="kw">Just</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span>
                                         (<span class="dt">BinOp</span>
                                            (<span class="dt">BinOp</span>
                                               (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>]))
                                               [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                               (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>])))
                                            [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_regionkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                            (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_regionkey&quot;</span>])))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                         (<span class="dt">StringLit</span> <span class="st">&quot;EUROPE&quot;</span>))),
                               qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                               qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_acctbal&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;100&quot;</span>)})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         l_orderkey,
         <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> revenue,
         o_orderdate,
         o_shippriority
 <span class="kw">from</span>
         customer,
         orders,
         lineitem
 <span class="kw">where</span>
         c_mktsegment = <span class="st">&#39;MACHINERY&#39;</span>
         <span class="kw">and</span> c_custkey = o_custkey
         <span class="kw">and</span> l_orderkey = o_orderkey
         <span class="kw">and</span> o_orderdate &lt; <span class="dt">date</span> <span class="st">&#39;1995-03-21&#39;</span>
         <span class="kw">and</span> l_shipdate &gt; <span class="dt">date</span> <span class="st">&#39;1995-03-21&#39;</span>
 <span class="kw">group</span> <span class="kw">by</span>
         l_orderkey,
         o_orderdate,
         o_shippriority
 <span class="kw">order</span> <span class="kw">by</span>
         revenue <span class="kw">desc</span>,
         o_orderdate
 fetch <span class="fu">first</span> <span class="dv">10</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_shippriority&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_mktsegment&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">StringLit</span> <span class="st">&quot;MACHINERY&quot;</span>))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>])))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>])))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                       (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-03-21&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                    (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-03-21&quot;</span>))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_shippriority&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>)})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         o_orderpriority,
         <span class="fu">count</span>(*) <span class="kw">as</span> order_count
 <span class="kw">from</span>
         orders
 <span class="kw">where</span>
         o_orderdate &gt;= <span class="dt">date</span> <span class="st">&#39;1996-03-01&#39;</span>
         <span class="kw">and</span> o_orderdate &lt; <span class="dt">date</span> <span class="st">&#39;1996-03-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;3&#39;</span> <span class="dt">month</span>
         <span class="kw">and</span> <span class="kw">exists</span> (
                 <span class="kw">select</span>
                         *
                 <span class="kw">from</span>
                         lineitem
                 <span class="kw">where</span>
                         l_orderkey = o_orderkey
                         <span class="kw">and</span> l_commitdate &lt; l_receiptdate
         )
 <span class="kw">group</span> <span class="kw">by</span>
         o_orderpriority
 <span class="kw">order</span> <span class="kw">by</span>
         o_orderpriority</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;order_count&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                       (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1996-03-01&quot;</span>))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1996-03-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                          (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;3&quot;</span>,
                                       ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}))))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
                            qeWhere <span class="fu">=</span>
                              <span class="kw">Just</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_commitdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>]))),
                            qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                            qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>]) <span class="dt">DirDefault</span>
               <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         n_name,
         <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> revenue
 <span class="kw">from</span>
         customer,
         orders,
         lineitem,
         supplier,
         nation,
         region
 <span class="kw">where</span>
         c_custkey = o_custkey
         <span class="kw">and</span> l_orderkey = o_orderkey
         <span class="kw">and</span> l_suppkey = s_suppkey
         <span class="kw">and</span> c_nationkey = s_nationkey
         <span class="kw">and</span> s_nationkey = n_nationkey
         <span class="kw">and</span> n_regionkey = r_regionkey
         <span class="kw">and</span> r_name = <span class="st">&#39;EUROPE&#39;</span>
         <span class="kw">and</span> o_orderdate &gt;= <span class="dt">date</span> <span class="st">&#39;1997-01-01&#39;</span>
         <span class="kw">and</span> o_orderdate &lt; <span class="dt">date</span> <span class="st">&#39;1997-01-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span>
 <span class="kw">group</span> <span class="kw">by</span>
         n_name
 <span class="kw">order</span> <span class="kw">by</span>
         revenue <span class="kw">desc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>]))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>])))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>])))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>])))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_regionkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_regionkey&quot;</span>])))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;EUROPE&quot;</span>)))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                       (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1997-01-01&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1997-01-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                       (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
                                    ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         <span class="fu">sum</span>(l_extendedprice * l_discount) <span class="kw">as</span> revenue
 <span class="kw">from</span>
         lineitem
 <span class="kw">where</span>
         l_shipdate &gt;= <span class="dt">date</span> <span class="st">&#39;1997-01-01&#39;</span>
         <span class="kw">and</span> l_shipdate &lt; <span class="dt">date</span> <span class="st">&#39;1997-01-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span>
         <span class="kw">and</span> l_discount <span class="kw">between</span> <span class="fl">0.07</span> - <span class="fl">0.01</span> <span class="kw">and</span> <span class="fl">0.07</span> + <span class="fl">0.01</span>
         <span class="kw">and</span> l_quantity &lt; <span class="dv">24</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                          (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1997-01-01&quot;</span>))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1997-01-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                             (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
                                          ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}))))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                       [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>],
                        <span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;0.07&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;0.01&quot;</span>),
                        <span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;0.07&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;0.01&quot;</span>)]))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;24&quot;</span>))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         supp_nation,
         cust_nation,
         l_year,
         <span class="fu">sum</span>(volume) <span class="kw">as</span> revenue
 <span class="kw">from</span>
         (
                 <span class="kw">select</span>
                         n1.n_name <span class="kw">as</span> supp_nation,
                         n2.n_name <span class="kw">as</span> cust_nation,
                         <span class="fu">extract</span>(<span class="dt">year</span> <span class="kw">from</span> l_shipdate) <span class="kw">as</span> l_year,
                         l_extendedprice * (<span class="dv">1</span> - l_discount) <span class="kw">as</span> volume
                 <span class="kw">from</span>
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2
                 <span class="kw">where</span>
                         s_suppkey = l_suppkey
                         <span class="kw">and</span> o_orderkey = l_orderkey
                         <span class="kw">and</span> c_custkey = o_custkey
                         <span class="kw">and</span> s_nationkey = n1.n_nationkey
                         <span class="kw">and</span> c_nationkey = n2.n_nationkey
                         <span class="kw">and</span> (
                                 (n1.n_name = <span class="st">&#39;PERU&#39;</span> <span class="kw">and</span> n2.n_name = <span class="st">&#39;IRAQ&#39;</span>)
                                 <span class="kw">or</span> (n1.n_name = <span class="st">&#39;IRAQ&#39;</span> <span class="kw">and</span> n2.n_name = <span class="st">&#39;PERU&#39;</span>)
                         )
                         <span class="kw">and</span> l_shipdate <span class="kw">between</span> <span class="dt">date</span> <span class="st">&#39;1995-01-01&#39;</span> <span class="kw">and</span> <span class="dt">date</span> <span class="st">&#39;1996-12-31&#39;</span>
         ) <span class="kw">as</span> shipping
 <span class="kw">group</span> <span class="kw">by</span>
         supp_nation,
         cust_nation,
         l_year
 <span class="kw">order</span> <span class="kw">by</span>
         supp_nation,
         cust_nation,
         l_year</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;supp_nation&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cust_nation&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_year&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;volume&quot;</span>]], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span>
                            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;supp_nation&quot;</span>)),
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;cust_nation&quot;</span>)),
                             (<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;extract&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;year&quot;</span>]))
                                [(<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>])],
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;l_year&quot;</span>)),
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                (<span class="dt">Parens</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]))),
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;volume&quot;</span>))],
                          qeFrom <span class="fu">=</span>
                            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>],
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>],
                             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>) <span class="kw">Nothing</span>),
                             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>) <span class="kw">Nothing</span>)],
                          qeWhere <span class="fu">=</span>
                            <span class="kw">Just</span>
                              (<span class="dt">BinOp</span>
                                 (<span class="dt">BinOp</span>
                                    (<span class="dt">BinOp</span>
                                       (<span class="dt">BinOp</span>
                                          (<span class="dt">BinOp</span>
                                             (<span class="dt">BinOp</span>
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]))
                                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>])))
                                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>])))
                                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                    (<span class="dt">Parens</span>
                                       (<span class="dt">BinOp</span>
                                          (<span class="dt">Parens</span>
                                             (<span class="dt">BinOp</span>
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;PERU&quot;</span>))
                                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;IRAQ&quot;</span>))))
                                          [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                                          (<span class="dt">Parens</span>
                                             (<span class="dt">BinOp</span>
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;IRAQ&quot;</span>))
                                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">StringLit</span> <span class="st">&quot;PERU&quot;</span>)))))))
                                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                 (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                                    [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>],
                                     <span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-01-01&quot;</span>,
                                     <span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1996-12-31&quot;</span>])),
                          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;shipping&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;supp_nation&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cust_nation&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_year&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;supp_nation&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cust_nation&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_year&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         o_year,
         <span class="fu">sum</span>(<span class="kw">case</span>
                 <span class="kw">when</span> nation = <span class="st">&#39;IRAQ&#39;</span> <span class="kw">then</span> volume
                 <span class="kw">else</span> <span class="dv">0</span>
         <span class="kw">end</span>) / <span class="fu">sum</span>(volume) <span class="kw">as</span> mkt_share
 <span class="kw">from</span>
         (
                 <span class="kw">select</span>
                         <span class="fu">extract</span>(<span class="dt">year</span> <span class="kw">from</span> o_orderdate) <span class="kw">as</span> o_year,
                         l_extendedprice * (<span class="dv">1</span> - l_discount) <span class="kw">as</span> volume,
                         n2.n_name <span class="kw">as</span> nation
                 <span class="kw">from</span>
                         part,
                         supplier,
                         lineitem,
                         orders,
                         customer,
                         nation n1,
                         nation n2,
                         region
                 <span class="kw">where</span>
                         p_partkey = l_partkey
                         <span class="kw">and</span> s_suppkey = l_suppkey
                         <span class="kw">and</span> l_orderkey = o_orderkey
                         <span class="kw">and</span> o_custkey = c_custkey
                         <span class="kw">and</span> c_nationkey = n1.n_nationkey
                         <span class="kw">and</span> n1.n_regionkey = r_regionkey
                         <span class="kw">and</span> r_name = <span class="st">&#39;MIDDLE EAST&#39;</span>
                         <span class="kw">and</span> s_nationkey = n2.n_nationkey
                         <span class="kw">and</span> o_orderdate <span class="kw">between</span> <span class="dt">date</span> <span class="st">&#39;1995-01-01&#39;</span> <span class="kw">and</span> <span class="dt">date</span> <span class="st">&#39;1996-12-31&#39;</span>
                         <span class="kw">and</span> p_type = <span class="st">&#39;STANDARD ANODIZED BRASS&#39;</span>
         ) <span class="kw">as</span> all_nations
 <span class="kw">group</span> <span class="kw">by</span>
         o_year
 <span class="kw">order</span> <span class="kw">by</span>
         o_year</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">BinOp</span>
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                   [<span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Nothing</span>,
                         caseWhens <span class="fu">=</span>
                           [([<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;IRAQ&quot;</span>)],
                             <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;volume&quot;</span>])],
                         caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;0&quot;</span>)}])
                [<span class="dt">Name</span> <span class="st">&quot;/&quot;</span>]
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;volume&quot;</span>]]),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;mkt_share&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span>
                            [(<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;extract&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;year&quot;</span>]))
                                [(<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>])],
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>)),
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                (<span class="dt">Parens</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]))),
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;volume&quot;</span>)),
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>))],
                          qeFrom <span class="fu">=</span>
                            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>],
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>],
                             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>) <span class="kw">Nothing</span>),
                             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>) <span class="kw">Nothing</span>),
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;region&quot;</span>]],
                          qeWhere <span class="fu">=</span>
                            <span class="kw">Just</span>
                              (<span class="dt">BinOp</span>
                                 (<span class="dt">BinOp</span>
                                    (<span class="dt">BinOp</span>
                                       (<span class="dt">BinOp</span>
                                          (<span class="dt">BinOp</span>
                                             (<span class="dt">BinOp</span>
                                                (<span class="dt">BinOp</span>
                                                   (<span class="dt">BinOp</span>
                                                      (<span class="dt">BinOp</span>
                                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                            (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]))
                                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                            (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])))
                                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>])))
                                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>])))
                                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_regionkey&quot;</span>])
                                                [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_regionkey&quot;</span>])))
                                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;r_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">StringLit</span> <span class="st">&quot;MIDDLE EAST&quot;</span>)))
                                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                    (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                                       [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>],
                                        <span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-01-01&quot;</span>,
                                        <span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1996-12-31&quot;</span>]))
                                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                    (<span class="dt">StringLit</span> <span class="st">&quot;STANDARD ANODIZED BRASS&quot;</span>))),
                          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;all_nations&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         nation,
         o_year,
         <span class="fu">sum</span>(amount) <span class="kw">as</span> sum_profit
 <span class="kw">from</span>
         (
                 <span class="kw">select</span>
                         n_name <span class="kw">as</span> nation,
                         <span class="fu">extract</span>(<span class="dt">year</span> <span class="kw">from</span> o_orderdate) <span class="kw">as</span> o_year,
                         l_extendedprice * (<span class="dv">1</span> - l_discount) - ps_supplycost * l_quantity <span class="kw">as</span> amount
                 <span class="kw">from</span>
                         part,
                         supplier,
                         lineitem,
                         partsupp,
                         orders,
                         nation
                 <span class="kw">where</span>
                         s_suppkey = l_suppkey
                         <span class="kw">and</span> ps_suppkey = l_suppkey
                         <span class="kw">and</span> ps_partkey = l_partkey
                         <span class="kw">and</span> p_partkey = l_partkey
                         <span class="kw">and</span> o_orderkey = l_orderkey
                         <span class="kw">and</span> s_nationkey = n_nationkey
                         <span class="kw">and</span> p_name <span class="kw">like</span> <span class="st">&#39;%antique%&#39;</span>
         ) <span class="kw">as</span> profit
 <span class="kw">group</span> <span class="kw">by</span>
         nation,
         o_year
 <span class="kw">order</span> <span class="kw">by</span>
         nation,
         o_year <span class="kw">desc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;amount&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;sum_profit&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span>
                            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>)),
                             (<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;extract&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;year&quot;</span>]))
                                [(<span class="st">&quot;from&quot;</span>, <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>])],
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>)),
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                   (<span class="dt">Parens</span>
                                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]))))
                                [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>]
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>])),
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;amount&quot;</span>))],
                          qeFrom <span class="fu">=</span>
                            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>],
                             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
                          qeWhere <span class="fu">=</span>
                            <span class="kw">Just</span>
                              (<span class="dt">BinOp</span>
                                 (<span class="dt">BinOp</span>
                                    (<span class="dt">BinOp</span>
                                       (<span class="dt">BinOp</span>
                                          (<span class="dt">BinOp</span>
                                             (<span class="dt">BinOp</span>
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]))
                                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])))
                                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>])))
                                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>])))
                                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>])))
                                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                    (<span class="dt">StringLit</span> <span class="st">&quot;%antique%&quot;</span>))),
                          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;profit&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_year&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         c_custkey,
         c_name,
         <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> revenue,
         c_acctbal,
         n_name,
         c_address,
         c_phone,
         c_comment
 <span class="kw">from</span>
         customer,
         orders,
         lineitem,
         nation
 <span class="kw">where</span>
         c_custkey = o_custkey
         <span class="kw">and</span> l_orderkey = o_orderkey
         <span class="kw">and</span> o_orderdate &gt;= <span class="dt">date</span> <span class="st">&#39;1993-12-01&#39;</span>
         <span class="kw">and</span> o_orderdate &lt; <span class="dt">date</span> <span class="st">&#39;1993-12-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;3&#39;</span> <span class="dt">month</span>
         <span class="kw">and</span> l_returnflag = <span class="st">&#39;R&#39;</span>
         <span class="kw">and</span> c_nationkey = n_nationkey
 <span class="kw">group</span> <span class="kw">by</span>
         c_custkey,
         c_name,
         c_acctbal,
         c_phone,
         n_name,
         c_address,
         c_comment
 <span class="kw">order</span> <span class="kw">by</span>
         revenue <span class="kw">desc</span>
 fetch <span class="fu">first</span> <span class="dv">20</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>)),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_address&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_phone&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_comment&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>]))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                             (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1993-12-01&quot;</span>)))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1993-12-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                             (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;3&quot;</span>,
                                          ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}))))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_returnflag&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;R&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>]))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_name&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_phone&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_address&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_comment&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;20&quot;</span>)})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         ps_partkey,
         <span class="fu">sum</span>(ps_supplycost * ps_availqty) <span class="kw">as</span> <span class="fu">value</span>
 <span class="kw">from</span>
         partsupp,
         supplier,
         nation
 <span class="kw">where</span>
         ps_suppkey = s_suppkey
         <span class="kw">and</span> s_nationkey = n_nationkey
         <span class="kw">and</span> n_name = <span class="st">&#39;CHINA&#39;</span>
 <span class="kw">group</span> <span class="kw">by</span>
         ps_partkey <span class="kw">having</span>
                 <span class="fu">sum</span>(ps_supplycost * ps_availqty) &gt; (
                         <span class="kw">select</span>
                                 <span class="fu">sum</span>(ps_supplycost * ps_availqty) * <span class="fl">0.0001000000</span>
                         <span class="kw">from</span>
                                 partsupp,
                                 supplier,
                                 nation
                         <span class="kw">where</span>
                                 ps_suppkey = s_suppkey
                                 <span class="kw">and</span> s_nationkey = n_nationkey
                                 <span class="kw">and</span> n_name = <span class="st">&#39;CHINA&#39;</span>
                 )
 <span class="kw">order</span> <span class="kw">by</span>
         <span class="fu">value</span> <span class="kw">desc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_availqty&quot;</span>])],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;value&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;CHINA&quot;</span>))),
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>])],
          qeHaving <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                    [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_availqty&quot;</span>])])
                 [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                 (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                    (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                            qeSelectList <span class="fu">=</span>
                              [(<span class="dt">BinOp</span>
                                  (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                                     [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_supplycost&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                        (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_availqty&quot;</span>])])
                                  [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                  (<span class="dt">NumLit</span> <span class="st">&quot;0.0001000000&quot;</span>),
                                <span class="kw">Nothing</span>)],
                            qeFrom <span class="fu">=</span>
                              [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
                               <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
                            qeWhere <span class="fu">=</span>
                              <span class="kw">Just</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                         (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;CHINA&quot;</span>))),
                            qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                            qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))),
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;value&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         l_shipmode,
         <span class="fu">sum</span>(<span class="kw">case</span>
                 <span class="kw">when</span> o_orderpriority = <span class="st">&#39;1-URGENT&#39;</span>
                         <span class="kw">or</span> o_orderpriority = <span class="st">&#39;2-HIGH&#39;</span>
                         <span class="kw">then</span> <span class="dv">1</span>
                 <span class="kw">else</span> <span class="dv">0</span>
         <span class="kw">end</span>) <span class="kw">as</span> high_line_count,
         <span class="fu">sum</span>(<span class="kw">case</span>
                 <span class="kw">when</span> o_orderpriority &lt;&gt; <span class="st">&#39;1-URGENT&#39;</span>
                         <span class="kw">and</span> o_orderpriority &lt;&gt; <span class="st">&#39;2-HIGH&#39;</span>
                         <span class="kw">then</span> <span class="dv">1</span>
                 <span class="kw">else</span> <span class="dv">0</span>
         <span class="kw">end</span>) <span class="kw">as</span> low_line_count
 <span class="kw">from</span>
         orders,
         lineitem
 <span class="kw">where</span>
         o_orderkey = l_orderkey
         <span class="kw">and</span> l_shipmode <span class="kw">in</span> (<span class="st">&#39;AIR&#39;</span>, <span class="st">&#39;RAIL&#39;</span>)
         <span class="kw">and</span> l_commitdate &lt; l_receiptdate
         <span class="kw">and</span> l_shipdate &lt; l_commitdate
         <span class="kw">and</span> l_receiptdate &gt;= <span class="dt">date</span> <span class="st">&#39;1994-01-01&#39;</span>
         <span class="kw">and</span> l_receiptdate &lt; <span class="dt">date</span> <span class="st">&#39;1994-01-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span>
 <span class="kw">group</span> <span class="kw">by</span>
         l_shipmode
 <span class="kw">order</span> <span class="kw">by</span>
         l_shipmode</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Nothing</span>,
                      caseWhens <span class="fu">=</span>
                        [([<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">StringLit</span> <span class="st">&quot;1-URGENT&quot;</span>))
                             [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">StringLit</span> <span class="st">&quot;2-HIGH&quot;</span>))],
                          <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>)],
                      caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;0&quot;</span>)}],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;high_line_count&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Nothing</span>,
                      caseWhens <span class="fu">=</span>
                        [([<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>]
                                (<span class="dt">StringLit</span> <span class="st">&quot;1-URGENT&quot;</span>))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderpriority&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>]
                                (<span class="dt">StringLit</span> <span class="st">&quot;2-HIGH&quot;</span>))],
                          <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>)],
                      caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;0&quot;</span>)}],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;low_line_count&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>])
                                (<span class="dt">InList</span> [<span class="dt">StringLit</span> <span class="st">&quot;AIR&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;RAIL&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_commitdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>])))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_commitdate&quot;</span>])))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                       (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1994-01-01&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1994-01-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                       (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
                                    ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         c_count,
         <span class="fu">count</span>(*) <span class="kw">as</span> custdist
 <span class="kw">from</span>
         (
                 <span class="kw">select</span>
                         c_custkey,
                         <span class="fu">count</span>(o_orderkey)
                 <span class="kw">from</span>
                         customer <span class="kw">left</span> <span class="kw">outer</span> <span class="kw">join</span> orders <span class="kw">on</span>
                                 c_custkey = o_custkey
                                 <span class="kw">and</span> o_comment <span class="kw">not</span> <span class="kw">like</span> <span class="st">&#39;%pending%requests%&#39;</span>
                 <span class="kw">group</span> <span class="kw">by</span>
                         c_custkey
         ) <span class="kw">as</span> c_orders (c_custkey, c_count)
 <span class="kw">group</span> <span class="kw">by</span>
         c_count
 <span class="kw">order</span> <span class="kw">by</span>
         custdist <span class="kw">desc</span>,
         c_count <span class="kw">desc</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_count&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;custdist&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span>
                            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>], <span class="kw">Nothing</span>),
                             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span>
                            [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span>
                               (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>])
                               (<span class="kw">Just</span>
                                  (<span class="dt">JoinOn</span>
                                     (<span class="dt">BinOp</span>
                                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                           (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>]))
                                        [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_comment&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;not like&quot;</span>]
                                           (<span class="dt">StringLit</span> <span class="st">&quot;%pending%requests%&quot;</span>)))))],
                          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>])],
                          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;c_orders&quot;</span>)
                  (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c_count&quot;</span>]))],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_count&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;custdist&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_count&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         <span class="fl">100.00</span> * <span class="fu">sum</span>(<span class="kw">case</span>
                 <span class="kw">when</span> p_type <span class="kw">like</span> <span class="st">&#39;PROMO%&#39;</span>
                         <span class="kw">then</span> l_extendedprice * (<span class="dv">1</span> - l_discount)
                 <span class="kw">else</span> <span class="dv">0</span>
         <span class="kw">end</span>) / <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> promo_revenue
 <span class="kw">from</span>
         lineitem,
         part
 <span class="kw">where</span>
         l_partkey = p_partkey
         <span class="kw">and</span> l_shipdate &gt;= <span class="dt">date</span> <span class="st">&#39;1994-12-01&#39;</span>
         <span class="kw">and</span> l_shipdate &lt; <span class="dt">date</span> <span class="st">&#39;1994-12-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">month</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span>
                (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;100.00&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                      [<span class="dt">Case</span>{caseTest <span class="fu">=</span> <span class="kw">Nothing</span>,
                            caseWhens <span class="fu">=</span>
                              [([<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                   (<span class="dt">StringLit</span> <span class="st">&quot;PROMO%&quot;</span>)],
                                <span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                  (<span class="dt">Parens</span>
                                     (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>]))))],
                            caseElse <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;0&quot;</span>)}]))
                [<span class="dt">Name</span> <span class="st">&quot;/&quot;</span>]
                (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                   [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                      (<span class="dt">Parens</span>
                         (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))]),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;promo_revenue&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                       (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1994-12-01&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1994-12-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                       (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
                                    ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="co">/*create view revenue0 (supplier_no, total_revenue) as</span>
<span class="co">         select</span>
<span class="co">                 l_suppkey,</span>
<span class="co">                 sum(l_extendedprice * (1 - l_discount))</span>
<span class="co">         from</span>
<span class="co">                 lineitem</span>
<span class="co">         where</span>
<span class="co">                 l_shipdate &gt;= date &#39;1995-06-01&#39;</span>
<span class="co">                 and l_shipdate &lt; date &#39;1995-06-01&#39; + interval &#39;3&#39; month</span>
<span class="co">         group by</span>
<span class="co">                 l_suppkey;*/</span>
 <span class="kw">with</span>
 revenue0 <span class="kw">as</span>
         (<span class="kw">select</span>
                 l_suppkey <span class="kw">as</span> supplier_no,
                 <span class="fu">sum</span>(l_extendedprice * (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> total_revenue
         <span class="kw">from</span>
                 lineitem
         <span class="kw">where</span>
                 l_shipdate &gt;= <span class="dt">date</span> <span class="st">&#39;1995-06-01&#39;</span>
                 <span class="kw">and</span> l_shipdate &lt; <span class="dt">date</span> <span class="st">&#39;1995-06-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;3&#39;</span> <span class="dt">month</span>
         <span class="kw">group</span> <span class="kw">by</span>
                 l_suppkey)
 <span class="kw">select</span>
         s_suppkey,
         s_name,
         s_address,
         s_phone,
         total_revenue
 <span class="kw">from</span>
         supplier,
         revenue0
 <span class="kw">where</span>
         s_suppkey = supplier_no
         <span class="kw">and</span> total_revenue = (
                 <span class="kw">select</span>
                         <span class="fu">max</span>(total_revenue)
                 <span class="kw">from</span>
                         revenue0
         )
 <span class="kw">order</span> <span class="kw">by</span>
         s_suppkey</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">With</span>{qeWithRecursive <span class="fu">=</span> <span class="kw">False</span>,
        qeViews <span class="fu">=</span>
          [(<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;revenue0&quot;</span>) <span class="kw">Nothing</span>,
            <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                   qeSelectList <span class="fu">=</span>
                     [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;supplier_no&quot;</span>)),
                      (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                         [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                            (<span class="dt">Parens</span>
                               (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
                       <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;total_revenue&quot;</span>))],
                   qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
                   qeWhere <span class="fu">=</span>
                     <span class="kw">Just</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                             (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-06-01&quot;</span>))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;1995-06-01&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                                (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;3&quot;</span>,
                                             ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>})))),
                   qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])],
                   qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                   qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})],
        qeQueryExpression <span class="fu">=</span>
          <span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                 qeSelectList <span class="fu">=</span>
                   [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_address&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_phone&quot;</span>], <span class="kw">Nothing</span>),
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;total_revenue&quot;</span>], <span class="kw">Nothing</span>)],
                 qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;revenue0&quot;</span>]],
                 qeWhere <span class="fu">=</span>
                   <span class="kw">Just</span>
                     (<span class="dt">BinOp</span>
                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                           (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;supplier_no&quot;</span>]))
                        [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                        (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;total_revenue&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                           (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                              (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                      qeSelectList <span class="fu">=</span>
                                        [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;total_revenue&quot;</span>]], <span class="kw">Nothing</span>)],
                                      qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;revenue0&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                      qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                      qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
                 qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                 qeOrderBy <span class="fu">=</span>
                   [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
                 qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         p_brand,
         p_type,
         p_size,
         <span class="fu">count</span>(<span class="kw">distinct</span> ps_suppkey) <span class="kw">as</span> supplier_cnt
 <span class="kw">from</span>
         partsupp,
         part
 <span class="kw">where</span>
         p_partkey = ps_partkey
         <span class="kw">and</span> p_brand &lt;&gt; <span class="st">&#39;Brand#15&#39;</span>
         <span class="kw">and</span> p_type <span class="kw">not</span> <span class="kw">like</span> <span class="st">&#39;MEDIUM BURNISHED%&#39;</span>
         <span class="kw">and</span> p_size <span class="kw">in</span> (<span class="dv">39</span>, <span class="dv">26</span>, <span class="dv">18</span>, <span class="dv">45</span>, <span class="dv">19</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>)
         <span class="kw">and</span> ps_suppkey <span class="kw">not</span> <span class="kw">in</span> (
                 <span class="kw">select</span>
                         s_suppkey
                 <span class="kw">from</span>
                         supplier
                 <span class="kw">where</span>
                         s_comment <span class="kw">like</span> <span class="st">&#39;%Customer%Complaints%&#39;</span>
         )
 <span class="kw">group</span> <span class="kw">by</span>
         p_brand,
         p_type,
         p_size
 <span class="kw">order</span> <span class="kw">by</span>
         supplier_cnt <span class="kw">desc</span>,
         p_brand,
         p_type,
         p_size</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
                           aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
                           aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>},
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;supplier_cnt&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>]))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;Brand#15&quot;</span>)))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;not like&quot;</span>]
                          (<span class="dt">StringLit</span> <span class="st">&quot;MEDIUM BURNISHED%&quot;</span>)))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>])
                       (<span class="dt">InList</span>
                          [<span class="dt">NumLit</span> <span class="st">&quot;39&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;26&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;18&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;45&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;19&quot;</span>,
                           <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;9&quot;</span>])))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">In</span> <span class="kw">False</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>])
                    (<span class="dt">InQueryExpr</span>
                       (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                               qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>], <span class="kw">Nothing</span>)],
                               qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>]],
                               qeWhere <span class="fu">=</span>
                                 <span class="kw">Just</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_comment&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                      (<span class="dt">StringLit</span> <span class="st">&quot;%Customer%Complaints%&quot;</span>)),
                               qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                               qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;supplier_cnt&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_type&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         <span class="fu">sum</span>(l_extendedprice) / <span class="fl">7.0</span> <span class="kw">as</span> avg_yearly
 <span class="kw">from</span>
         lineitem,
         part
 <span class="kw">where</span>
         p_partkey = l_partkey
         <span class="kw">and</span> p_brand = <span class="st">&#39;Brand#52&#39;</span>
         <span class="kw">and</span> p_container = <span class="st">&#39;JUMBO CAN&#39;</span>
         <span class="kw">and</span> l_quantity &lt; (
                 <span class="kw">select</span>
                         <span class="fl">0.2</span> * <span class="fu">avg</span>(l_quantity)
                 <span class="kw">from</span>
                         lineitem
                 <span class="kw">where</span>
                         l_partkey = p_partkey
         )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]])
                [<span class="dt">Name</span> <span class="st">&quot;/&quot;</span>]
                (<span class="dt">NumLit</span> <span class="st">&quot;7.0&quot;</span>),
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;avg_yearly&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                          (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;Brand#52&quot;</span>)))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_container&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">StringLit</span> <span class="st">&quot;JUMBO CAN&quot;</span>)))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                    (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                       (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                               qeSelectList <span class="fu">=</span>
                                 [(<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;0.2&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                     (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]]),
                                   <span class="kw">Nothing</span>)],
                               qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
                               qeWhere <span class="fu">=</span>
                                 <span class="kw">Just</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>])),
                               qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                               qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice,
         <span class="fu">sum</span>(l_quantity)
 <span class="kw">from</span>
         customer,
         orders,
         lineitem
 <span class="kw">where</span>
         o_orderkey <span class="kw">in</span> (
                 <span class="kw">select</span>
                         l_orderkey
                 <span class="kw">from</span>
                         lineitem
                 <span class="kw">group</span> <span class="kw">by</span>
                         l_orderkey <span class="kw">having</span>
                                 <span class="fu">sum</span>(l_quantity) &gt; <span class="dv">313</span>
         )
         <span class="kw">and</span> c_custkey = o_custkey
         <span class="kw">and</span> o_orderkey = l_orderkey
 <span class="kw">group</span> <span class="kw">by</span>
         c_name,
         c_custkey,
         o_orderkey,
         o_orderdate,
         o_totalprice
 <span class="kw">order</span> <span class="kw">by</span>
         o_totalprice <span class="kw">desc</span>,
         o_orderdate
 fetch <span class="fu">first</span> <span class="dv">100</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_totalprice&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>],
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>])
                       (<span class="dt">InQueryExpr</span>
                          (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                  qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>], <span class="kw">Nothing</span>)],
                                  qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
                                  qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>])],
                                  qeHaving <span class="fu">=</span>
                                    <span class="kw">Just</span>
                                      (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]])
                                         [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                         (<span class="dt">NumLit</span> <span class="st">&quot;313&quot;</span>)),
                                  qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>])))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                    (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]))),
          qeGroupBy <span class="fu">=</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_name&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]),
             <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_totalprice&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_totalprice&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderdate&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;100&quot;</span>)})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         <span class="fu">sum</span>(l_extendedprice* (<span class="dv">1</span> - l_discount)) <span class="kw">as</span> revenue
 <span class="kw">from</span>
         lineitem,
         part
 <span class="kw">where</span>
         (
                 p_partkey = l_partkey
                 <span class="kw">and</span> p_brand = <span class="st">&#39;Brand#43&#39;</span>
                 <span class="kw">and</span> p_container <span class="kw">in</span> (<span class="st">&#39;SM CASE&#39;</span>, <span class="st">&#39;SM BOX&#39;</span>, <span class="st">&#39;SM PACK&#39;</span>, <span class="st">&#39;SM PKG&#39;</span>)
                 <span class="kw">and</span> l_quantity &gt;= <span class="dv">3</span> <span class="kw">and</span> l_quantity &lt;= <span class="dv">3</span> + <span class="dv">10</span>
                 <span class="kw">and</span> p_size <span class="kw">between</span> <span class="dv">1</span> <span class="kw">and</span> <span class="dv">5</span>
                 <span class="kw">and</span> l_shipmode <span class="kw">in</span> (<span class="st">&#39;AIR&#39;</span>, <span class="st">&#39;AIR REG&#39;</span>)
                 <span class="kw">and</span> l_shipinstruct = <span class="st">&#39;DELIVER IN PERSON&#39;</span>
         )
         <span class="kw">or</span>
         (
                 p_partkey = l_partkey
                 <span class="kw">and</span> p_brand = <span class="st">&#39;Brand#25&#39;</span>
                 <span class="kw">and</span> p_container <span class="kw">in</span> (<span class="st">&#39;MED BAG&#39;</span>, <span class="st">&#39;MED BOX&#39;</span>, <span class="st">&#39;MED PKG&#39;</span>, <span class="st">&#39;MED PACK&#39;</span>)
                 <span class="kw">and</span> l_quantity &gt;= <span class="dv">10</span> <span class="kw">and</span> l_quantity &lt;= <span class="dv">10</span> + <span class="dv">10</span>
                 <span class="kw">and</span> p_size <span class="kw">between</span> <span class="dv">1</span> <span class="kw">and</span> <span class="dv">10</span>
                 <span class="kw">and</span> l_shipmode <span class="kw">in</span> (<span class="st">&#39;AIR&#39;</span>, <span class="st">&#39;AIR REG&#39;</span>)
                 <span class="kw">and</span> l_shipinstruct = <span class="st">&#39;DELIVER IN PERSON&#39;</span>
         )
         <span class="kw">or</span>
         (
                 p_partkey = l_partkey
                 <span class="kw">and</span> p_brand = <span class="st">&#39;Brand#24&#39;</span>
                 <span class="kw">and</span> p_container <span class="kw">in</span> (<span class="st">&#39;LG CASE&#39;</span>, <span class="st">&#39;LG BOX&#39;</span>, <span class="st">&#39;LG PACK&#39;</span>, <span class="st">&#39;LG PKG&#39;</span>)
                 <span class="kw">and</span> l_quantity &gt;= <span class="dv">22</span> <span class="kw">and</span> l_quantity &lt;= <span class="dv">22</span> + <span class="dv">10</span>
                 <span class="kw">and</span> p_size <span class="kw">between</span> <span class="dv">1</span> <span class="kw">and</span> <span class="dv">15</span>
                 <span class="kw">and</span> l_shipmode <span class="kw">in</span> (<span class="st">&#39;AIR&#39;</span>, <span class="st">&#39;AIR REG&#39;</span>)
                 <span class="kw">and</span> l_shipinstruct = <span class="st">&#39;DELIVER IN PERSON&#39;</span>
         )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_extendedprice&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                   (<span class="dt">Parens</span>
                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_discount&quot;</span>])))],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;revenue&quot;</span>))],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">Parens</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span>
                                         (<span class="dt">BinOp</span>
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]))
                                            [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">StringLit</span> <span class="st">&quot;Brand#43&quot;</span>)))
                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                         (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_container&quot;</span>])
                                            (<span class="dt">InList</span>
                                               [<span class="dt">StringLit</span> <span class="st">&quot;SM CASE&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;SM BOX&quot;</span>,
                                                <span class="dt">StringLit</span> <span class="st">&quot;SM PACK&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;SM PKG&quot;</span>])))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>)))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>))))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                                   [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>]))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>])
                                (<span class="dt">InList</span> [<span class="dt">StringLit</span> <span class="st">&quot;AIR&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;AIR REG&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipinstruct&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">StringLit</span> <span class="st">&quot;DELIVER IN PERSON&quot;</span>))))
                    [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                    (<span class="dt">Parens</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span>
                                         (<span class="dt">BinOp</span>
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]))
                                            [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">StringLit</span> <span class="st">&quot;Brand#25&quot;</span>)))
                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                         (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_container&quot;</span>])
                                            (<span class="dt">InList</span>
                                               [<span class="dt">StringLit</span> <span class="st">&quot;MED BAG&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;MED BOX&quot;</span>,
                                                <span class="dt">StringLit</span> <span class="st">&quot;MED PKG&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;MED PACK&quot;</span>])))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>)))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>]
                                      (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>))))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                                   [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>]))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>])
                                (<span class="dt">InList</span> [<span class="dt">StringLit</span> <span class="st">&quot;AIR&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;AIR REG&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipinstruct&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                             (<span class="dt">StringLit</span> <span class="st">&quot;DELIVER IN PERSON&quot;</span>)))))
                 [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>]
                 (<span class="dt">Parens</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span>
                                      (<span class="dt">BinOp</span>
                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                            (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>]))
                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_brand&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                            (<span class="dt">StringLit</span> <span class="st">&quot;Brand#24&quot;</span>)))
                                      [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                      (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_container&quot;</span>])
                                         (<span class="dt">InList</span>
                                            [<span class="dt">StringLit</span> <span class="st">&quot;LG CASE&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;LG BOX&quot;</span>,
                                             <span class="dt">StringLit</span> <span class="st">&quot;LG PACK&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;LG PKG&quot;</span>])))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;22&quot;</span>)))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;22&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;10&quot;</span>))))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;between&quot;</span>]
                                [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_size&quot;</span>], <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;15&quot;</span>]))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipmode&quot;</span>])
                             (<span class="dt">InList</span> [<span class="dt">StringLit</span> <span class="st">&quot;AIR&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;AIR REG&quot;</span>])))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipinstruct&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                          (<span class="dt">StringLit</span> <span class="st">&quot;DELIVER IN PERSON&quot;</span>))))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         s_name,
         s_address
 <span class="kw">from</span>
         supplier,
         nation
 <span class="kw">where</span>
         s_suppkey <span class="kw">in</span> (
                 <span class="kw">select</span>
                         ps_suppkey
                 <span class="kw">from</span>
                         partsupp
                 <span class="kw">where</span>
                         ps_partkey <span class="kw">in</span> (
                                 <span class="kw">select</span>
                                         p_partkey
                                 <span class="kw">from</span>
                                         part
                                 <span class="kw">where</span>
                                         p_name <span class="kw">like</span> <span class="st">&#39;lime%&#39;</span>
                         )
                         <span class="kw">and</span> ps_availqty &gt; (
                                 <span class="kw">select</span>
                                         <span class="fl">0.5</span> * <span class="fu">sum</span>(l_quantity)
                                 <span class="kw">from</span>
                                         lineitem
                                 <span class="kw">where</span>
                                         l_partkey = ps_partkey
                                         <span class="kw">and</span> l_suppkey = ps_suppkey
                                         <span class="kw">and</span> l_shipdate &gt;= <span class="dt">date</span> <span class="st">&#39;1994-01-01&#39;</span>
                                         <span class="kw">and</span> l_shipdate &lt; <span class="dt">date</span> <span class="st">&#39;1994-01-01&#39;</span> + <span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span>
                         )
         )
         <span class="kw">and</span> s_nationkey = n_nationkey
         <span class="kw">and</span> n_name = <span class="st">&#39;VIETNAM&#39;</span>
 <span class="kw">order</span> <span class="kw">by</span>
         s_name</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_address&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>])
                       (<span class="dt">InQueryExpr</span>
                          (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                  qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>], <span class="kw">Nothing</span>)],
                                  qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;partsupp&quot;</span>]],
                                  qeWhere <span class="fu">=</span>
                                    <span class="kw">Just</span>
                                      (<span class="dt">BinOp</span>
                                         (<span class="dt">In</span> <span class="kw">True</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>])
                                            (<span class="dt">InQueryExpr</span>
                                               (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                                       qeSelectList <span class="fu">=</span>
                                                         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_partkey&quot;</span>], <span class="kw">Nothing</span>)],
                                                       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;part&quot;</span>]],
                                                       qeWhere <span class="fu">=</span>
                                                         <span class="kw">Just</span>
                                                           (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;p_name&quot;</span>])
                                                              [<span class="dt">Name</span> <span class="st">&quot;like&quot;</span>]
                                                              (<span class="dt">StringLit</span> <span class="st">&quot;lime%&quot;</span>)),
                                                       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))
                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_availqty&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                            (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                                               (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                                       qeSelectList <span class="fu">=</span>
                                                         [(<span class="dt">BinOp</span> (<span class="dt">NumLit</span> <span class="st">&quot;0.5&quot;</span>) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>]
                                                             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>]
                                                                [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_quantity&quot;</span>]]),
                                                           <span class="kw">Nothing</span>)],
                                                       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]],
                                                       qeWhere <span class="fu">=</span>
                                                         <span class="kw">Just</span>
                                                           (<span class="dt">BinOp</span>
                                                              (<span class="dt">BinOp</span>
                                                                 (<span class="dt">BinOp</span>
                                                                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_partkey&quot;</span>])
                                                                       [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_partkey&quot;</span>]))
                                                                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])
                                                                       [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;ps_suppkey&quot;</span>])))
                                                                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>])
                                                                    [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>]
                                                                    (<span class="dt">TypedLit</span>
                                                                       (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>])
                                                                       <span class="st">&quot;1994-01-01&quot;</span>)))
                                                              [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                              (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l_shipdate&quot;</span>])
                                                                 [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>]
                                                                 (<span class="dt">BinOp</span>
                                                                    (<span class="dt">TypedLit</span>
                                                                       (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>])
                                                                       <span class="st">&quot;1994-01-01&quot;</span>)
                                                                    [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>]
                                                                    (<span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                                                 ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
                                                                                 ilFrom <span class="fu">=</span>
                                                                                   <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span>
                                                                                     <span class="kw">Nothing</span>,
                                                                                 ilTo <span class="fu">=</span>
                                                                                   <span class="kw">Nothing</span>})))),
                                                       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
                                  qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                  qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;VIETNAM&quot;</span>))),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         s_name,
         <span class="fu">count</span>(*) <span class="kw">as</span> numwait
 <span class="kw">from</span>
         supplier,
         lineitem l1,
         orders,
         nation
 <span class="kw">where</span>
         s_suppkey = l1.l_suppkey
         <span class="kw">and</span> o_orderkey = l1.l_orderkey
         <span class="kw">and</span> o_orderstatus = <span class="st">&#39;F&#39;</span>
         <span class="kw">and</span> l1.l_receiptdate &gt; l1.l_commitdate
         <span class="kw">and</span> <span class="kw">exists</span> (
                 <span class="kw">select</span>
                         *
                 <span class="kw">from</span>
                         lineitem l2
                 <span class="kw">where</span>
                         l2.l_orderkey = l1.l_orderkey
                         <span class="kw">and</span> l2.l_suppkey &lt;&gt; l1.l_suppkey
         )
         <span class="kw">and</span> <span class="kw">not</span> <span class="kw">exists</span> (
                 <span class="kw">select</span>
                         *
                 <span class="kw">from</span>
                         lineitem l3
                 <span class="kw">where</span>
                         l3.l_orderkey = l1.l_orderkey
                         <span class="kw">and</span> l3.l_suppkey &lt;&gt; l1.l_suppkey
                         <span class="kw">and</span> l3.l_receiptdate &gt; l3.l_commitdate
         )
         <span class="kw">and</span> s_nationkey = n_nationkey
         <span class="kw">and</span> n_name = <span class="st">&#39;INDIA&#39;</span>
 <span class="kw">group</span> <span class="kw">by</span>
         s_name
 <span class="kw">order</span> <span class="kw">by</span>
         numwait <span class="kw">desc</span>,
         s_name
 fetch <span class="fu">first</span> <span class="dv">100</span> <span class="kw">rows</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;numwait&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;supplier&quot;</span>],
             <span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>) <span class="kw">Nothing</span>),
             <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;nation&quot;</span>]],
          qeWhere <span class="fu">=</span>
            <span class="kw">Just</span>
              (<span class="dt">BinOp</span>
                 (<span class="dt">BinOp</span>
                    (<span class="dt">BinOp</span>
                       (<span class="dt">BinOp</span>
                          (<span class="dt">BinOp</span>
                             (<span class="dt">BinOp</span>
                                (<span class="dt">BinOp</span>
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]))
                                   [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>])))
                                [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_orderstatus&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;F&quot;</span>)))
                             [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                             (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_commitdate&quot;</span>])))
                          [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                          (<span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
                             (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                     qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                                     qeFrom <span class="fu">=</span>
                                       [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>])
                                          (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;l2&quot;</span>) <span class="kw">Nothing</span>)],
                                     qeWhere <span class="fu">=</span>
                                       <span class="kw">Just</span>
                                         (<span class="dt">BinOp</span>
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]))
                                            [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l2&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>]))),
                                     qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                     qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))
                       [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                       (<span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>]
                          (<span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
                             (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                     qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                                     qeFrom <span class="fu">=</span>
                                       [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;lineitem&quot;</span>])
                                          (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;l3&quot;</span>) <span class="kw">Nothing</span>)],
                                     qeWhere <span class="fu">=</span>
                                       <span class="kw">Just</span>
                                         (<span class="dt">BinOp</span>
                                            (<span class="dt">BinOp</span>
                                               (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l3&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>])
                                                  [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_orderkey&quot;</span>]))
                                               [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                               (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l3&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])
                                                  [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>]
                                                  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l1&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_suppkey&quot;</span>])))
                                            [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                            (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l3&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_receiptdate&quot;</span>])
                                               [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                               (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;l3&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;l_commitdate&quot;</span>]))),
                                     qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                     qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))))
                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_nationkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                       (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_nationkey&quot;</span>])))
                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                 (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;n_name&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">StringLit</span> <span class="st">&quot;INDIA&quot;</span>))),
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;numwait&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
             <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;s_name&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;100&quot;</span>)})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">
 <span class="kw">select</span>
         cntrycode,
         <span class="fu">count</span>(*) <span class="kw">as</span> numcust,
         <span class="fu">sum</span>(c_acctbal) <span class="kw">as</span> totacctbal
 <span class="kw">from</span>
         (
                 <span class="kw">select</span>
                         substring(c_phone <span class="kw">from</span> <span class="dv">1</span> <span class="kw">for</span> <span class="dv">2</span>) <span class="kw">as</span> cntrycode,
                         c_acctbal
                 <span class="kw">from</span>
                         customer
                 <span class="kw">where</span>
                         substring(c_phone <span class="kw">from</span> <span class="dv">1</span> <span class="kw">for</span> <span class="dv">2</span>) <span class="kw">in</span>
                                 (<span class="st">&#39;41&#39;</span>, <span class="st">&#39;28&#39;</span>, <span class="st">&#39;39&#39;</span>, <span class="st">&#39;21&#39;</span>, <span class="st">&#39;24&#39;</span>, <span class="st">&#39;29&#39;</span>, <span class="st">&#39;44&#39;</span>)
                         <span class="kw">and</span> c_acctbal &gt; (
                                 <span class="kw">select</span>
                                         <span class="fu">avg</span>(c_acctbal)
                                 <span class="kw">from</span>
                                         customer
                                 <span class="kw">where</span>
                                         c_acctbal &gt; <span class="fl">0.00</span>
                                         <span class="kw">and</span> substring(c_phone <span class="kw">from</span> <span class="dv">1</span> <span class="kw">for</span> <span class="dv">2</span>) <span class="kw">in</span>
                                                 (<span class="st">&#39;41&#39;</span>, <span class="st">&#39;28&#39;</span>, <span class="st">&#39;39&#39;</span>, <span class="st">&#39;21&#39;</span>, <span class="st">&#39;24&#39;</span>, <span class="st">&#39;29&#39;</span>, <span class="st">&#39;44&#39;</span>)
                         )
                         <span class="kw">and</span> <span class="kw">not</span> <span class="kw">exists</span> (
                                 <span class="kw">select</span>
                                         *
                                 <span class="kw">from</span>
                                         orders
                                 <span class="kw">where</span>
                                         o_custkey = c_custkey
                         )
         ) <span class="kw">as</span> custsale
 <span class="kw">group</span> <span class="kw">by</span>
         cntrycode
 <span class="kw">order</span> <span class="kw">by</span>
         cntrycode</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">Right</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cntrycode&quot;</span>], <span class="kw">Nothing</span>),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;numcust&quot;</span>)),
             (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>]],
              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;totacctbal&quot;</span>))],
          qeFrom <span class="fu">=</span>
            [<span class="dt">TRAlias</span>
               (<span class="dt">TRQueryExpr</span>
                  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                          qeSelectList <span class="fu">=</span>
                            [(<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_phone&quot;</span>]))
                                [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>), (<span class="st">&quot;for&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)],
                              <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;cntrycode&quot;</span>)),
                             (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>], <span class="kw">Nothing</span>)],
                          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>]],
                          qeWhere <span class="fu">=</span>
                            <span class="kw">Just</span>
                              (<span class="dt">BinOp</span>
                                 (<span class="dt">BinOp</span>
                                    (<span class="dt">In</span> <span class="kw">True</span>
                                       (<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>] (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_phone&quot;</span>]))
                                          [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>), (<span class="st">&quot;for&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)])
                                       (<span class="dt">InList</span>
                                          [<span class="dt">StringLit</span> <span class="st">&quot;41&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;28&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;39&quot;</span>,
                                           <span class="dt">StringLit</span> <span class="st">&quot;21&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;24&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;29&quot;</span>,
                                           <span class="dt">StringLit</span> <span class="st">&quot;44&quot;</span>]))
                                    [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                    (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                       (<span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
                                          (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                                  qeSelectList <span class="fu">=</span>
                                                    [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>]],
                                                      <span class="kw">Nothing</span>)],
                                                  qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;customer&quot;</span>]],
                                                  qeWhere <span class="fu">=</span>
                                                    <span class="kw">Just</span>
                                                      (<span class="dt">BinOp</span>
                                                         (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_acctbal&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
                                                            (<span class="dt">NumLit</span> <span class="st">&quot;0.00&quot;</span>))
                                                         [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                                         (<span class="dt">In</span> <span class="kw">True</span>
                                                            (<span class="dt">SpecialOpK</span> [<span class="dt">Name</span> <span class="st">&quot;substring&quot;</span>]
                                                               (<span class="kw">Just</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_phone&quot;</span>]))
                                                               [(<span class="st">&quot;from&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>),
                                                                (<span class="st">&quot;for&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>)])
                                                            (<span class="dt">InList</span>
                                                               [<span class="dt">StringLit</span> <span class="st">&quot;41&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;28&quot;</span>,
                                                                <span class="dt">StringLit</span> <span class="st">&quot;39&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;21&quot;</span>,
                                                                <span class="dt">StringLit</span> <span class="st">&quot;24&quot;</span>, <span class="dt">StringLit</span> <span class="st">&quot;29&quot;</span>,
                                                                <span class="dt">StringLit</span> <span class="st">&quot;44&quot;</span>]))),
                                                  qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                  qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
                                                  qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))))
                                 [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>]
                                 (<span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>]
                                    (<span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
                                       (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                                               qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
                                               qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;orders&quot;</span>]],
                                               qeWhere <span class="fu">=</span>
                                                 <span class="kw">Just</span>
                                                   (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;o_custkey&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
                                                      (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c_custkey&quot;</span>])),
                                               qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                                               qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})))),
                          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
                          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
               (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;custsale&quot;</span>) <span class="kw">Nothing</span>)],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cntrycode&quot;</span>])],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;cntrycode&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h2 id="sql-2011-tests"><a href="#sql-2011-tests">sql 2011 tests</a></h2>
<h3 id="literals-1"><a href="#literals-1">literals</a></h3>
<h4 id="numeric-literals"><a href="#numeric-literals">numeric literals</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dv">11</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11.11</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11.11&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11E23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11E+23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11E-23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11.11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11.11E23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11.11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11.11E+23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11.11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11.11E-23&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E+23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E-23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11.11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11.11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E+23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+<span class="fl">11.11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E-23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E+23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11E-23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11.11E23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11.11E+23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E+23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-<span class="fl">11.11E-23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;11.11E-23&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fl">11.11e23</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NumLit</span> <span class="st">&quot;11.11e23&quot;</span></code></pre>
</td></tr>
</table>
<h4 id="general-literals"><a href="#general-literals">general literals</a></h4>
<h5 id="character-string-literals"><a href="#character-string-literals">character string literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;a regular string literal&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;a regular string literal&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;something&#39;</span> <span class="st">&#39; some more&#39;</span> <span class="st">&#39;and more&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;something some moreand more&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;something&#39;</span> 
 <span class="st">&#39; some more&#39;</span>    <span class="st">&#39;and more&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;something some moreand more&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;something&#39;</span> <span class="co">-- a comment</span>
 <span class="st">&#39; some more&#39;</span> <span class="co">/*another comment*/</span> <span class="st">&#39;and more&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;something some moreand more&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;a quote: </span><span class="ch">&#39;&#39;</span><span class="st">, stuff&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;a quote: &#39;, stuff&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">&#39;&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StringLit</span> <span class="st">&quot;&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">_francais <span class="st">&#39;français&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;_francais&quot;</span>]) <span class="st">&quot;fran\231ais&quot;</span></code></pre>
</td></tr>
</table>
<h5 id="national-character-string-literals"><a href="#national-character-string-literals">national character string literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">N<span class="st">&#39;something&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CSStringLit</span> <span class="st">&quot;N&quot;</span> <span class="st">&quot;something&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">n<span class="st">&#39;something&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CSStringLit</span> <span class="st">&quot;n&quot;</span> <span class="st">&quot;something&quot;</span></code></pre>
</td></tr>
</table>
<h5 id="unicode-character-string-literals"><a href="#unicode-character-string-literals">unicode character string literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">U&amp;<span class="st">&#39;something&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CSStringLit</span> <span class="st">&quot;U&amp;&quot;</span> <span class="st">&quot;something&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">u&amp;<span class="st">&#39;something&#39;</span> <span class="kw">escape</span> =</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Escape</span> (<span class="dt">CSStringLit</span> <span class="st">&quot;u&amp;&quot;</span> <span class="st">&quot;something&quot;</span>) <span class="ch">&#39;=&#39;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">u&amp;<span class="st">&#39;something&#39;</span> uescape =</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">UEscape</span> (<span class="dt">CSStringLit</span> <span class="st">&quot;u&amp;&quot;</span> <span class="st">&quot;something&quot;</span>) <span class="ch">&#39;=&#39;</span></code></pre>
</td></tr>
</table>
<h5 id="binary-string-literals"><a href="#binary-string-literals">binary string literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">X<span class="st">&#39;7f7f7f&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CSStringLit</span> <span class="st">&quot;X&quot;</span> <span class="st">&quot;7f7f7f&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">X<span class="st">&#39;7f7f7f&#39;</span> <span class="kw">escape</span> z</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Escape</span> (<span class="dt">CSStringLit</span> <span class="st">&quot;X&quot;</span> <span class="st">&quot;7f7f7f&quot;</span>) <span class="ch">&#39;z&#39;</span></code></pre>
</td></tr>
</table>
<h5 id="datetime-literals"><a href="#datetime-literals">datetime literals</a></h5>
<h5 id="intervalliterals-literals"><a href="#intervalliterals-literals">intervalLiterals literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;1&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;interval&quot;</span>]) <span class="st">&quot;1&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">day</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">day</span>(<span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> (<span class="kw">Just</span> (<span class="dv">3</span>, <span class="kw">Nothing</span>)), ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> + <span class="st">&#39;1&#39;</span> <span class="dt">day</span>(<span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Just</span> <span class="kw">True</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;day&quot;</span> (<span class="kw">Just</span> (<span class="dv">3</span>, <span class="kw">Nothing</span>)), ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> - <span class="st">&#39;1&#39;</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">2</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Just</span> <span class="kw">False</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">2</span>)), ilTo <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>, ilTo <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="st">&#39;1&#39;</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) </code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntervalLit</span>{ilSign <span class="fu">=</span> <span class="kw">Nothing</span>, ilLiteral <span class="fu">=</span> <span class="st">&quot;1&quot;</span>,
            ilFrom <span class="fu">=</span> <span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)),
            ilTo <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))}</code></pre>
</td></tr>
</table>
<h5 id="boolean-literals"><a href="#boolean-literals">boolean literals</a></h5>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">false</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;false&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">unknown</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;unknown&quot;</span>]</code></pre>
</td></tr>
</table>
<h3 id="identifiers-1"><a href="#identifiers-1">identifiers</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">test</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;test&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">_test</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;_test&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">t1</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;t1&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a.b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a.b.c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ot">&quot;quoted iden&quot;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">QName</span> <span class="st">&quot;quoted iden&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ot">&quot;quoted &quot;&quot; iden&quot;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">QName</span> <span class="st">&quot;quoted \&quot; iden&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">U&amp;<span class="ot">&quot;quoted iden&quot;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">UQName</span> <span class="st">&quot;quoted iden&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">U&amp;<span class="ot">&quot;quoted &quot;&quot; iden&quot;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">UQName</span> <span class="st">&quot;quoted \&quot; iden&quot;</span>]</code></pre>
</td></tr>
</table>
<h3 id="type-names"><a href="#type-names">type names</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> varbinary)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">varbinary <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> large <span class="dt">object</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> large <span class="dt">object</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> large <span class="dt">object</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> large <span class="dt">object</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">clob</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">clob</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">varying</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">varying</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> large <span class="dt">object</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> large <span class="dt">object</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nclob</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nclob</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary large <span class="dt">object</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary large <span class="dt">object</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">numeric</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">numeric</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">dec</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">dec</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">smallint</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">smallint</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">integer</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">integer</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">int</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">int</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> bigint)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">bigint <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">float</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">float</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">real</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">real</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">double</span> <span class="dt">precision</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">double</span> <span class="dt">precision</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">boolean</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">boolean</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">date</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">date</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">timestamp</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">timestamp</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">3</span> octets))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">3</span> octets) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span>(<span class="dv">50</span> characters))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
     (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
     (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3M))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3M) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3T))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3T) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3P))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3P) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(4M characters) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
     (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(4M characters)  <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
     (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(6G octets) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(6G octets)  <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K) )</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
     (<span class="kw">Just</span> <span class="dt">PrecK</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
     (<span class="kw">Just</span> <span class="dt">PrecK</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> collate something_insensitive)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> collate something_insensitive <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
     [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])]) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">RowTypeName</span>
     [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
      (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">RowTypeName</span>
     [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
      (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
     (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
     (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> varbinary <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">varbinary <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> varbinary <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">varbinary <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> large <span class="dt">object</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> large <span class="dt">object</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">clob</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">clob</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">clob</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">clob</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">varying</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">varying</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">varying</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> large <span class="dt">object</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> large <span class="dt">object</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nclob</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nclob</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nclob</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nclob</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary large <span class="dt">object</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary large <span class="dt">object</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary large <span class="dt">object</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">numeric</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">numeric</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">numeric</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">numeric</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">dec</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">dec</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">dec</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">dec</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">smallint</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">smallint</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">smallint</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">smallint</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">integer</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">integer</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">integer</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">integer</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">int</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">int</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">int</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">int</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> bigint <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">bigint <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> bigint <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">bigint <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">float</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">float</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">float</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">float</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">real</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">real</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">real</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">real</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">double</span> <span class="dt">precision</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">double</span> <span class="dt">precision</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">double</span> <span class="dt">precision</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">double</span> <span class="dt">precision</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">boolean</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">boolean</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">boolean</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">boolean</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">date</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">date</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">date</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">date</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]) <span class="kw">Nothing</span>) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">timestamp</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">timestamp</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">timestamp</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">timestamp</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">3</span> octets) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">3</span> octets) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">3</span> octets) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">3</span> octets) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3M) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3M) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3M) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3M) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3T) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3T) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3T) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3T) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3P) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3P) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3P) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3P) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(4M characters)  <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(4M characters)  <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(4M characters)  <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(4M characters)  <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(6G octets)  <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(6G octets)  <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(6G octets)  <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(6G octets)  <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>) (<span class="kw">Just</span> <span class="dt">PrecOctets</span>))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>) <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>) <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>) (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>) (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> collate something_insensitive <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> collate something_insensitive <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> collate something_insensitive <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>)
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>)))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="dt">array</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))
     <span class="kw">Nothing</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="dt">array</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))
     <span class="kw">Nothing</span>)
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="dt">array</span>[<span class="dv">5</span>])</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))
     (<span class="kw">Just</span> <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="dt">array</span>[<span class="dv">5</span>] <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">ArrayTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>)))))
     (<span class="kw">Just</span> <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary varying&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character varying&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> varbinary <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">varbinary <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varbinary&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">character</span> large <span class="dt">object</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;character large object&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> large <span class="dt">object</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> large <span class="dt">object</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char large object&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">clob</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">clob</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;clob&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character varying&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national char varying&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> <span class="dt">varying</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> <span class="dt">varying</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar varying&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nchar</span> large <span class="dt">object</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nchar</span> large <span class="dt">object</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nchar large object&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">nclob</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">nclob</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;nclob&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> binary large <span class="dt">object</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">binary large <span class="dt">object</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;binary large object&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">numeric</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">numeric</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;numeric&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">dec</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">dec</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;dec&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">smallint</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">smallint</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;smallint&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">integer</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">integer</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;integer&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">int</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">int</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> bigint <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">bigint <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;bigint&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">float</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">float</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;float&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">real</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">real</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;real&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">double</span> <span class="dt">precision</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">double</span> <span class="dt">precision</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;double precision&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">boolean</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">boolean</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;boolean&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">date</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">date</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;date&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>) (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">timestamp</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">timestamp</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;timestamp&quot;</span>])) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">5</span>)) <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span> (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="dv">5</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">decimal</span>(<span class="dv">15</span>,<span class="dv">2</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">PrecScaleTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;decimal&quot;</span>] <span class="dv">15</span> <span class="dv">2</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">3</span> octets) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>)))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">3</span> octets) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="dv">3</span> <span class="kw">Nothing</span> (<span class="kw">Just</span> <span class="dt">PrecOctets</span>)))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>)))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">varchar</span>(<span class="dv">50</span> characters) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;varchar&quot;</span>] <span class="dv">50</span> <span class="kw">Nothing</span>
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>)))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3M) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3M) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3T) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3T) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecT</span>) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(3P) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(3P) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">3</span> (<span class="kw">Just</span> <span class="dt">PrecP</span>) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(4M characters)  <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>)))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(4M characters)  <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">4</span> (<span class="kw">Just</span> <span class="dt">PrecM</span>)
        (<span class="kw">Just</span> <span class="dt">PrecCharacters</span>)))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">blob</span>(6G octets)  <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>)
        (<span class="kw">Just</span> <span class="dt">PrecOctets</span>)))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">blob</span>(6G octets)  <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;blob&quot;</span>] <span class="dv">6</span> (<span class="kw">Just</span> <span class="dt">PrecG</span>)
        (<span class="kw">Just</span> <span class="dt">PrecOctets</span>)))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">national</span> <span class="dt">character</span> large <span class="dt">object</span>(7K)  <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">PrecLengthTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;national character large object&quot;</span>] <span class="dv">7</span>
        (<span class="kw">Just</span> <span class="dt">PrecK</span>)
        <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">time</span> <span class="kw">with</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;time&quot;</span>] <span class="kw">Nothing</span> <span class="kw">True</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">datetime(<span class="dv">3</span>) <span class="kw">without</span> <span class="dt">time</span> <span class="dt">zone</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">TimeTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;datetime&quot;</span>] (<span class="kw">Just</span> <span class="dv">3</span>) <span class="kw">False</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> collate something_insensitive <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> collate something_insensitive <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> []
        [<span class="dt">Name</span> <span class="st">&quot;something_insensitive&quot;</span>]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        []))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]
        []))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span>(<span class="dv">5</span>) <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] (<span class="kw">Just</span> <span class="dv">5</span>) [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">char</span> <span class="dt">varying</span> <span class="dt">character</span> <span class="kw">set</span> something <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">CharTypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char varying&quot;</span>] <span class="kw">Nothing</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] []))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">RowTypeName</span> [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])]))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">RowTypeName</span>
        [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
         (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])]))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span> (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">2</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Nothing</span>))) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">5</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">5</span>))) <span class="kw">Nothing</span>))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>))))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span> <span class="kw">to</span> <span class="dt">month</span> <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> <span class="kw">Nothing</span>)
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;month&quot;</span> <span class="kw">Nothing</span>))))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;test&#39;</span> <span class="kw">as</span> <span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="kw">multiset</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;test&quot;</span>)
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>))))))</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">interval</span> <span class="dt">year</span>(<span class="dv">4</span>) <span class="kw">to</span> <span class="dt">second</span>(<span class="dv">2</span>,<span class="dv">3</span>) <span class="kw">multiset</span> <span class="st">&#39;test&#39;</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">TypedLit</span>
  (<span class="dt">MultisetTypeName</span>
     (<span class="dt">IntervalTypeName</span> (<span class="dt">Itf</span> <span class="st">&quot;year&quot;</span> (<span class="kw">Just</span> (<span class="dv">4</span>, <span class="kw">Nothing</span>)))
        (<span class="kw">Just</span> (<span class="dt">Itf</span> <span class="st">&quot;second&quot;</span> (<span class="kw">Just</span> (<span class="dv">2</span>, <span class="kw">Just</span> <span class="dv">3</span>))))))
  <span class="st">&quot;test&quot;</span></code></pre>
</td></tr>
</table>
<h3 id="field-definition"><a href="#field-definition">field definition</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(<span class="st">&#39;(1,2)&#39;</span> <span class="kw">as</span> <span class="kw">row</span>(a <span class="dt">int</span>,b <span class="dt">char</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">StringLit</span> <span class="st">&quot;(1,2)&quot;</span>)
  (<span class="dt">RowTypeName</span>
     [(<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>]),
      (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;char&quot;</span>])])</code></pre>
</td></tr>
</table>
<h3 id="value-expressions"><a href="#value-expressions">value expressions</a></h3>
<h4 id="general-value-specification"><a href="#general-value-specification">general value specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">CURRENT_DEFAULT_TRANSFORM_GROUP</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;CURRENT_DEFAULT_TRANSFORM_GROUP&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">CURRENT_PATH</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;CURRENT_PATH&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">CURRENT_ROLE</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;CURRENT_ROLE&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">CURRENT_USER</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;CURRENT_USER&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">SESSION_USER</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SESSION_USER&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">SYSTEM_USER</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SYSTEM_USER&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">USER</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;USER&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">VALUE</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;VALUE&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="parameter-specification"><a href="#parameter-specification">parameter specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ch">:hostparam</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">HostParameter</span> <span class="st">&quot;hostparam&quot;</span> <span class="kw">Nothing</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ch">:hostparam</span> <span class="kw">indicator</span> <span class="ch">:another_host_param</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">HostParameter</span> <span class="st">&quot;hostparam&quot;</span> (<span class="kw">Just</span> <span class="st">&quot;another_host_param&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">?</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parameter</span></code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="ch">:h</span>[<span class="dv">3</span>]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">HostParameter</span> <span class="st">&quot;h&quot;</span> <span class="kw">Nothing</span>) [<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="contextually-typed-value-specification"><a href="#contextually-typed-value-specification">contextually typed value specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">null</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;null&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">array</span>[]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;array&quot;</span>]) []</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">multiset</span>[]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetCtor</span> []</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">default</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;default&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="identifier-chain"><a href="#identifier-chain">identifier chain</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a.b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="column-reference"><a href="#column-reference">column reference</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">module.a.b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;module&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="set-function-specification"><a href="#set-function-specification">set function specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> SalesQuota, <span class="fu">SUM</span>(SalesYTD) TotalSalesYTD,
   <span class="fu">GROUPING</span>(SalesQuota) <span class="kw">AS</span> <span class="fu">Grouping</span>
<span class="kw">FROM</span> Sales.SalesPerson
<span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">ROLLUP</span>(SalesQuota);</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SalesQuota&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;SUM&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SalesYTD&quot;</span>]],
           <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;TotalSalesYTD&quot;</span>)),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;GROUPING&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SalesQuota&quot;</span>]],
           <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;Grouping&quot;</span>))],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;Sales&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;SalesPerson&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">Rollup</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;SalesQuota&quot;</span>])]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="window-function"><a href="#window-function">window function</a></h4>
<h4 id="nested-window-function"><a href="#nested-window-function">nested window function</a></h4>
<h4 id="case-expression"><a href="#case-expression">case expression</a></h4>
<h4 id="cast-specification"><a href="#cast-specification">cast specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cast</span>(a <span class="kw">as</span> <span class="dt">int</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Cast</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) (<span class="dt">TypeName</span> [<span class="dt">Name</span> <span class="st">&quot;int&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="next-value-expression"><a href="#next-value-expression">next value expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">next</span> <span class="fu">value</span> <span class="kw">for</span> a.b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NextValueFor</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="field-reference"><a href="#field-reference">field reference</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">f(something).a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;f&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>]
  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="array-element-reference"><a href="#array-element-reference">array element reference</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">something[<span class="dv">3</span>]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(something(a))[x]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">Parens</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]))
  [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(something(a))[x][y] </code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span>
  (<span class="dt">Array</span> (<span class="dt">Parens</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]))
     [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]])
  [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;y&quot;</span>]]</code></pre>
</td></tr>
</table>
<h4 id="multisetelementreference"><a href="#multisetelementreference">multisetElementReference</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">element(something)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;element&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]]</code></pre>
</td></tr>
</table>
<h4 id="numeric-value-expression"><a href="#numeric-value-expression">numeric value expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a + b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a - b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a * b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;*&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a / b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;/&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">+a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">-a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;-&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="numeric-value-function"><a href="#numeric-value-function">numeric value function</a></h4>
<h4 id="string-value-expression"><a href="#string-value-expression">string value expression</a></h4>
<h4 id="string-value-function"><a href="#string-value-function">string value function</a></h4>
<h4 id="datetime-value-expression"><a href="#datetime-value-expression">datetime value expression</a></h4>
<h5 id="datetime-value-function"><a href="#datetime-value-function">datetime value function</a></h5>
<h4 id="datetime-value-function-1"><a href="#datetime-value-function-1">datetime value function</a></h4>
<h4 id="interval-value-expression"><a href="#interval-value-expression">interval value expression</a></h4>
<h4 id="interval-value-function"><a href="#interval-value-function">interval value function</a></h4>
<h4 id="booleab-value-expression"><a href="#booleab-value-expression">booleab value expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">or</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">and</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;and&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">not</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PrefixOp</span> [<span class="dt">Name</span> <span class="st">&quot;not&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is true&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">false</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is false&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> unknown</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is unknown&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not true&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> <span class="kw">false</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not false&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">is</span> <span class="kw">not</span> unknown</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">PostfixOp</span> [<span class="dt">Name</span> <span class="st">&quot;is not unknown&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a <span class="kw">or</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parens</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;or&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))</code></pre>
</td></tr>
</table>
<h4 id="array-value-expression"><a href="#array-value-expression">array value expression</a></h4>
<h4 id="array-value-function"><a href="#array-value-function">array value function</a></h4>
<h4 id="array-value-constructor"><a href="#array-value-constructor">array value constructor</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">array</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;array&quot;</span>]) [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">array</span>[a,b,c]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Array</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;array&quot;</span>])
  [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">array</span>(<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ArrayCtor</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="dt">array</span>(<span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ArrayCtor</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span>
            [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="multiset-value-expression"><a href="#multiset-value-expression">multiset value expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">multiset</span> <span class="kw">union</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetBinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Union</span> <span class="dt">SQDefault</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">multiset</span> <span class="kw">union</span> <span class="kw">all</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetBinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Union</span> <span class="dt">All</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">multiset</span> <span class="kw">union</span> <span class="kw">distinct</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetBinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Union</span> <span class="dt">Distinct</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">multiset</span> <span class="kw">except</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetBinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Except</span> <span class="dt">SQDefault</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a <span class="kw">multiset</span> <span class="kw">intersect</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetBinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Intersect</span> <span class="dt">SQDefault</span>
  (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
</table>
<h4 id="multiset-value-function"><a href="#multiset-value-function">multiset value function</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">set</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;set&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
</table>
<h4 id="multiset-value-constructor"><a href="#multiset-value-constructor">multiset value constructor</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">multiset</span>[a,b,c]</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetCtor</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">multiset</span>(<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetQueryCtor</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">table</span>(<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultisetQueryCtor</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="parenthesized-value-expression"><a href="#parenthesized-value-expression">parenthesized value expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(<span class="dv">3</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parens</span> (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>)</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">((<span class="dv">3</span>))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Parens</span> (<span class="dt">Parens</span> (<span class="dt">NumLit</span> <span class="st">&quot;3&quot;</span>))</code></pre>
</td></tr>
</table>
<h3 id="query-expressions"><a href="#query-expressions">query expressions</a></h3>
<h4 id="row-value-constructor"><a href="#row-value-constructor">row value constructor</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(<span class="dv">1</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;row&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">row</span>(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;row&quot;</span>] [<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="table-value-constructor"><a href="#table-value-constructor">table value constructor</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">values</span> (<span class="dv">1</span>,<span class="dv">2</span>), (a+b,(<span class="kw">select</span> <span class="fu">count</span>(*) <span class="kw">from</span> t));</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Values</span>
  [[<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>, <span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>],
   [<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;+&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]),
    <span class="dt">SubQueryExpr</span> <span class="dt">SqSq</span>
      (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
              qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>], <span class="kw">Nothing</span>)],
              qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
              qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
              qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})]]</code></pre>
</td></tr>
</table>
<h4 id="fromclause"><a href="#fromclause">fromClause</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> tbl1,tbl2</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;tbl1&quot;</span>], <span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;tbl2&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="table-reference"><a href="#table-reference">table reference</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">as</span> u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]) (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t u(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>])
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">as</span> u(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>])
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) (<span class="kw">Just</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> (<span class="kw">select</span> * <span class="kw">from</span> t) u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span>
            (<span class="dt">TRQueryExpr</span>
               (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
                       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
                       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
                       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}))
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> lateral t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRLateral</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>])], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> (a <span class="kw">join</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRParens</span>
            (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
               <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> (a <span class="kw">join</span> b) u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span>
            (<span class="dt">TRParens</span>
               (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
                  <span class="kw">Nothing</span>))
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> ((a <span class="kw">join</span> b)) u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span>
            (<span class="dt">TRParens</span>
               (<span class="dt">TRParens</span>
                  (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
                     <span class="kw">Nothing</span>)))
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> ((a <span class="kw">join</span> b) u) u</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRAlias</span>
            (<span class="dt">TRParens</span>
               (<span class="dt">TRAlias</span>
                  (<span class="dt">TRParens</span>
                     (<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
                        <span class="kw">Nothing</span>))
                  (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)))
            (<span class="dt">Alias</span> (<span class="dt">Name</span> <span class="st">&quot;u&quot;</span>) <span class="kw">Nothing</span>)],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="joined-table"><a href="#joined-table">joined table</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">cross</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JCross</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">join</span> b <span class="kw">using</span> (c)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinUsing</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">inner</span> <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">left</span> <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">left</span> <span class="kw">outer</span> <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">right</span> <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JRight</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">full</span> <span class="kw">join</span> b <span class="kw">on</span> <span class="kw">true</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span> <span class="dt">JFull</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            (<span class="kw">Just</span> (<span class="dt">JoinOn</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;true&quot;</span>])))],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">inner</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JInner</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">left</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">left</span> <span class="kw">outer</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JLeft</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">right</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JRight</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> a <span class="kw">natural</span> <span class="kw">full</span> <span class="kw">join</span> b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span>
         [<span class="dt">TRJoin</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">True</span> <span class="dt">JFull</span> (<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])
            <span class="kw">Nothing</span>],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="where-clause"><a href="#where-clause">where clause</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">where</span> a = <span class="dv">5</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)),
       qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="group-by-clause"><a href="#group-by-clause">group by clause</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a collate c</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Collate</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>])],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="kw">rollup</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">Rollup</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="kw">cube</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">Cube</span>
            [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> <span class="fu">grouping</span> sets((),(a,b))</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span>
         [<span class="dt">GroupingSets</span>
            [<span class="dt">GroupingParens</span> [],
             <span class="dt">GroupingParens</span>
               [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]), <span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])]]],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> ()</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">GroupingParens</span> []], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="having-clause"><a href="#having-clause">having clause</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,<span class="fu">sum</span>(x) <span class="kw">from</span> t <span class="kw">group</span> <span class="kw">by</span> a <span class="kw">having</span> <span class="fu">sum</span>(x) &gt; <span class="dv">1000</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>),
          (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeGroupBy <span class="fu">=</span> [<span class="dt">SimpleGroup</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>])],
       qeHaving <span class="fu">=</span>
         <span class="kw">Just</span>
           (<span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>]
              (<span class="dt">NumLit</span> <span class="st">&quot;1000&quot;</span>)),
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="window-clause"><a href="#window-clause">window clause</a></h4>
<h4 id="query-specification"><a href="#query-specification">query specification</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="kw">all</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">All</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="kw">distinct</span> a <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">Distinct</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a.* <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;.&quot;</span>] <span class="dt">Star</span>, <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a b <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>))],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">as</span> b <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Just</span> (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>))],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a,b <span class="kw">from</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span>
         [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h4 id="with-query-expression"><a href="#with-query-expression">with query expression</a></h4>
<h4 id="set-operation-query-expression"><a href="#set-operation-query-expression">set operation query expression</a></h4>
<h4 id="explicit-table-query-expression"><a href="#explicit-table-query-expression">explicit table query expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">table</span> t</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Table</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]</code></pre>
</td></tr>
</table>
<h4 id="order-offset-fetch-query-expression"><a href="#order-offset-fetch-query-expression">order, offset, fetch query expression</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t offset <span class="dv">5</span> <span class="kw">row</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>),
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t offset <span class="dv">5</span> <span class="kw">rows</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>),
       qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> a <span class="kw">from</span> t fetch <span class="fu">first</span> <span class="dv">5</span> <span class="kw">row</span> <span class="kw">only</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
       qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
       qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeFetchFirst <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>)}</code></pre>
</td></tr>
</table>
<h4 id="search-or-cycle-clause"><a href="#search-or-cycle-clause">search or cycle clause</a></h4>
<h3 id="scalar-subquery"><a href="#scalar-subquery">scalar subquery</a></h3>
<h3 id="predicates"><a href="#predicates">predicates</a></h3>
<h4 id="comparison-predicates"><a href="#comparison-predicates">comparison predicates</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a = b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &lt;&gt; b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &lt; b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &gt; b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &lt;= b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &gt;= b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;=&quot;</span>] (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">ROW</span>(a) = <span class="kw">ROW</span>(b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span> (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
  (<span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;ROW&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]])</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a,b) = (c,d)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BinOp</span>
  (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]])
  [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>]
  (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;d&quot;</span>]])</code></pre>
</td></tr>
</table>
<h4 id="between-predicate"><a href="#between-predicate">between predicate</a></h4>
<h4 id="in-predicate"><a href="#in-predicate">in predicate</a></h4>
<h4 id="like-predicate"><a href="#like-predicate">like predicate</a></h4>
<h4 id="similar-predicate"><a href="#similar-predicate">similar predicate</a></h4>
<h4 id="regex-like-predicate"><a href="#regex-like-predicate">regex like predicate</a></h4>
<h4 id="null-predicate"><a href="#null-predicate">null predicate</a></h4>
<h4 id="quantified-comparison-predicate"><a href="#quantified-comparison-predicate">quantified comparison predicate</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a = <span class="kw">any</span> (<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] <span class="dt">CPAny</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &lt;= <span class="kw">some</span> (<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&lt;=&quot;</span>] <span class="dt">CPSome</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a &gt; <span class="kw">all</span> (<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] <span class="dt">CPAll</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a,b) &lt;&gt; <span class="kw">all</span> (<span class="kw">select</span> * <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">QuantifiedComparison</span>
  (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]])
  [<span class="dt">Name</span> <span class="st">&quot;&lt;&gt;&quot;</span>]
  <span class="dt">CPAll</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="exists-predicate"><a href="#exists-predicate">exists predicate</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">exists</span>(<span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">where</span> a = <span class="dv">4</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SubQueryExpr</span> <span class="dt">SqExists</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>)),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="unique-predicate"><a href="#unique-predicate">unique predicate</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">unique</span>(<span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">where</span> a = <span class="dv">4</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SubQueryExpr</span> <span class="dt">SqUnique</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
          qeWhere <span class="fu">=</span> <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;=&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;4&quot;</span>)),
          qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [],
          qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="normalized-predicate"><a href="#normalized-predicate">normalized predicate</a></h4>
<h4 id="match-predicate"><a href="#match-predicate">match predicate</a></h4>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a match (<span class="kw">select</span> a <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Match</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="kw">False</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span> [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a,b) match (<span class="kw">select</span> a,b <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Match</span>
  (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]])
  <span class="kw">False</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">(a,b) match <span class="kw">unique</span> (<span class="kw">select</span> a,b <span class="kw">from</span> t)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Match</span>
  (<span class="dt">SpecialOp</span> [<span class="dt">Name</span> <span class="st">&quot;rowctor&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]])
  <span class="kw">True</span>
  (<span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
          qeSelectList <span class="fu">=</span>
            [(<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="kw">Nothing</span>), (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>], <span class="kw">Nothing</span>)],
          qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]], qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [],
          qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>, qeOrderBy <span class="fu">=</span> [], qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>,
          qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>})</code></pre>
</td></tr>
</table>
<h4 id="overlaps-predicate"><a href="#overlaps-predicate">overlaps predicate</a></h4>
<h4 id="distinct-predicate"><a href="#distinct-predicate">distinct predicate</a></h4>
<h4 id="member-predicate"><a href="#member-predicate">member predicate</a></h4>
<h4 id="submultiset-predicate"><a href="#submultiset-predicate">submultiset predicate</a></h4>
<h4 id="set-predicate"><a href="#set-predicate">set predicate</a></h4>
<h4 id="period-predicate"><a href="#period-predicate">period predicate</a></h4>
<h3 id="interval-qualifier"><a href="#interval-qualifier">interval qualifier</a></h3>
<h3 id="collate-clause"><a href="#collate-clause">collate clause</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">a collate my_collation</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Collate</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;my_collation&quot;</span>]</code></pre>
</td></tr>
</table>
<h3 id="aggregate-function"><a href="#aggregate-function">aggregate function</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(*)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Star</span>]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(*) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Star</span>], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(<span class="kw">all</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">All</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">count</span>(<span class="kw">all</span> a) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;count&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">All</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">avg</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">avg</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;avg&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">max</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">max</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;max&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">min</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;min&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">min</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;min&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">sum</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;sum&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">every(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;every&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">every(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;every&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">any</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;any&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">any</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;any&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">some</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;some&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">some</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;some&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">stddev_pop</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;stddev_pop&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">stddev_pop</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;stddev_pop&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">stddev_samp</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;stddev_samp&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">stddev_samp</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;stddev_samp&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>, aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
             aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">var_samp</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;var_samp&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">var_samp</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;var_samp&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">var_pop</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;var_pop&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">var_pop</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;var_pop&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">collect</span>(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;collect&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">collect</span>(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;collect&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">fusion(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;fusion&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">fusion(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;fusion&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]], aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">intersection(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;intersection&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">intersection(<span class="kw">distinct</span> a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;intersection&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">Distinct</span>, aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
             aggOrderBy <span class="fu">=</span> [], aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">COVAR_POP</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;COVAR_POP&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">COVAR_POP</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;COVAR_POP&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">COVAR_SAMP</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;COVAR_SAMP&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">COVAR_SAMP</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;COVAR_SAMP&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">CORR</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;CORR&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">CORR</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;CORR&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SLOPE</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SLOPE&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SLOPE</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SLOPE&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_INTERCEPT</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_INTERCEPT&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_INTERCEPT</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_INTERCEPT&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_COUNT</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_COUNT&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_COUNT</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_COUNT&quot;</span>],
             aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_R2</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_R2&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_R2</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_R2&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_AVGX</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_AVGX&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_AVGX</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_AVGX&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_AVGY</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_AVGY&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_AVGY</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_AVGY&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SXX</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SXX&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SXX</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SXX&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SYY</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SYY&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SYY</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SYY&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SXY</span>(a,b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SXY&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">REGR_SXY</span>(a,b) <span class="kw">filter</span> (<span class="kw">where</span> something &gt; <span class="dv">5</span>)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;REGR_SXY&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]], aggOrderBy <span class="fu">=</span> [],
             aggFilter <span class="fu">=</span>
               <span class="kw">Just</span> (<span class="dt">BinOp</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;something&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;&gt;&quot;</span>] (<span class="dt">NumLit</span> <span class="st">&quot;5&quot;</span>))}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">rank</span>(a,c) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;rank&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>], <span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;c&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">dense_rank</span>(a) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;dense_rank&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">percent_rank</span>(a) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;percent_rank&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">cume_dist</span>(a) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;cume_dist&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">percentile_cont</span>(a) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;percentile_cont&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">percentile_disc</span>(a) within <span class="kw">group</span> (<span class="kw">order</span> <span class="kw">by</span> b)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateAppGroup</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;percentile_disc&quot;</span>],
                  aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
                  aggGroup <span class="fu">=</span>
                    [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>]}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">array_agg(a)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span> [<span class="dt">Name</span> <span class="st">&quot;array_agg&quot;</span>] [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]]</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql">array_agg(a <span class="kw">order</span> <span class="kw">by</span> z)</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">AggregateApp</span>{aggName <span class="fu">=</span> [<span class="dt">Name</span> <span class="st">&quot;array_agg&quot;</span>], aggDistinct <span class="fu">=</span> <span class="dt">SQDefault</span>,
             aggArgs <span class="fu">=</span> [<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]],
             aggOrderBy <span class="fu">=</span>
               [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;z&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
             aggFilter <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>
<h3 id="sort-specification-list"><a href="#sort-specification-list">sort specification list</a></h3>
<table>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a <span class="kw">asc</span>,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Asc</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a <span class="kw">desc</span>,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) <span class="dt">Desc</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> a collate x <span class="kw">desc</span>,b</code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">Collate</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>]) [<span class="dt">Name</span> <span class="st">&quot;x&quot;</span>]) <span class="dt">Desc</span>
            <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">Iden</span> [<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>]) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
<tr><td>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> t <span class="kw">order</span> <span class="kw">by</span> <span class="dv">1</span>,<span class="dv">2</span></code></pre>
</td><td>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Select</span>{qeSetQuantifier <span class="fu">=</span> <span class="dt">SQDefault</span>,
       qeSelectList <span class="fu">=</span> [(<span class="dt">Star</span>, <span class="kw">Nothing</span>)], qeFrom <span class="fu">=</span> [<span class="dt">TRSimple</span> [<span class="dt">Name</span> <span class="st">&quot;t&quot;</span>]],
       qeWhere <span class="fu">=</span> <span class="kw">Nothing</span>, qeGroupBy <span class="fu">=</span> [], qeHaving <span class="fu">=</span> <span class="kw">Nothing</span>,
       qeOrderBy <span class="fu">=</span>
         [<span class="dt">SortSpec</span> (<span class="dt">NumLit</span> <span class="st">&quot;1&quot;</span>) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>,
          <span class="dt">SortSpec</span> (<span class="dt">NumLit</span> <span class="st">&quot;2&quot;</span>) <span class="dt">DirDefault</span> <span class="dt">NullsOrderDefault</span>],
       qeOffset <span class="fu">=</span> <span class="kw">Nothing</span>, qeFetchFirst <span class="fu">=</span> <span class="kw">Nothing</span>}</code></pre>
</td></tr>
</table>

</body>
</html>
