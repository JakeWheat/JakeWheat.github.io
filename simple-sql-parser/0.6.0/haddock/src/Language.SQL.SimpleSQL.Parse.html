<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span>
</span><span id="line-2"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">TOC</span><span class="hs-glyph">:</span><span>
</span><span id="line-3"></span><span>
</span><span id="line-4"></span><span class="hs-identifier">notes</span><span>
</span><span id="line-5"></span><span class="hs-identifier">Public</span><span> </span><span class="hs-identifier">api</span><span>
</span><span id="line-6"></span><span class="hs-identifier">Names</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">identifiers</span><span>
</span><span id="line-7"></span><span class="hs-identifier">Typenames</span><span>
</span><span id="line-8"></span><span class="hs-identifier">Scalar</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-9"></span><span>  </span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">literals</span><span>
</span><span id="line-10"></span><span>  </span><span class="hs-identifier">star</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">param</span><span>
</span><span id="line-11"></span><span>  </span><span class="hs-identifier">parens</span><span> </span><span class="hs-identifier">expression</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">row</span><span> </span><span class="hs-identifier">constructor</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">subquery</span><span>
</span><span id="line-12"></span><span>  </span><span class="hs-keyword">case</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">cast</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">exists</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unique</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">array</span><span class="hs-operator">/</span><span> </span><span class="hs-identifier">multiset</span><span> </span><span class="hs-identifier">constructor</span><span>
</span><span id="line-13"></span><span>  </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">app</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-identifier">function</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">aggregate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">function</span><span>
</span><span id="line-14"></span><span>  </span><span class="hs-identifier">suffixes</span><span class="hs-glyph">:</span><span> </span><span class="hs-keyword">in</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">between</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">quantified</span><span> </span><span class="hs-identifier">comparison</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">match</span><span> </span><span class="hs-identifier">predicate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">array</span><span>
</span><span id="line-15"></span><span>    </span><span class="hs-identifier">subscript</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">escape</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">collate</span><span>
</span><span id="line-16"></span><span>  </span><span class="hs-identifier">operators</span><span>
</span><span id="line-17"></span><span>  </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">top</span><span> </span><span class="hs-identifier">level</span><span>
</span><span id="line-18"></span><span>  </span><span class="hs-identifier">helpers</span><span>
</span><span id="line-19"></span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-20"></span><span>  </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">lists</span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">clause</span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">table</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">clauses</span><span class="hs-glyph">:</span><span>
</span><span id="line-23"></span><span>    </span><span class="hs-keyword">where</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">group</span><span> </span><span class="hs-identifier">by</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">having</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">order</span><span> </span><span class="hs-identifier">by</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">offset</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">fetch</span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-identifier">common</span><span> </span><span class="hs-identifier">table</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expression</span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-identifier">set</span><span> </span><span class="hs-identifier">operations</span><span>
</span><span id="line-27"></span><span class="hs-identifier">lexers</span><span>
</span><span id="line-28"></span><span class="hs-identifier">utilities</span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Notes</span><span> </span><span class="hs-identifier">about</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">code</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">lexers</span><span> </span><span class="hs-identifier">appear</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">bottom</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">file</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">tries</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">clear</span><span>
</span><span id="line-33"></span><span class="hs-identifier">separation</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">lexers</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-34"></span><span class="hs-identifier">lexers</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">isn't</span><span> </span><span class="hs-number">100</span><span class="hs-operator">%</span><span> </span><span class="hs-identifier">complete</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">moment</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">needs</span><span> </span><span class="hs-identifier">fixing</span><span class="hs-operator">.</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Left</span><span> </span><span class="hs-identifier">factoring</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">aggressively</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factored</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">avoided</span><span> </span><span class="hs-keyword">as</span><span>
</span><span id="line-39"></span><span class="hs-identifier">much</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">possible</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Try</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">avoided</span><span> </span><span class="hs-identifier">because</span><span class="hs-glyph">:</span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">overused</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">hard</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">follow</span><span>
</span><span id="line-42"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">overused</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">harder</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">debug</span><span>
</span><span id="line-43"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span> </span><span class="hs-identifier">much</span><span> </span><span class="hs-identifier">worse</span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">could</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">made</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">bit</span><span> </span><span class="hs-identifier">simpler</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">few</span><span> </span><span class="hs-identifier">extra</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">trys'</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">this</span><span>
</span><span id="line-46"></span><span class="hs-identifier">isn't</span><span> </span><span class="hs-identifier">done</span><span> </span><span class="hs-identifier">because</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">impact</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">error</span><span>
</span><span id="line-47"></span><span class="hs-identifier">messages</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Apparently</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">help</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">speed</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">hasn't</span><span> </span><span class="hs-identifier">been</span><span>
</span><span id="line-48"></span><span class="hs-identifier">looked</span><span> </span><span class="hs-identifier">into</span><span class="hs-operator">.</span><span>
</span><span id="line-49"></span><span>
</span><span id="line-50"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Parser</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-identifier">A</span><span> </span><span class="hs-identifier">lot</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">care</span><span> </span><span class="hs-identifier">has</span><span> </span><span class="hs-identifier">been</span><span> </span><span class="hs-identifier">given</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">generating</span><span> </span><span class="hs-identifier">good</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span>
</span><span id="line-53"></span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">invalid</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">few</span><span> </span><span class="hs-identifier">utils</span><span> </span><span class="hs-identifier">below</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">partially</span><span> </span><span class="hs-identifier">help</span><span>
</span><span id="line-54"></span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">area</span><span class="hs-operator">.</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">set</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">crafted</span><span> </span><span class="hs-identifier">bad</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">ErrorMessages.lhs</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">these</span><span>
</span><span id="line-57"></span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">guage</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">quality</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">monitor</span><span>
</span><span id="line-58"></span><span class="hs-identifier">regressions</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">hand</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-operator">&lt;?&gt;</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">limited</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">much</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">possible</span><span class="hs-glyph">:</span><span>
</span><span id="line-59"></span><span class="hs-identifier">each</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">should</span><span> </span><span class="hs-identifier">justify</span><span> </span><span class="hs-identifier">itself</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">improving</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">actual</span><span> </span><span class="hs-identifier">error</span><span>
</span><span id="line-60"></span><span class="hs-identifier">message</span><span class="hs-operator">.</span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">plan</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">write</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">really</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">which</span><span>
</span><span id="line-63"></span><span class="hs-identifier">doesn't</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">precedence</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">associativity</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">pass</span><span>
</span><span id="line-64"></span><span class="hs-identifier">over</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">ast</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">I</span><span> </span><span class="hs-identifier">don't</span><span> </span><span class="hs-identifier">think</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">way</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">sanely</span><span> </span><span class="hs-identifier">handle</span><span>
</span><span id="line-65"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">common</span><span> </span><span class="hs-identifier">prefixes</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">postfix</span><span> </span><span class="hs-identifier">multiple</span><span> </span><span class="hs-identifier">keyword</span><span>
</span><span id="line-66"></span><span class="hs-identifier">operators</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">ambiguities</span><span> </span><span class="hs-identifier">also</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">should</span><span> </span><span class="hs-identifier">help</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">lot</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-67"></span><span class="hs-identifier">generating</span><span> </span><span class="hs-identifier">good</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span> </span><span class="hs-identifier">also</span><span class="hs-operator">.</span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span class="hs-identifier">Both</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factoring</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">message</span><span> </span><span class="hs-identifier">work</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">greatly</span><span> </span><span class="hs-identifier">complicated</span><span>
</span><span id="line-70"></span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">large</span><span> </span><span class="hs-identifier">number</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">shared</span><span> </span><span class="hs-identifier">prefixes</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">various</span><span> </span><span class="hs-identifier">elements</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">SQL</span><span>
</span><span id="line-71"></span><span class="hs-identifier">syntax</span><span class="hs-operator">.</span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Main</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factoring</span><span> </span><span class="hs-identifier">issues</span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">three</span><span> </span><span class="hs-identifier">big</span><span> </span><span class="hs-identifier">areas</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">tricky</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factor</span><span class="hs-glyph">:</span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">typenames</span><span>
</span><span id="line-78"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">identifier</span><span>
</span><span id="line-79"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">suffix</span><span> </span><span class="hs-identifier">operators</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">typenames</span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">number</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">variations</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">standard</span><span>
</span><span id="line-84"></span><span class="hs-identifier">deals</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">switching</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">parsed</span><span>
</span><span id="line-85"></span><span class="hs-identifier">first</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">doesn't</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">currently</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-86"></span><span class="hs-identifier">future</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Taking</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">approach</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-identifier">grammar</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">limit</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-87"></span><span class="hs-identifier">extensibility</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-identifier">affect</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">ease</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">adapting</span><span> </span><span class="hs-identifier">to</span><span>
</span><span id="line-88"></span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">sql</span><span> </span><span class="hs-identifier">dialects</span><span class="hs-operator">.</span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">lot</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">nodes</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span>
</span><span id="line-93"></span><span class="hs-identifier">identifiers</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">can't</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">distinguished</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">tokens</span><span> </span><span class="hs-identifier">after</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">initial</span><span>
</span><span id="line-94"></span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">parsed</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Using</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">implement</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">variations</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">very</span><span>
</span><span id="line-95"></span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">much</span><span> </span><span class="hs-identifier">harder</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">debug</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span>
</span><span id="line-96"></span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span> </span><span class="hs-identifier">really</span><span> </span><span class="hs-identifier">bad</span><span class="hs-operator">.</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-identifier">Here</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">list</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">nodes</span><span class="hs-glyph">:</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">identifiers</span><span>
</span><span id="line-101"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">application</span><span>
</span><span id="line-102"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">aggregate</span><span> </span><span class="hs-identifier">application</span><span>
</span><span id="line-103"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">application</span><span>
</span><span id="line-104"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">string'</span><span>
</span><span id="line-105"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">extras</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">further</span><span> </span><span class="hs-identifier">ambiguity</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literals</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">precision</span><span class="hs-special">,</span><span>
</span><span id="line-108"></span><span class="hs-identifier">functions</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">aggregates</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">etc</span><span class="hs-operator">.</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">identifier</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">followed</span><span> </span><span class="hs-identifier">by</span><span>
</span><span id="line-109"></span><span class="hs-identifier">parens</span><span> </span><span class="hs-identifier">comma</span><span> </span><span class="hs-identifier">separated</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">something</span><span> </span><span class="hs-identifier">similar</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">it</span><span>
</span><span id="line-110"></span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">later</span><span> </span><span class="hs-identifier">that</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">find</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">token</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">tells</span><span> </span><span class="hs-identifier">us</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">flavour</span><span> </span><span class="hs-identifier">it</span><span>
</span><span id="line-111"></span><span class="hs-identifier">is</span><span class="hs-operator">.</span><span>
</span><span id="line-112"></span><span>
</span><span id="line-113"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">set</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">nodes</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">identifier</span><span class="hs-operator">/</span><span class="hs-identifier">keyword</span><span>
</span><span id="line-114"></span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">commit</span><span> </span><span class="hs-identifier">since</span><span> </span><span class="hs-identifier">no</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">same</span><span> </span><span class="hs-identifier">way</span><span class="hs-glyph">:</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-keyword">case</span><span>
</span><span id="line-117"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">cast</span><span>
</span><span id="line-118"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">exists</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unique</span><span> </span><span class="hs-identifier">subquery</span><span>
</span><span id="line-119"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">array</span><span> </span><span class="hs-identifier">constructor</span><span>
</span><span id="line-120"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">multiset</span><span> </span><span class="hs-identifier">constructor</span><span>
</span><span id="line-121"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">functions</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">extract</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">position</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">substring</span><span class="hs-special">,</span><span>
</span><span id="line-122"></span><span>  </span><span class="hs-identifier">convert</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">translate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">overlay</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">trim</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">etc</span><span class="hs-operator">.</span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">mentioned</span><span> </span><span class="hs-identifier">above</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">treated</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">group</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-125"></span><span class="hs-identifier">moment</span><span class="hs-glyph">:</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">see</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">interval'</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">either</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">full</span><span> </span><span class="hs-identifier">interval</span><span>
</span><span id="line-126"></span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">only</span><span class="hs-operator">.</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-identifier">Some</span><span> </span><span class="hs-identifier">items</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">list</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">fixed</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">future</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">to</span><span>
</span><span id="line-129"></span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">substring</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-number">3</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-number">5</span><span class="hs-special">)</span><span class="hs-special">'</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">well</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">regular</span><span>
</span><span id="line-130"></span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">substring</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">substring</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span class="hs-special">,</span><span class="hs-number">3</span><span class="hs-special">,</span><span class="hs-number">5</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">same</span><span> </span><span class="hs-identifier">time</span><span class="hs-operator">.</span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">work</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factoring</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">mostly</span><span> </span><span class="hs-identifier">done</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">still</span><span>
</span><span id="line-133"></span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">substantial</span><span> </span><span class="hs-identifier">bit</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">complete</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">far</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">most</span><span> </span><span class="hs-identifier">difficult</span><span>
</span><span id="line-134"></span><span class="hs-identifier">bit</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">At</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">moment</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">work</span><span> </span><span class="hs-identifier">around</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">try</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">downsides</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-135"></span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">poor</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span class="hs-operator">.</span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="hs-operator">===</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">suffix</span><span> </span><span class="hs-identifier">operators</span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">permissiveness</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">very</span><span> </span><span class="hs-identifier">permissive</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-identifier">ways</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">departs</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-142"></span><span class="hs-identifier">standard</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">able</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">eliminate</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">number</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">possibilities</span><span> </span><span class="hs-identifier">just</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-143"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">grammar</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">allows</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">done</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">number</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-144"></span><span class="hs-identifier">reasons</span><span class="hs-glyph">:</span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">makes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">less</span><span> </span><span class="hs-identifier">variations</span><span>
</span><span id="line-147"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">should</span><span> </span><span class="hs-identifier">allow</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">dialects</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">extensibility</span><span> </span><span class="hs-identifier">more</span><span> </span><span class="hs-identifier">easily</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-identifier">future</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">new</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">binary</span><span> </span><span class="hs-identifier">operators</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">custom</span><span> </span><span class="hs-identifier">precedence</span><span class="hs-special">)</span><span>
</span><span id="line-149"></span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-identifier">things</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">effectively</span><span> </span><span class="hs-identifier">checked</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">grammar</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-identifier">standard</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">checked</span><span> </span><span class="hs-identifier">using</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">typechecker</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">static</span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-identifier">analysis</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-identifier">To</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">front</span><span> </span><span class="hs-identifier">end</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">sql</span><span> </span><span class="hs-identifier">engine</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">sql</span><span> </span><span class="hs-identifier">validity</span><span>
</span><span id="line-154"></span><span class="hs-identifier">checker</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">need</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">lot</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">checks</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">ast</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">A</span><span>
</span><span id="line-155"></span><span class="hs-identifier">typechecker</span><span class="hs-operator">/</span><span class="hs-identifier">static</span><span> </span><span class="hs-identifier">checker</span><span> </span><span class="hs-identifier">plus</span><span> </span><span class="hs-identifier">annotation</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">being</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">compiler</span><span>
</span><span id="line-156"></span><span class="hs-identifier">front</span><span> </span><span class="hs-identifier">end</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">planned</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">likely</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">happen</span><span> </span><span class="hs-identifier">too</span><span> </span><span class="hs-identifier">soon</span><span class="hs-operator">.</span><span>
</span><span id="line-157"></span><span>
</span><span id="line-158"></span><span class="hs-identifier">Some</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">areas</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">affects</span><span class="hs-glyph">:</span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span class="hs-identifier">typenames</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">variation</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">should</span><span> </span><span class="hs-identifier">switch</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">actual</span><span>
</span><span id="line-161"></span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">given</span><span> </span><span class="hs-identifier">according</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">standard</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">does</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">for</span><span>
</span><span id="line-162"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">names</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">E.g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">write</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">int</span><span>
</span><span id="line-163"></span><span class="hs-identifier">collate</span><span> </span><span class="hs-identifier">C'</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">int</span><span class="hs-special">(</span><span class="hs-number">15</span><span class="hs-special">,</span><span class="hs-number">2</span><span class="hs-special">)</span><span class="hs-special">'</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">character</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-164"></span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-identifier">scale</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instead</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">being</span><span> </span><span class="hs-identifier">rejected</span><span class="hs-operator">.</span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">every</span><span> </span><span class="hs-identifier">variation</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-identifier">uses</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">same</span><span>
</span><span id="line-167"></span><span class="hs-identifier">parser</span><span class="hs-operator">/</span><span class="hs-identifier">syntax</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">means</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">don't</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">stop</span><span> </span><span class="hs-identifier">non</span><span> </span><span class="hs-identifier">boolean</span><span> </span><span class="hs-identifier">valued</span><span>
</span><span id="line-168"></span><span class="hs-identifier">expressions</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">boolean</span><span> </span><span class="hs-identifier">valued</span><span> </span><span class="hs-identifier">contexts</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Another</span><span> </span><span class="hs-identifier">area</span><span>
</span><span id="line-169"></span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">affects</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">that</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">allow</span><span> </span><span class="hs-identifier">general</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">group</span><span> </span><span class="hs-identifier">by</span><span class="hs-special">,</span><span>
</span><span id="line-170"></span><span class="hs-identifier">whereas</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">allows</span><span> </span><span class="hs-identifier">column</span><span> </span><span class="hs-identifier">names</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">collation</span><span class="hs-operator">.</span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span class="hs-identifier">These</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">areas</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">specified</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">roughly</span><span> </span><span class="hs-identifier">speaking</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-173"></span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">rather</span><span> </span><span class="hs-identifier">than</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">semantics</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">standard</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">not</span><span>
</span><span id="line-174"></span><span class="hs-identifier">fixing</span><span> </span><span class="hs-identifier">them</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">leaving</span><span> </span><span class="hs-identifier">them</span><span> </span><span class="hs-identifier">till</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">semantic</span><span> </span><span class="hs-identifier">checking</span><span>
</span><span id="line-175"></span><span class="hs-special">(</span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">doesn't</span><span> </span><span class="hs-identifier">exist</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">time</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-176"></span><span>
</span><span id="line-177"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-178"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- | This is the module with the parser functions.</span><span>
</span><span id="line-179"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.SQL.SimpleSQL.Parse</span><span>
</span><span id="line-180"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseQueryExpr"><span class="hs-identifier">parseQueryExpr</span></a></span><span>
</span><span id="line-181"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseScalarExpr"><span class="hs-identifier">parseScalarExpr</span></a></span><span>
</span><span id="line-182"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseStatement"><span class="hs-identifier">parseStatement</span></a></span><span>
</span><span id="line-183"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseStatements"><span class="hs-identifier">parseStatements</span></a></span><span>
</span><span id="line-184"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier">ParseError</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Identity</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Identity</span></span><span class="hs-special">)</span><span>
</span><span id="line-187"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">guard</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-188"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&lt;**&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Char</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">toLower</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isDigit</span></span><span class="hs-special">)</span><span>
</span><span id="line-190"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">setPosition</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">setSourceColumn</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">setSourceLine</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">getPosition</span></span><span>
</span><span id="line-191"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">option</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">between</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">sepBy</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">sepBy1</span></span><span>
</span><span id="line-192"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">try</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">many1</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">choice</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">eof</span></span><span>
</span><span id="line-193"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">optionMaybe</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">optional</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">runParser</span></span><span>
</span><span id="line-194"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">chainl1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">chainr1</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-operator">(&lt;?&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec.Perm</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">permute</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-operator">(&lt;$?&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|?&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec.Prim</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">getState</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">token</span></span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec.Pos</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">newPos</span></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec.Expr</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">E</span></span><span>
</span><span id="line-199"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">intercalate</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">sort</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier">groupBy</span></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">on</span></span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-202"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Parsec.String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">GenParser</span></span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html"><span class="hs-identifier">Language.SQL.SimpleSQL.Syntax</span></a></span><span>
</span><span id="line-205"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Combinators.html"><span class="hs-identifier">Language.SQL.SimpleSQL.Combinators</span></a></span><span>
</span><span id="line-206"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html"><span class="hs-identifier">Language.SQL.SimpleSQL.Errors</span></a></span><span>
</span><span id="line-207"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html"><span class="hs-identifier">Language.SQL.SimpleSQL.Dialect</span></a></span><span>
</span><span id="line-208"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html"><span class="hs-identifier">Language.SQL.SimpleSQL.Lex</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Public</span><span> </span><span class="hs-identifier">API</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- | Parses a query expr, trailing semicolon optional.</span><span>
</span><span id="line-214"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseQueryExpr"><span class="hs-identifier hs-type">parseQueryExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-215"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ dialect of SQL to use</span><span>
</span><span id="line-216"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-217"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ filename to use in error messages</span><span>
</span><span id="line-218"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-219"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ line number and column number of the first character</span><span>
</span><span id="line-220"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- in the source to use in error messages</span><span>
</span><span id="line-221"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-222"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ the SQL source to parse</span><span>
</span><span id="line-223"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span>
</span><span id="line-224"></span><span class="hs-operator">&gt;</span><span> </span><span id="parseQueryExpr"><span class="annot"><span class="annottext">parseQueryExpr :: Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parseQueryExpr"><span class="hs-identifier hs-var hs-var">parseQueryExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError QueryExpr
forall a.
Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError a
</span><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-var">wrapParse</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#topLevelQueryExpr"><span class="hs-identifier hs-var">topLevelQueryExpr</span></a></span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- | Parses a statement, trailing semicolon optional.</span><span>
</span><span id="line-227"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseStatement"><span class="hs-identifier hs-type">parseStatement</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-228"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ dialect of SQL to use</span><span>
</span><span id="line-229"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-230"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ filename to use in error messages</span><span>
</span><span id="line-231"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ line number and column number of the first character</span><span>
</span><span id="line-233"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- in the source to use in error messages</span><span>
</span><span id="line-234"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-235"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ the SQL source to parse</span><span>
</span><span id="line-236"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-237"></span><span class="hs-operator">&gt;</span><span> </span><span id="parseStatement"><span class="annot"><span class="annottext">parseStatement :: Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#parseStatement"><span class="hs-identifier hs-var hs-var">parseStatement</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser Statement
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError Statement
forall a.
Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError a
</span><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-var">wrapParse</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#topLevelStatement"><span class="hs-identifier hs-var">topLevelStatement</span></a></span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span>
</span><span id="line-240"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- | Parses a list of statements, with semi colons between</span><span>
</span><span id="line-241"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- them. The final semicolon is optional.</span><span>
</span><span id="line-242"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseStatements"><span class="hs-identifier hs-type">parseStatements</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-243"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-comment">-- ^ dialect of SQL to use</span><span>
</span><span id="line-244"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-245"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ filename to use in error messages</span><span>
</span><span id="line-246"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-247"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ line number and column number of the first character</span><span>
</span><span id="line-248"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- in the source to use in error messages</span><span>
</span><span id="line-249"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-250"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ the SQL source to parse</span><span>
</span><span id="line-251"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-252"></span><span class="hs-operator">&gt;</span><span> </span><span id="parseStatements"><span class="annot"><span class="annottext">parseStatements :: Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError [Statement]
</span><a href="Language.SQL.SimpleSQL.Parse.html#parseStatements"><span class="hs-identifier hs-var hs-var">parseStatements</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Statement]
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError [Statement]
forall a.
Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError a
</span><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-var">wrapParse</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Statement]
</span><a href="Language.SQL.SimpleSQL.Parse.html#statements"><span class="hs-identifier hs-var">statements</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">-- | Parses a scalar expression.</span><span>
</span><span id="line-255"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parseScalarExpr"><span class="hs-identifier hs-type">parseScalarExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-256"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ dialect of SQL to use</span><span>
</span><span id="line-257"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-258"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ filename to use in error messages</span><span>
</span><span id="line-259"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ line number and column number of the first character</span><span>
</span><span id="line-261"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- in the source to use in error messages</span><span>
</span><span id="line-262"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-263"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-comment">-- ^ the SQL source to parse</span><span>
</span><span id="line-264"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-265"></span><span class="hs-operator">&gt;</span><span> </span><span id="parseScalarExpr"><span class="annot"><span class="annottext">parseScalarExpr :: Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parseScalarExpr"><span class="hs-identifier hs-var hs-var">parseScalarExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError ScalarExpr
forall a.
Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError a
</span><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-var">wrapParse</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-266"></span><span>
</span><span id="line-267"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">helper</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">takes</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">given</span><span> </span><span class="hs-identifier">and</span><span class="hs-glyph">:</span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="hs-identifier">sets</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">position</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">parsing</span><span>
</span><span id="line-270"></span><span class="hs-identifier">automatically</span><span> </span><span class="hs-identifier">skips</span><span> </span><span class="hs-identifier">leading</span><span> </span><span class="hs-identifier">whitespace</span><span>
</span><span id="line-271"></span><span class="hs-identifier">checks</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">parses</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">input</span><span> </span><span class="hs-identifier">using</span><span> </span><span class="hs-identifier">eof</span><span>
</span><span id="line-272"></span><span class="hs-identifier">converts</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">nice</span><span> </span><span class="hs-identifier">wrapper</span><span>
</span><span id="line-273"></span><span>
</span><span id="line-274"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679121225"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-type">wrapParse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679121225"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-275"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-276"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FilePath</span></span><span>
</span><span id="line-277"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span>
</span><span id="line-278"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-279"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Errors.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679121225"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-280"></span><span class="hs-operator">&gt;</span><span> </span><span id="wrapParse"><span class="annot"><span class="annottext">wrapParse :: Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError a
</span><a href="Language.SQL.SimpleSQL.Parse.html#wrapParse"><span class="hs-identifier hs-var hs-var">wrapParse</span></a></span></span><span> </span><span id="local-6989586621679120851"><span class="annot"><span class="annottext">parser :: Parser a
</span><a href="#local-6989586621679120851"><span class="hs-identifier hs-var">parser</span></a></span></span><span> </span><span id="local-6989586621679120850"><span class="annot"><span class="annottext">d :: Dialect
</span><a href="#local-6989586621679120850"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679120849"><span class="annot"><span class="annottext">f :: FilePath
</span><a href="#local-6989586621679120849"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679120848"><span class="annot"><span class="annottext">p :: Maybe (Int, Int)
</span><a href="#local-6989586621679120848"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679120847"><span class="annot"><span class="annottext">src :: FilePath
</span><a href="#local-6989586621679120847"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-281"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120846"><span class="annot"><span class="annottext">l :: Int
</span><a href="#local-6989586621679120846"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120845"><span class="annot"><span class="annottext">c :: Int
</span><a href="#local-6989586621679120845"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int, Int) -&gt; Maybe (Int, Int) -&gt; (Int, Int)
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (Int, Int)
</span><a href="#local-6989586621679120848"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-282"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120843"><span class="annot"><span class="annottext">[((FilePath, Int, Int), Token)]
</span><a href="#local-6989586621679120843"><span class="hs-identifier hs-var">lx</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dialect
-&gt; FilePath
-&gt; Maybe (Int, Int)
-&gt; FilePath
-&gt; Either ParseError [((FilePath, Int, Int), Token)]
</span><a href="Language.SQL.SimpleSQL.Lex.html#lexSQL"><span class="hs-identifier hs-var">L.lexSQL</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120850"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120849"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int, Int) -&gt; Maybe (Int, Int)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120846"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120845"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120847"><span class="hs-identifier hs-var">src</span></a></span><span>
</span><span id="line-283"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(ParseError -&gt; Either ParseError a)
-&gt; (a -&gt; Either ParseError a)
-&gt; Either ParseError a
-&gt; Either ParseError a
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParseError -&gt; Either ParseError a
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">(ParseError -&gt; Either ParseError a)
-&gt; (ParseError -&gt; ParseError) -&gt; ParseError -&gt; Either ParseError a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; ParseError -&gt; ParseError
</span><a href="Language.SQL.SimpleSQL.Errors.html#convParseError"><span class="hs-identifier hs-var">convParseError</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120847"><span class="hs-identifier hs-var">src</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either ParseError a
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span>
</span><span id="line-284"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><span class="annottext">(Either ParseError a -&gt; Either ParseError a)
-&gt; Either ParseError a -&gt; Either ParseError a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser a
-&gt; Dialect
-&gt; FilePath
-&gt; [((FilePath, Int, Int), Token)]
-&gt; Either ParseError a
forall s t u a.
Stream s Identity t =&gt;
Parsec s u a -&gt; u -&gt; FilePath -&gt; s -&gt; Either ParseError a
</span><span class="hs-identifier hs-var">runParser</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Int, Int)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (m :: * -&gt; *) s u.
Monad m =&gt;
Maybe (Int, Int) -&gt; ParsecT s u m ()
</span><a href="#local-6989586621679120838"><span class="hs-identifier hs-var">setPos</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (Int, Int)
</span><a href="#local-6989586621679120848"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser a -&gt; Parser a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser a
</span><a href="#local-6989586621679120851"><span class="hs-identifier hs-var">parser</span></a></span><span> </span><span class="annot"><span class="annottext">Parser a
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u.
(Stream s m t, Show t) =&gt;
ParsecT s u m ()
</span><span class="hs-identifier hs-var">eof</span></span><span class="hs-special">)</span><span>
</span><span id="line-285"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120850"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120849"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">([((FilePath, Int, Int), Token)] -&gt; Either ParseError a)
-&gt; [((FilePath, Int, Int), Token)] -&gt; Either ParseError a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(((FilePath, Int, Int), Token) -&gt; Bool)
-&gt; [((FilePath, Int, Int), Token)]
-&gt; [((FilePath, Int, Int), Token)]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">((FilePath, Int, Int), Token) -&gt; Bool
forall a. (a, Token) -&gt; Bool
</span><a href="#local-6989586621679120836"><span class="hs-identifier hs-var">keep</span></a></span><span> </span><span class="annot"><span class="annottext">[((FilePath, Int, Int), Token)]
</span><a href="#local-6989586621679120843"><span class="hs-identifier hs-var">lx</span></a></span><span>
</span><span id="line-286"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-287"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120838"><span class="annot"><span class="annottext">setPos :: Maybe (Int, Int) -&gt; ParsecT s u m ()
</span><a href="#local-6989586621679120838"><span class="hs-identifier hs-var hs-var">setPos</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; ParsecT s u m ()
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120838"><span class="hs-identifier hs-var">setPos</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120835"><span class="annot"><span class="annottext">l :: Int
</span><a href="#local-6989586621679120835"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120834"><span class="annot"><span class="annottext">c :: Int
</span><a href="#local-6989586621679120834"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(SourcePos -&gt; SourcePos)
-&gt; ParsecT s u m SourcePos -&gt; ParsecT s u m SourcePos
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">SourcePos -&gt; SourcePos
</span><a href="#local-6989586621679120833"><span class="hs-identifier hs-var">up</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m SourcePos
forall (m :: * -&gt; *) s u. Monad m =&gt; ParsecT s u m SourcePos
</span><span class="hs-identifier hs-var">getPosition</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m SourcePos
-&gt; (SourcePos -&gt; ParsecT s u m ()) -&gt; ParsecT s u m ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">SourcePos -&gt; ParsecT s u m ()
forall (m :: * -&gt; *) s u. Monad m =&gt; SourcePos -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">setPosition</span></span><span>
</span><span id="line-289"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679120833"><span class="annot"><span class="annottext">up :: SourcePos -&gt; SourcePos
</span><a href="#local-6989586621679120833"><span class="hs-identifier hs-var hs-var">up</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(SourcePos -&gt; Int -&gt; SourcePos) -&gt; Int -&gt; SourcePos -&gt; SourcePos
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">SourcePos -&gt; Int -&gt; SourcePos
</span><span class="hs-identifier hs-var">setSourceColumn</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120834"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">(SourcePos -&gt; SourcePos)
-&gt; (SourcePos -&gt; SourcePos) -&gt; SourcePos -&gt; SourcePos
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(SourcePos -&gt; Int -&gt; SourcePos) -&gt; Int -&gt; SourcePos -&gt; SourcePos
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">SourcePos -&gt; Int -&gt; SourcePos
</span><span class="hs-identifier hs-var">setSourceLine</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120835"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-290"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120836"><span class="annot"><span class="annottext">keep :: (a, Token) -&gt; Bool
</span><a href="#local-6989586621679120836"><span class="hs-identifier hs-var hs-var">keep</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Whitespace"><span class="hs-identifier hs-type">L.Whitespace</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-291"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120836"><span class="hs-identifier hs-var">keep</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#LineComment"><span class="hs-identifier hs-type">L.LineComment</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-292"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120836"><span class="hs-identifier hs-var">keep</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#BlockComment"><span class="hs-identifier hs-type">L.BlockComment</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-293"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120836"><span class="hs-identifier hs-var">keep</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span class="hs-comment">------------------------------------------------</span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Names</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span class="hs-identifier">Names</span><span> </span><span class="hs-identifier">represent</span><span> </span><span class="hs-identifier">identifiers</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">few</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">things</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">here</span><span>
</span><span id="line-301"></span><span class="hs-identifier">handles</span><span> </span><span class="hs-identifier">regular</span><span> </span><span class="hs-identifier">identifiers</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">dotten</span><span> </span><span class="hs-identifier">chain</span><span> </span><span class="hs-identifier">identifiers</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">quoted</span><span>
</span><span id="line-302"></span><span class="hs-identifier">identifiers</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">unicode</span><span> </span><span class="hs-identifier">quoted</span><span> </span><span class="hs-identifier">identifiers</span><span class="hs-operator">.</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="hs-identifier">Dots</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">dots</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">chains</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">parsed</span><span> </span><span class="hs-identifier">here</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">represented</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-305"></span><span class="hs-identifier">Iden</span><span> </span><span class="hs-identifier">constructor</span><span> </span><span class="hs-identifier">usually</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">If</span><span> </span><span class="hs-identifier">parts</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">chains</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">non</span><span> </span><span class="hs-identifier">identifier</span><span>
</span><span id="line-306"></span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span class="hs-special">,</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">represented</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">BinOp</span><span> </span><span class="hs-string">&quot;.&quot;</span><span>
</span><span id="line-307"></span><span class="hs-identifier">instead</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Dotten</span><span> </span><span class="hs-identifier">chain</span><span> </span><span class="hs-identifier">identifiers</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">appear</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">contexts</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">such</span><span>
</span><span id="line-308"></span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">names</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">table</span><span> </span><span class="hs-identifier">names</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">represented</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Name</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">only</span><span class="hs-operator">.</span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span class="hs-identifier">Identifier</span><span> </span><span class="hs-identifier">grammar</span><span class="hs-glyph">:</span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="hs-identifier">unquoted</span><span class="hs-glyph">:</span><span>
</span><span id="line-313"></span><span class="hs-identifier">underscore</span><span> </span><span class="hs-operator">&lt;|&gt;</span><span> </span><span class="hs-identifier">letter</span><span> </span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">underscore</span><span> </span><span class="hs-operator">&lt;|&gt;</span><span> </span><span class="hs-identifier">alphanum</span><span>
</span><span id="line-314"></span><span>
</span><span id="line-315"></span><span class="hs-identifier">example</span><span>
</span><span id="line-316"></span><span class="hs-identifier">_example123</span><span>
</span><span id="line-317"></span><span>
</span><span id="line-318"></span><span class="hs-identifier">quoted</span><span class="hs-glyph">:</span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="hs-identifier">double</span><span> </span><span class="hs-identifier">quote</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">non</span><span> </span><span class="hs-identifier">quote</span><span> </span><span class="hs-identifier">character</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">two</span><span> </span><span class="hs-identifier">double</span><span> </span><span class="hs-identifier">quotes</span><span>
</span><span id="line-321"></span><span class="hs-identifier">together</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">double</span><span> </span><span class="hs-identifier">quote</span><span>
</span><span id="line-322"></span><span>
</span><span id="line-323"></span><span class="hs-string">&quot;example quoted&quot;</span><span>
</span><span id="line-324"></span><span class="hs-string">&quot;example with &quot;</span><span class="hs-string">&quot; quote&quot;</span><span>
</span><span id="line-325"></span><span>
</span><span id="line-326"></span><span class="hs-identifier">unicode</span><span> </span><span class="hs-identifier">quoted</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">same</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">quoted</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">parser</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">except</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">starts</span><span>
</span><span id="line-327"></span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">U</span><span class="hs-operator">&amp;</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">u</span><span class="hs-operator">&amp;</span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="hs-identifier">u</span><span class="hs-operator">&amp;</span><span class="hs-string">&quot;example quoted&quot;</span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-332"></span><span class="hs-operator">&gt;</span><span> </span><span id="name"><span class="annot"><span class="annottext">name :: Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-333"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120827"><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120827"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Dialect
forall (m :: * -&gt; *) s u. Monad m =&gt; ParsecT s u m u
</span><span class="hs-identifier hs-var">getState</span></span><span>
</span><span id="line-334"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name)
-&gt; (Maybe (FilePath, FilePath), FilePath) -&gt; Name
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">((Maybe (FilePath, FilePath), FilePath) -&gt; Name)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, FilePath), FilePath)
-&gt; Parser Name
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, FilePath), FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#identifierTok"><span class="hs-identifier hs-var">identifierTok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#blacklist"><span class="hs-identifier hs-var">blacklist</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120827"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>
</span><span id="line-336"></span><span class="hs-identifier">todo</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">replace</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">named</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">over</span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-type">names</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-339"></span><span class="hs-operator">&gt;</span><span> </span><span id="names"><span class="annot"><span class="annottext">names :: Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var hs-var">names</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; [Name]) -&gt; Parser Name -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
-&gt; Parser [Name]
forall t s a.
GenParser t s a -&gt; GenParser t s (a -&gt; a) -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%3F%3F%2A%3E"><span class="hs-operator hs-var">&lt;??*&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenParser ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
</span><a href="#local-6989586621679120818"><span class="hs-identifier hs-var">anotherName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-comment">-- can't use a simple chain here since we</span><span>
</span><span id="line-341"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-comment">-- want to wrap the . + name in a try</span><span>
</span><span id="line-342"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-comment">-- this will change when this is left factored</span><span>
</span><span id="line-343"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-344"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120818"><span class="hs-identifier hs-type">anotherName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-345"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120818"><span class="annot"><span class="annottext">anotherName :: GenParser ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
</span><a href="#local-6989586621679120818"><span class="hs-identifier hs-var hs-var">anotherName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenParser ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; [Name] -&gt; [Name])
-&gt; Parser Name
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect ([Name] -&gt; [Name])
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-346"></span><span>
</span><span id="line-347"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-identifier">Names</span><span>
</span><span id="line-348"></span><span>
</span><span id="line-349"></span><span class="hs-identifier">Typenames</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">casts</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-special">,</span><span>
</span><span id="line-350"></span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">followed</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">string</span><span> </span><span class="hs-identifier">literal</span><span class="hs-operator">.</span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span class="hs-identifier">Here</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">grammar</span><span> </span><span class="hs-identifier">notes</span><span class="hs-glyph">:</span><span>
</span><span id="line-353"></span><span>
</span><span id="line-354"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-355"></span><span>
</span><span id="line-356"></span><span class="hs-identifier">just</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">chain</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">multi</span><span> </span><span class="hs-identifier">word</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">fixed</span><span>
</span><span id="line-357"></span><span class="hs-identifier">list</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">possibilities</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">character</span><span> </span><span class="hs-identifier">varying'</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">see</span><span> </span><span class="hs-identifier">below</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-358"></span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">exact</span><span> </span><span class="hs-identifier">list</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-359"></span><span>
</span><span id="line-360"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">simple</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">identifier</span><span class="hs-glyph">-</span><span class="hs-identifier">chain</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-361"></span><span>     </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">multiword</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">identifier</span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Precision</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-364"></span><span>
</span><span id="line-365"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">precision</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">simple</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span class="hs-glyph">-</span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-366"></span><span>
</span><span id="line-367"></span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">char</span><span class="hs-special">(</span><span class="hs-number">5</span><span class="hs-special">)</span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span class="hs-identifier">note</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">above</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">below</span><span> </span><span class="hs-identifier">every</span><span> </span><span class="hs-keyword">where</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">appear</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">this</span><span>
</span><span id="line-370"></span><span class="hs-identifier">means</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">single</span><span> </span><span class="hs-identifier">identifier</span><span class="hs-operator">/</span><span class="hs-identifier">quoted</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">dotted</span><span> </span><span class="hs-identifier">chain</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">multi</span><span> </span><span class="hs-identifier">word</span><span>
</span><span id="line-371"></span><span class="hs-identifier">identifier</span><span>
</span><span id="line-372"></span><span>
</span><span id="line-373"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Precision</span><span> </span><span class="hs-identifier">scale</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">precision</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">simple</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span class="hs-glyph">-</span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">comma</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span class="hs-glyph">-</span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">decimal</span><span class="hs-special">(</span><span class="hs-number">15</span><span class="hs-special">,</span><span class="hs-number">2</span><span class="hs-special">)</span><span>
</span><span id="line-378"></span><span>
</span><span id="line-379"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">Lob</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-380"></span><span>
</span><span id="line-381"></span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">variation</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">extra</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-identifier">on</span><span>
</span><span id="line-382"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">units</span><span class="hs-glyph">:</span><span>
</span><span id="line-383"></span><span>
</span><span id="line-384"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">lob</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span>
</span><span id="line-385"></span><span>   </span><span class="hs-operator">&lt;</span><span class="hs-identifier">simple</span><span class="hs-glyph">-</span><span class="hs-keyword">type</span><span class="hs-glyph">-</span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span> </span><span class="hs-identifier">integer</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">multiplier</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">char</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">units</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-386"></span><span>
</span><span id="line-387"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">multiplier</span><span class="hs-operator">&gt;</span><span>    </span><span class="hs-operator">::=</span><span>   </span><span class="hs-identifier">K</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">M</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">G</span><span>
</span><span id="line-388"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">char</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">units</span><span class="hs-operator">&gt;</span><span>    </span><span class="hs-operator">::=</span><span>   </span><span class="hs-identifier">CHARACTERS</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">CODE_UNITS</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">OCTETS</span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">both</span><span> </span><span class="hs-identifier">multiplier</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">char</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">units</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">missing</span><span class="hs-special">,</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">will</span><span>
</span><span id="line-391"></span><span class="hs-identifier">parse</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-special">)</span><span>
</span><span id="line-392"></span><span>
</span><span id="line-393"></span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span>
</span><span id="line-394"></span><span class="hs-identifier">clob</span><span class="hs-special">(</span><span class="hs-number">5</span><span class="hs-identifier">M</span><span> </span><span class="hs-identifier">octets</span><span class="hs-special">)</span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">char</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-397"></span><span>
</span><span id="line-398"></span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">allows</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-399"></span><span class="hs-identifier">character</span><span> </span><span class="hs-identifier">set</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">collation</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">appear</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">suffix</span><span class="hs-glyph">:</span><span>
</span><span id="line-400"></span><span>
</span><span id="line-401"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">char</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span>
</span><span id="line-402"></span><span>    </span><span class="hs-operator">&lt;</span><span class="hs-identifier">simple</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-403"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span class="hs-glyph">-</span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-404"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="hs-identifier">CHARACTER</span><span> </span><span class="hs-identifier">SET</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">chain</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-405"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="hs-identifier">COLLATE</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">chain</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-406"></span><span>
</span><span id="line-407"></span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span class="hs-identifier">char</span><span class="hs-special">(</span><span class="hs-number">5</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">character</span><span> </span><span class="hs-identifier">set</span><span> </span><span class="hs-identifier">my_charset</span><span> </span><span class="hs-identifier">collate</span><span> </span><span class="hs-identifier">my_collation</span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Time</span><span> </span><span class="hs-identifier">typename</span><span>
</span><span id="line-412"></span><span>
</span><span id="line-413"></span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">either</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">time</span><span> </span><span class="hs-identifier">zone'</span><span>
</span><span id="line-414"></span><span class="hs-identifier">or</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">without</span><span> </span><span class="hs-identifier">time</span><span> </span><span class="hs-identifier">zone'</span><span> </span><span class="hs-identifier">suffix</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.:</span><span>
</span><span id="line-415"></span><span>
</span><span id="line-416"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">datetime</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span>
</span><span id="line-417"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span class="hs-glyph">-</span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-418"></span><span>    </span><span class="hs-operator">&lt;</span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">without</span><span> </span><span class="hs-identifier">time</span><span> </span><span class="hs-identifier">zone</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-419"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">without</span><span> </span><span class="hs-identifier">time</span><span> </span><span class="hs-identifier">zone</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-identifier">WITH</span><span> </span><span class="hs-identifier">TIME</span><span> </span><span class="hs-identifier">ZONE</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">WITHOUT</span><span> </span><span class="hs-identifier">TIME</span><span> </span><span class="hs-identifier">ZONE</span><span>
</span><span id="line-420"></span><span>    </span><span class="hs-identifier">WITH</span><span> </span><span class="hs-identifier">TIME</span><span> </span><span class="hs-identifier">ZONE</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">WITHOUT</span><span> </span><span class="hs-identifier">TIME</span><span> </span><span class="hs-identifier">ZONE</span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">row</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-423"></span><span>
</span><span id="line-424"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">row</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span>
</span><span id="line-425"></span><span>    </span><span class="hs-identifier">ROW</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">field</span><span> </span><span class="hs-identifier">definition</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">comma</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">field</span><span> </span><span class="hs-identifier">definition</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">}</span><span class="hs-operator">...</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-426"></span><span>
</span><span id="line-427"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">field</span><span> </span><span class="hs-identifier">definition</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">identifier</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-operator">&gt;</span><span>
</span><span id="line-428"></span><span>
</span><span id="line-429"></span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span>
</span><span id="line-430"></span><span class="hs-identifier">row</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">int</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-identifier">char</span><span class="hs-special">(</span><span class="hs-number">5</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-431"></span><span>
</span><span id="line-432"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">interval</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-identifier">INTERVAL</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">TO</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span class="hs-operator">&gt;</span><span class="hs-special">]</span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-operator">&lt;</span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span> </span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">comma</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span> </span><span class="hs-identifier">int</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">paren</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-438"></span><span>
</span><span id="line-439"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">array</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">array</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">::=</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-keyword">data</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-identifier">ARRAY</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">bracket</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">unsigned</span><span> </span><span class="hs-identifier">integer</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-operator">&lt;</span><span class="hs-identifier">right</span><span> </span><span class="hs-identifier">bracket</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-442"></span><span>
</span><span id="line-443"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">multiset</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span>
</span><span id="line-444"></span><span>
</span><span id="line-445"></span><span class="hs-operator">&lt;</span><span class="hs-identifier">multiset</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span>    </span><span class="hs-operator">::=</span><span>   </span><span class="hs-operator">&lt;</span><span class="hs-keyword">data</span><span> </span><span class="hs-keyword">type</span><span class="hs-operator">&gt;</span><span> </span><span class="hs-identifier">MULTISET</span><span>
</span><span id="line-446"></span><span>
</span><span id="line-447"></span><span class="hs-identifier">A</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">into</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">smallest'</span><span> </span><span class="hs-identifier">constructor</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">fit</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-448"></span><span class="hs-identifier">syntactically</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">clob</span><span class="hs-special">(</span><span class="hs-number">5</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">precision</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">not</span><span>
</span><span id="line-449"></span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">lob</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">name</span><span class="hs-operator">.</span><span>
</span><span id="line-450"></span><span>
</span><span id="line-451"></span><span class="hs-identifier">Unfortunately</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">improve</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">lot</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">left</span><span class="hs-special">)</span><span>
</span><span id="line-452"></span><span class="hs-identifier">factoring</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">function</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">little</span><span> </span><span class="hs-identifier">dense</span><span class="hs-operator">.</span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-type">typeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#TypeName"><span class="hs-identifier hs-type">TypeName</span></a></span><span>
</span><span id="line-455"></span><span class="hs-operator">&gt;</span><span> </span><span id="typeName"><span class="annot"><span class="annottext">typeName :: Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var hs-var">typeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-456"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="#local-6989586621679120815"><span class="hs-identifier hs-var">rowTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TypeName -&gt; Parser TypeName -&gt; Parser TypeName
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="#local-6989586621679120814"><span class="hs-identifier hs-var">intervalTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TypeName -&gt; Parser TypeName -&gt; Parser TypeName
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="#local-6989586621679120813"><span class="hs-identifier hs-var">otherTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-457"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser TypeName
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
-&gt; Parser TypeName
forall t s a.
GenParser t s a -&gt; GenParser t s (a -&gt; a) -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%3F%3F%2A%3E"><span class="hs-operator hs-var">&lt;??*&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120812"><span class="hs-identifier hs-var">tnSuffix</span></a></span><span>
</span><span id="line-458"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-459"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120815"><span class="annot"><span class="annottext">rowTypeName :: Parser TypeName
</span><a href="#local-6989586621679120815"><span class="hs-identifier hs-var hs-var">rowTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-460"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[(Name, TypeName)] -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RowTypeName"><span class="hs-identifier hs-var">RowTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">([(Name, TypeName)] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
-&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;row&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser (Name, TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [(Name, TypeName)]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser (Name, TypeName)
</span><a href="#local-6989586621679120807"><span class="hs-identifier hs-var">rowField</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-461"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120807"><span class="annot"><span class="annottext">rowField :: Parser (Name, TypeName)
</span><a href="#local-6989586621679120807"><span class="hs-identifier hs-var hs-var">rowField</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; TypeName -&gt; (Name, TypeName))
-&gt; Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TypeName -&gt; (Name, TypeName))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TypeName -&gt; (Name, TypeName))
-&gt; Parser TypeName -&gt; Parser (Name, TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span>
</span><span id="line-462"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-463"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120814"><span class="annot"><span class="annottext">intervalTypeName :: Parser TypeName
</span><a href="#local-6989586621679120814"><span class="hs-identifier hs-var hs-var">intervalTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-464"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;interval&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser TypeName -&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-465"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(IntervalTypeField -&gt; Maybe IntervalTypeField -&gt; TypeName)
-&gt; (IntervalTypeField, Maybe IntervalTypeField) -&gt; TypeName
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">IntervalTypeField -&gt; Maybe IntervalTypeField -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#IntervalTypeName"><span class="hs-identifier hs-var">IntervalTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">((IntervalTypeField, Maybe IntervalTypeField) -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (IntervalTypeField, Maybe IntervalTypeField)
-&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (IntervalTypeField, Maybe IntervalTypeField)
</span><a href="Language.SQL.SimpleSQL.Parse.html#intervalQualifier"><span class="hs-identifier hs-var">intervalQualifier</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-466"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-467"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120813"><span class="annot"><span class="annottext">otherTypeName :: Parser TypeName
</span><a href="#local-6989586621679120813"><span class="hs-identifier hs-var hs-var">otherTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-468"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="#local-6989586621679120804"><span class="hs-identifier hs-var">nameOfType</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
-&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span>
</span><span id="line-469"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; TypeName)
</span><a href="#local-6989586621679120803"><span class="hs-identifier hs-var">typeNameWithParens</span></a></span><span>
</span><span id="line-470"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe Integer
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120802"><span class="hs-identifier hs-var">timeTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120801"><span class="hs-identifier hs-var">charTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-471"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TypeName"><span class="hs-identifier hs-var">TypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-472"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120804"><span class="annot"><span class="annottext">nameOfType :: Parser [Name]
</span><a href="#local-6989586621679120804"><span class="hs-identifier hs-var hs-var">nameOfType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="#local-6989586621679120799"><span class="hs-identifier hs-var">reservedTypeNames</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-473"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120801"><span class="annot"><span class="annottext">charTypeName :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120801"><span class="hs-identifier hs-var hs-var">charTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="#local-6989586621679120798"><span class="hs-identifier hs-var">charSet</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="#local-6989586621679120797"><span class="hs-identifier hs-var">tcollate</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) d a b c t.
Applicative f =&gt;
f d -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; t) -&gt; f (c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Maybe Integer -&gt; [Name] -&gt; [Name] -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CharTypeName"><span class="hs-identifier hs-var">CharTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-474"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="#local-6989586621679120797"><span class="hs-identifier hs-var">tcollate</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; Maybe Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) d a b c t.
Applicative f =&gt;
f d -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; t) -&gt; f (c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Maybe Integer -&gt; [Name] -&gt; [Name] -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CharTypeName"><span class="hs-identifier hs-var">CharTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120803"><span class="annot"><span class="annottext">typeNameWithParens :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; TypeName)
</span><a href="#local-6989586621679120803"><span class="hs-identifier hs-var hs-var">typeNameWithParens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-476"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var">openParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-477"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120791"><span class="hs-identifier hs-var">precMaybeSuffix</span></a></span><span>
</span><span id="line-478"></span><span class="hs-operator">&gt;</span><span>               </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120790"><span class="hs-identifier hs-var">precScaleTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120789"><span class="hs-identifier hs-var">precLengthTypeName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-479"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120791"><span class="annot"><span class="annottext">precMaybeSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120791"><span class="hs-identifier hs-var hs-var">precMaybeSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; (Integer -&gt; Maybe Integer) -&gt; Integer -&gt; [Name] -&gt; TypeName
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Integer -&gt; Maybe Integer
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Maybe Integer -&gt; [Name] -&gt; TypeName)
 -&gt; Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120802"><span class="hs-identifier hs-var">timeTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120801"><span class="hs-identifier hs-var">charTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-480"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Name] -&gt; Integer -&gt; TypeName) -&gt; Integer -&gt; [Name] -&gt; TypeName
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Integer -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecTypeName"><span class="hs-identifier hs-var">PrecTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-481"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120790"><span class="annot"><span class="annottext">precScaleTypeName :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120790"><span class="hs-identifier hs-var hs-var">precScaleTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ([Name] -&gt; Integer -&gt; Integer -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) c a b t.
Applicative f =&gt;
f c -&gt; (a -&gt; b -&gt; c -&gt; t) -&gt; f (b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Integer -&gt; Integer -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecScaleTypeName"><span class="hs-identifier hs-var">PrecScaleTypeName</span></a></span><span>
</span><span id="line-482"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120789"><span class="annot"><span class="annottext">precLengthTypeName :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120789"><span class="hs-identifier hs-var hs-var">precLengthTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-483"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">PrecMultiplier -&gt; Maybe PrecMultiplier
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(PrecMultiplier -&gt; Maybe PrecMultiplier)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
</span><a href="#local-6989586621679120784"><span class="hs-identifier hs-var">lobPrecSuffix</span></a></span><span>
</span><span id="line-484"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe PrecMultiplier)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier -&gt; Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe PrecUnits)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
</span><a href="#local-6989586621679120783"><span class="hs-identifier hs-var">lobUnits</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe PrecUnits)
-&gt; ([Name]
    -&gt; Integer -&gt; Maybe PrecMultiplier -&gt; Maybe PrecUnits -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier -&gt; Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) d a b c t.
Applicative f =&gt;
f d -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; t) -&gt; f (c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; Integer -&gt; Maybe PrecMultiplier -&gt; Maybe PrecUnits -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecLengthTypeName"><span class="hs-identifier hs-var">PrecLengthTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-485"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe PrecMultiplier
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe PrecMultiplier)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier -&gt; Integer -&gt; [Name] -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">PrecUnits -&gt; Maybe PrecUnits
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(PrecUnits -&gt; Maybe PrecUnits)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe PrecUnits)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
</span><a href="#local-6989586621679120783"><span class="hs-identifier hs-var">lobUnits</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe PrecUnits)
-&gt; ([Name]
    -&gt; Integer -&gt; Maybe PrecMultiplier -&gt; Maybe PrecUnits -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe PrecMultiplier -&gt; Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) d a b c t.
Applicative f =&gt;
f d -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; t) -&gt; f (c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; Integer -&gt; Maybe PrecMultiplier -&gt; Maybe PrecUnits -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecLengthTypeName"><span class="hs-identifier hs-var">PrecLengthTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-486"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120802"><span class="annot"><span class="annottext">timeTypeName :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; [Name] -&gt; TypeName)
</span><a href="#local-6989586621679120802"><span class="hs-identifier hs-var hs-var">timeTypeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
</span><a href="#local-6989586621679120781"><span class="hs-identifier hs-var">tz</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ([Name] -&gt; Maybe Integer -&gt; Bool -&gt; TypeName)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; [Name] -&gt; TypeName)
forall (f :: * -&gt; *) c a b t.
Applicative f =&gt;
f c -&gt; (a -&gt; b -&gt; c -&gt; t) -&gt; f (b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Maybe Integer -&gt; Bool -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TimeTypeName"><span class="hs-identifier hs-var">TimeTypeName</span></a></span><span>
</span><span id="line-487"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-488"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120784"><span class="annot"><span class="annottext">lobPrecSuffix :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
</span><a href="#local-6989586621679120784"><span class="hs-identifier hs-var hs-var">lobPrecSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecK"><span class="hs-identifier hs-var">PrecK</span></a></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;k&quot;</span></span><span>
</span><span id="line-489"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecM"><span class="hs-identifier hs-var">PrecM</span></a></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;m&quot;</span></span><span>
</span><span id="line-490"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecG"><span class="hs-identifier hs-var">PrecG</span></a></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;g&quot;</span></span><span>
</span><span id="line-491"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecT"><span class="hs-identifier hs-var">PrecT</span></a></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;t&quot;</span></span><span>
</span><span id="line-492"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecP"><span class="hs-identifier hs-var">PrecP</span></a></span><span> </span><span class="annot"><span class="annottext">PrecMultiplier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecMultiplier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;p&quot;</span></span><span>
</span><span id="line-493"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120783"><span class="annot"><span class="annottext">lobUnits :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
</span><a href="#local-6989586621679120783"><span class="hs-identifier hs-var hs-var">lobUnits</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PrecUnits
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecCharacters"><span class="hs-identifier hs-var">PrecCharacters</span></a></span><span> </span><span class="annot"><span class="annottext">PrecUnits
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;characters&quot;</span></span><span>
</span><span id="line-494"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-comment">-- char and byte are the oracle spelling</span><span>
</span><span id="line-495"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-comment">-- todo: move these to oracle dialect</span><span>
</span><span id="line-496"></span><span class="hs-operator">&gt;</span><span>                </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecUnits
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecCharacters"><span class="hs-identifier hs-var">PrecCharacters</span></a></span><span> </span><span class="annot"><span class="annottext">PrecUnits
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;char&quot;</span></span><span>
</span><span id="line-497"></span><span class="hs-operator">&gt;</span><span>                </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecUnits
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecOctets"><span class="hs-identifier hs-var">PrecOctets</span></a></span><span> </span><span class="annot"><span class="annottext">PrecUnits
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;octets&quot;</span></span><span>
</span><span id="line-498"></span><span class="hs-operator">&gt;</span><span>                </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">PrecUnits
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrecOctets"><span class="hs-identifier hs-var">PrecOctets</span></a></span><span> </span><span class="annot"><span class="annottext">PrecUnits
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrecUnits
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;byte&quot;</span></span><span>
</span><span id="line-499"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120781"><span class="annot"><span class="annottext">tz :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
</span><a href="#local-6989586621679120781"><span class="hs-identifier hs-var hs-var">tz</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;time&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;zone&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-500"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;without&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;time&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;zone&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-501"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120798"><span class="annot"><span class="annottext">charSet :: Parser [Name]
</span><a href="#local-6989586621679120798"><span class="hs-identifier hs-var hs-var">charSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;character&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-502"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120797"><span class="annot"><span class="annottext">tcollate :: Parser [Name]
</span><a href="#local-6989586621679120797"><span class="hs-identifier hs-var hs-var">tcollate</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;collate&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-503"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-504"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120812"><span class="annot"><span class="annottext">tnSuffix :: GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120812"><span class="hs-identifier hs-var hs-var">tnSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120770"><span class="hs-identifier hs-var">multiset</span></a></span><span> </span><span class="annot"><span class="annottext">GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120769"><span class="hs-identifier hs-var">array</span></a></span><span>
</span><span id="line-505"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120770"><span class="annot"><span class="annottext">multiset :: GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120770"><span class="hs-identifier hs-var hs-var">multiset</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TypeName -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MultisetTypeName"><span class="hs-identifier hs-var">MultisetTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeName -&gt; TypeName)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;multiset&quot;</span></span><span>
</span><span id="line-506"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120769"><span class="annot"><span class="annottext">array :: GenParser
  ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
</span><a href="#local-6989586621679120769"><span class="hs-identifier hs-var hs-var">array</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;array&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-507"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
-&gt; (TypeName -&gt; Maybe Integer -&gt; TypeName)
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TypeName -&gt; TypeName)
forall (f :: * -&gt; *) b a c.
Applicative f =&gt;
f b -&gt; (a -&gt; b -&gt; c) -&gt; f (a -&gt; c)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%3E"><span class="hs-operator hs-var">&lt;$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TypeName -&gt; Maybe Integer -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ArrayTypeName"><span class="hs-identifier hs-var">ArrayTypeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-508"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-509"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- this parser handles the fixed set of multi word</span><span>
</span><span id="line-510"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- type names, plus all the type names which are</span><span>
</span><span id="line-511"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- reserved words</span><span>
</span><span id="line-512"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120799"><span class="annot"><span class="annottext">reservedTypeNames :: Parser [Name]
</span><a href="#local-6989586621679120799"><span class="hs-identifier hs-var hs-var">reservedTypeNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-513"></span><span class="hs-operator">&gt;</span><span>         </span><span id="local-6989586621679120764"><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120764"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Dialect
forall (m :: * -&gt; *) s u. Monad m =&gt; ParsecT s u m u
</span><span class="hs-identifier hs-var">getState</span></span><span>
</span><span id="line-514"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; [Name]) -&gt; ([FilePath] -&gt; Name) -&gt; [FilePath] -&gt; [Name]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name)
-&gt; ([FilePath] -&gt; FilePath) -&gt; [FilePath] -&gt; Name
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; FilePath
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="annot"><span class="annottext">([FilePath] -&gt; [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diSpecialTypeNames"><span class="hs-identifier hs-var hs-var">diSpecialTypeNames</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120764"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-515"></span><span class="hs-operator">&gt;</span><span>         </span><span>
</span><span id="line-516"></span><span>
</span><span id="line-517"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Scalar</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-518"></span><span>
</span><span id="line-519"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">literals</span><span>
</span><span id="line-520"></span><span>
</span><span id="line-521"></span><span class="hs-identifier">See</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">stringToken</span><span> </span><span class="hs-identifier">lexer</span><span> </span><span class="hs-identifier">below</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">notes</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">string</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-operator">.</span><span>
</span><span id="line-522"></span><span>
</span><span id="line-523"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#stringLit"><span class="hs-identifier hs-type">stringLit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-524"></span><span class="hs-operator">&gt;</span><span> </span><span id="stringLit"><span class="annot"><span class="annottext">stringLit :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringLit"><span class="hs-identifier hs-var hs-var">stringLit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679120759"><span class="annot"><span class="annottext">s :: FilePath
</span><a href="#local-6989586621679120759"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120758"><span class="annot"><span class="annottext">e :: FilePath
</span><a href="#local-6989586621679120758"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120757"><span class="annot"><span class="annottext">t :: FilePath
</span><a href="#local-6989586621679120757"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#StringLit"><span class="hs-identifier hs-var">StringLit</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120759"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120758"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120757"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((FilePath, FilePath, FilePath) -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath, FilePath, FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringTokExtend"><span class="hs-identifier hs-var">stringTokExtend</span></a></span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#numberLit"><span class="hs-identifier hs-type">numberLit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-527"></span><span class="hs-operator">&gt;</span><span> </span><span id="numberLit"><span class="annot"><span class="annottext">numberLit :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#numberLit"><span class="hs-identifier hs-var hs-var">numberLit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NumLit"><span class="hs-identifier hs-var">NumLit</span></a></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; ScalarExpr) -&gt; Parser FilePath -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#sqlNumberTok"><span class="hs-identifier hs-var">sqlNumberTok</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-528"></span><span>
</span><span id="line-529"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#simpleLiteral"><span class="hs-identifier hs-type">simpleLiteral</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-530"></span><span class="hs-operator">&gt;</span><span> </span><span id="simpleLiteral"><span class="annot"><span class="annottext">simpleLiteral :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#simpleLiteral"><span class="hs-identifier hs-var hs-var">simpleLiteral</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#numberLit"><span class="hs-identifier hs-var">numberLit</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringLit"><span class="hs-identifier hs-var">stringLit</span></a></span><span>
</span><span id="line-531"></span><span>
</span><span id="line-532"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">star</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">param</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">host</span><span> </span><span class="hs-identifier">param</span><span>
</span><span id="line-533"></span><span>
</span><span id="line-534"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">star</span><span>
</span><span id="line-535"></span><span>
</span><span id="line-536"></span><span class="hs-identifier">used</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-operator">*</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">x</span><span class="hs-operator">.*</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">agg</span><span class="hs-special">(</span><span class="hs-operator">*</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">variations</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">other</span><span>
</span><span id="line-537"></span><span class="hs-identifier">places</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">well</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">doesn't</span><span> </span><span class="hs-identifier">attempt</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">check</span><span> </span><span class="hs-identifier">that</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">star</span><span> </span><span class="hs-identifier">is</span><span>
</span><span id="line-538"></span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">valid</span><span> </span><span class="hs-identifier">context</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">parses</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">OK</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">context</span><span class="hs-operator">.</span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#star"><span class="hs-identifier hs-type">star</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-541"></span><span class="hs-operator">&gt;</span><span> </span><span id="star"><span class="annot"><span class="annottext">star :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#star"><span class="hs-identifier hs-var hs-var">star</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Star"><span class="hs-identifier hs-var">Star</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Parser FilePath -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;*&quot;</span></span><span>
</span><span id="line-542"></span><span>
</span><span id="line-543"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">parameter</span><span>
</span><span id="line-544"></span><span>
</span><span id="line-545"></span><span class="hs-identifier">unnamed</span><span> </span><span class="hs-identifier">parameter</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">named</span><span> </span><span class="hs-identifier">parameter</span><span>
</span><span id="line-546"></span><span class="hs-identifier">use</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-keyword">where</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-operator">?</span><span>
</span><span id="line-547"></span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-keyword">where</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-operator">&gt;</span><span> </span><span class="hs-glyph">:</span><span class="hs-identifier">param</span><span>
</span><span id="line-548"></span><span>
</span><span id="line-549"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parameter"><span class="hs-identifier hs-type">parameter</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-550"></span><span class="hs-operator">&gt;</span><span> </span><span id="parameter"><span class="annot"><span class="annottext">parameter :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parameter"><span class="hs-identifier hs-var hs-var">parameter</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-551"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Parameter"><span class="hs-identifier hs-var">Parameter</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Parser Char -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#questionMark"><span class="hs-identifier hs-var">questionMark</span></a></span><span>
</span><span id="line-552"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#HostParameter"><span class="hs-identifier hs-var">HostParameter</span></a></span><span>
</span><span id="line-553"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">(FilePath -&gt; Maybe FilePath -&gt; ScalarExpr)
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe FilePath -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#hostParamTok"><span class="hs-identifier hs-var">hostParamTok</span></a></span><span>
</span><span id="line-554"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe FilePath -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe FilePath)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe FilePath)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;indicator&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; Parser FilePath -&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#hostParamTok"><span class="hs-identifier hs-var">hostParamTok</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">positional</span><span> </span><span class="hs-identifier">arg</span><span>
</span><span id="line-557"></span><span>
</span><span id="line-558"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#positionalArg"><span class="hs-identifier hs-type">positionalArg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-559"></span><span class="hs-operator">&gt;</span><span> </span><span id="positionalArg"><span class="annot"><span class="annottext">positionalArg :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#positionalArg"><span class="hs-identifier hs-var hs-var">positionalArg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PositionalArg"><span class="hs-identifier hs-var">PositionalArg</span></a></span><span> </span><span class="annot"><span class="annottext">(Int -&gt; ScalarExpr)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Int
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Int
</span><a href="Language.SQL.SimpleSQL.Parse.html#positionalArgTok"><span class="hs-identifier hs-var">positionalArgTok</span></a></span><span>
</span><span id="line-560"></span><span>
</span><span id="line-561"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">parens</span><span>
</span><span id="line-562"></span><span>
</span><span id="line-563"></span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">parens</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">row</span><span> </span><span class="hs-identifier">ctor</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">subquery</span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parensExpr"><span class="hs-identifier hs-type">parensExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-566"></span><span class="hs-operator">&gt;</span><span> </span><span id="parensExpr"><span class="annot"><span class="annottext">parensExpr :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parensExpr"><span class="hs-identifier hs-var hs-var">parensExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser ScalarExpr -&gt; Parser ScalarExpr)
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-567"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SubQueryExprType -&gt; QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SubQueryExpr"><span class="hs-identifier hs-var">SubQueryExpr</span></a></span><span> </span><span class="annot"><span class="annottext">SubQueryExprType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SqSq"><span class="hs-identifier hs-var">SqSq</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; ScalarExpr) -&gt; Parser QueryExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-568"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[ScalarExpr] -&gt; ScalarExpr
</span><a href="#local-6989586621679120735"><span class="hs-identifier hs-var">ctor</span></a></span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-569"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-570"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120735"><span class="annot"><span class="annottext">ctor :: [ScalarExpr] -&gt; ScalarExpr
</span><a href="#local-6989586621679120735"><span class="hs-identifier hs-var hs-var">ctor</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679120734"><span class="annot"><span class="annottext">a :: ScalarExpr
</span><a href="#local-6989586621679120734"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Parens"><span class="hs-identifier hs-var">Parens</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120734"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-571"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120735"><span class="hs-identifier hs-var">ctor</span></a></span><span> </span><span id="local-6989586621679120732"><span class="annot"><span class="annottext">as :: [ScalarExpr]
</span><a href="#local-6989586621679120732"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SpecialOp"><span class="hs-identifier hs-var">SpecialOp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="hs-string">&quot;rowctor&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[ScalarExpr]
</span><a href="#local-6989586621679120732"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-572"></span><span>
</span><span id="line-573"></span><span class="hs-operator">==</span><span> </span><span class="hs-keyword">case</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">cast</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">exists</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unique</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">array</span><span class="hs-operator">/</span><span class="hs-identifier">multiset</span><span> </span><span class="hs-identifier">constructor</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">interval</span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span class="hs-identifier">All</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">fixed</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">reserved</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">so</span><span> </span><span class="hs-identifier">no</span><span> </span><span class="hs-identifier">other</span><span>
</span><span id="line-576"></span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">same</span><span> </span><span class="hs-identifier">keyword</span><span class="hs-operator">.</span><span>
</span><span id="line-577"></span><span>
</span><span id="line-578"></span><span class="hs-operator">===</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">expression</span><span>
</span><span id="line-579"></span><span>
</span><span id="line-580"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#caseExpr"><span class="hs-identifier hs-type">caseExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-581"></span><span class="hs-operator">&gt;</span><span> </span><span id="caseExpr"><span class="annot"><span class="annottext">caseExpr :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#caseExpr"><span class="hs-identifier hs-var hs-var">caseExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-582"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Maybe ScalarExpr
-&gt; [([ScalarExpr], ScalarExpr)] -&gt; Maybe ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Case"><span class="hs-identifier hs-var">Case</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe ScalarExpr
 -&gt; [([ScalarExpr], ScalarExpr)] -&gt; Maybe ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([([ScalarExpr], ScalarExpr)] -&gt; Maybe ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;case&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-583"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([([ScalarExpr], ScalarExpr)] -&gt; Maybe ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [([ScalarExpr], ScalarExpr)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr], ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [([ScalarExpr], ScalarExpr)]
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m [a]
</span><span class="hs-identifier hs-var">many1</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr], ScalarExpr)
</span><a href="#local-6989586621679120728"><span class="hs-identifier hs-var">whenClause</span></a></span><span>
</span><span id="line-584"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120727"><span class="hs-identifier hs-var">elseClause</span></a></span><span>
</span><span id="line-585"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;end&quot;</span></span><span>
</span><span id="line-586"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-587"></span><span class="hs-operator">&gt;</span><span>    </span><span id="local-6989586621679120728"><span class="annot"><span class="annottext">whenClause :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr], ScalarExpr)
</span><a href="#local-6989586621679120728"><span class="hs-identifier hs-var hs-var">whenClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; ScalarExpr -&gt; ([ScalarExpr], ScalarExpr))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ([ScalarExpr], ScalarExpr))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;when&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-588"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ([ScalarExpr], ScalarExpr))
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr], ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;then&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-589"></span><span class="hs-operator">&gt;</span><span>    </span><span id="local-6989586621679120727"><span class="annot"><span class="annottext">elseClause :: Parser ScalarExpr
</span><a href="#local-6989586621679120727"><span class="hs-identifier hs-var hs-var">elseClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;else&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-590"></span><span>
</span><span id="line-591"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">cast</span><span>
</span><span id="line-592"></span><span>
</span><span id="line-593"></span><span class="hs-identifier">cast</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">cast</span><span class="hs-special">(</span><span class="hs-identifier">expr</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-keyword">type</span><span class="hs-special">)</span><span>
</span><span id="line-594"></span><span>
</span><span id="line-595"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#cast"><span class="hs-identifier hs-type">cast</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-596"></span><span class="hs-operator">&gt;</span><span> </span><span id="cast"><span class="annot"><span class="annottext">cast :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#cast"><span class="hs-identifier hs-var hs-var">cast</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cast&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-597"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScalarExpr -&gt; TypeName -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Cast"><span class="hs-identifier hs-var">Cast</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; TypeName -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TypeName -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-598"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TypeName -&gt; ScalarExpr)
-&gt; Parser TypeName -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser TypeName -&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-599"></span><span>
</span><span id="line-600"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">exists</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unique</span><span>
</span><span id="line-601"></span><span>
</span><span id="line-602"></span><span class="hs-identifier">subquery</span><span> </span><span class="hs-identifier">expression</span><span class="hs-glyph">:</span><span>
</span><span id="line-603"></span><span class="hs-special">[</span><span class="hs-identifier">exists</span><span class="hs-glyph">|</span><span class="hs-identifier">unique</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">queryexpr</span><span class="hs-special">)</span><span>
</span><span id="line-604"></span><span>
</span><span id="line-605"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#subquery"><span class="hs-identifier hs-type">subquery</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-606"></span><span class="hs-operator">&gt;</span><span> </span><span id="subquery"><span class="annot"><span class="annottext">subquery :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#subquery"><span class="hs-identifier hs-var hs-var">subquery</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SubQueryExprType -&gt; QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SubQueryExpr"><span class="hs-identifier hs-var">SubQueryExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(SubQueryExprType -&gt; QueryExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
</span><a href="#local-6989586621679120723"><span class="hs-identifier hs-var">sqkw</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; ScalarExpr)
-&gt; Parser QueryExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-607"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-608"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120723"><span class="annot"><span class="annottext">sqkw :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
</span><a href="#local-6989586621679120723"><span class="hs-identifier hs-var hs-var">sqkw</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SubQueryExprType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SqExists"><span class="hs-identifier hs-var">SqExists</span></a></span><span> </span><span class="annot"><span class="annottext">SubQueryExprType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;exists&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">SubQueryExprType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SqUnique"><span class="hs-identifier hs-var">SqUnique</span></a></span><span> </span><span class="annot"><span class="annottext">SubQueryExprType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SubQueryExprType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unique&quot;</span></span><span>
</span><span id="line-609"></span><span>
</span><span id="line-610"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">array</span><span class="hs-operator">/</span><span class="hs-identifier">multiset</span><span> </span><span class="hs-identifier">constructor</span><span>
</span><span id="line-611"></span><span>
</span><span id="line-612"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#arrayCtor"><span class="hs-identifier hs-type">arrayCtor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-613"></span><span class="hs-operator">&gt;</span><span> </span><span id="arrayCtor"><span class="annot"><span class="annottext">arrayCtor :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#arrayCtor"><span class="hs-identifier hs-var hs-var">arrayCtor</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;array&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-614"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-615"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ArrayCtor"><span class="hs-identifier hs-var">ArrayCtor</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; ScalarExpr) -&gt; Parser QueryExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-616"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ScalarExpr -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Array"><span class="hs-identifier hs-var">Array</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Iden"><span class="hs-identifier hs-var">Iden</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="hs-string">&quot;array&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-617"></span><span>
</span><span id="line-618"></span><span class="hs-identifier">As</span><span> </span><span class="hs-identifier">far</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">I</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">tell</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">table</span><span class="hs-special">(</span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expr</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">just</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">sugar</span><span> </span><span class="hs-identifier">for</span><span>
</span><span id="line-619"></span><span class="hs-identifier">multiset</span><span class="hs-special">(</span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expr</span><span class="hs-special">)</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">must</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">compatibility</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">something</span><span class="hs-operator">.</span><span>
</span><span id="line-620"></span><span>
</span><span id="line-621"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#multisetCtor"><span class="hs-identifier hs-type">multisetCtor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-622"></span><span class="hs-operator">&gt;</span><span> </span><span id="multisetCtor"><span class="annot"><span class="annottext">multisetCtor :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#multisetCtor"><span class="hs-identifier hs-var hs-var">multisetCtor</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-623"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-624"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;multiset&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-625"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-626"></span><span class="hs-operator">&gt;</span><span>      </span><span class="hs-special">[</span><span class="annot"><span class="annottext">QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MultisetQueryCtor"><span class="hs-identifier hs-var">MultisetQueryCtor</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; ScalarExpr) -&gt; Parser QueryExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-627"></span><span class="hs-operator">&gt;</span><span>      </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MultisetCtor"><span class="hs-identifier hs-var">MultisetCtor</span></a></span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-628"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-629"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MultisetQueryCtor"><span class="hs-identifier hs-var">MultisetQueryCtor</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; ScalarExpr) -&gt; Parser QueryExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-630"></span><span>
</span><span id="line-631"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#nextValueFor"><span class="hs-identifier hs-type">nextValueFor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-632"></span><span class="hs-operator">&gt;</span><span> </span><span id="nextValueFor"><span class="annot"><span class="annottext">nextValueFor :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#nextValueFor"><span class="hs-identifier hs-var hs-var">nextValueFor</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;next&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;value&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;for&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-633"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NextValueFor"><span class="hs-identifier hs-var">NextValueFor</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; ScalarExpr) -&gt; Parser [Name] -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-634"></span><span>
</span><span id="line-635"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">interval</span><span>
</span><span id="line-636"></span><span>
</span><span id="line-637"></span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">literals</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">follow</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">grammar</span><span> </span><span class="hs-identifier">less</span><span>
</span><span id="line-638"></span><span class="hs-identifier">permissively</span><span> </span><span class="hs-identifier">here</span><span>
</span><span id="line-639"></span><span>
</span><span id="line-640"></span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">SQL</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">literals</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">something</span><span> </span><span class="hs-identifier">like</span><span>
</span><span id="line-641"></span><span class="hs-identifier">interval</span><span> </span><span class="hs-char">'5'</span><span> </span><span class="hs-identifier">day</span><span> </span><span class="hs-special">(</span><span class="hs-number">3</span><span class="hs-special">)</span><span>
</span><span id="line-642"></span><span class="hs-identifier">or</span><span>
</span><span id="line-643"></span><span class="hs-identifier">interval</span><span> </span><span class="hs-char">'5'</span><span> </span><span class="hs-identifier">month</span><span>
</span><span id="line-644"></span><span>
</span><span id="line-645"></span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">looks</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">this</span><span class="hs-glyph">:</span><span>
</span><span id="line-646"></span><span class="hs-identifier">interval</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">something'</span><span>
</span><span id="line-647"></span><span>
</span><span id="line-648"></span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">parsed</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">regular</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">must</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-649"></span><span class="hs-identifier">interval</span><span class="hs-glyph">-</span><span class="hs-identifier">datetime</span><span class="hs-glyph">-</span><span class="hs-identifier">field</span><span> </span><span class="hs-identifier">suffix</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">intervallit</span><span>
</span><span id="line-650"></span><span>
</span><span id="line-651"></span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">uses</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">because</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">conflict</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">names</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">todo</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">fix</span><span>
</span><span id="line-652"></span><span class="hs-identifier">this</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">monad</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">applicative</span><span>
</span><span id="line-653"></span><span>
</span><span id="line-654"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#intervalLit"><span class="hs-identifier hs-type">intervalLit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-655"></span><span class="hs-operator">&gt;</span><span> </span><span id="intervalLit"><span class="annot"><span class="annottext">intervalLit :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#intervalLit"><span class="hs-identifier hs-var hs-var">intervalLit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;interval&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-656"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120709"><span class="annot"><span class="annottext">Maybe Sign
</span><a href="#local-6989586621679120709"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Sign)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Sign))
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Sign)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Sign
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Plus"><span class="hs-identifier hs-var">Plus</span></a></span><span> </span><span class="annot"><span class="annottext">Sign
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-var">symbol_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;+&quot;</span></span><span>
</span><span id="line-657"></span><span class="hs-operator">&gt;</span><span>                               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Sign
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Minus"><span class="hs-identifier hs-var">Minus</span></a></span><span> </span><span class="annot"><span class="annottext">Sign
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Sign
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-var">symbol_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-658"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120705"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120705"><span class="hs-identifier hs-var">lit</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-var">singleQuotesOnlyStringTok</span></a></span><span>
</span><span id="line-659"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120703"><span class="annot"><span class="annottext">Maybe (IntervalTypeField, Maybe IntervalTypeField)
</span><a href="#local-6989586621679120703"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (IntervalTypeField, Maybe IntervalTypeField)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (IntervalTypeField, Maybe IntervalTypeField))
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (IntervalTypeField, Maybe IntervalTypeField)
</span><a href="Language.SQL.SimpleSQL.Parse.html#intervalQualifier"><span class="hs-identifier hs-var">intervalQualifier</span></a></span><span>
</span><span id="line-660"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Maybe Sign
-&gt; FilePath
-&gt; Maybe (IntervalTypeField, Maybe IntervalTypeField)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *).
MonadFail f =&gt;
Maybe Sign
-&gt; FilePath
-&gt; Maybe (IntervalTypeField, Maybe IntervalTypeField)
-&gt; f ScalarExpr
</span><a href="#local-6989586621679120702"><span class="hs-identifier hs-var">mkIt</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Sign
</span><a href="#local-6989586621679120709"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120705"><span class="hs-identifier hs-var">lit</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (IntervalTypeField, Maybe IntervalTypeField)
</span><a href="#local-6989586621679120703"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-661"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-662"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120702"><span class="annot"><span class="annottext">mkIt :: Maybe Sign
-&gt; FilePath
-&gt; Maybe (IntervalTypeField, Maybe IntervalTypeField)
-&gt; f ScalarExpr
</span><a href="#local-6989586621679120702"><span class="hs-identifier hs-var hs-var">mkIt</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span id="local-6989586621679120701"><span class="annot"><span class="annottext">val :: FilePath
</span><a href="#local-6989586621679120701"><span class="hs-identifier hs-var">val</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; f ScalarExpr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; f ScalarExpr) -&gt; ScalarExpr -&gt; f ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TypeName -&gt; FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TypedLit"><span class="hs-identifier hs-var">TypedLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; TypeName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TypeName"><span class="hs-identifier hs-var">TypeName</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="hs-string">&quot;interval&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120701"><span class="hs-identifier hs-var">val</span></a></span><span>
</span><span id="line-663"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120702"><span class="hs-identifier hs-var">mkIt</span></a></span><span> </span><span id="local-6989586621679120699"><span class="annot"><span class="annottext">s :: Maybe Sign
</span><a href="#local-6989586621679120699"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679120698"><span class="annot"><span class="annottext">val :: FilePath
</span><a href="#local-6989586621679120698"><span class="hs-identifier hs-var">val</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120697"><span class="annot"><span class="annottext">a :: IntervalTypeField
</span><a href="#local-6989586621679120697"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120696"><span class="annot"><span class="annottext">b :: Maybe IntervalTypeField
</span><a href="#local-6989586621679120696"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; f ScalarExpr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; f ScalarExpr) -&gt; ScalarExpr -&gt; f ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe Sign
-&gt; FilePath
-&gt; IntervalTypeField
-&gt; Maybe IntervalTypeField
-&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#IntervalLit"><span class="hs-identifier hs-var">IntervalLit</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Sign
</span><a href="#local-6989586621679120699"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120698"><span class="hs-identifier hs-var">val</span></a></span><span> </span><span class="annot"><span class="annottext">IntervalTypeField
</span><a href="#local-6989586621679120697"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe IntervalTypeField
</span><a href="#local-6989586621679120696"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-664"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120702"><span class="hs-identifier hs-var">mkIt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679120694"><span class="annot"><span class="annottext">_val :: FilePath
</span><a href="#local-6989586621679120694"><span class="hs-identifier hs-var">_val</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; f ScalarExpr
forall (m :: * -&gt; *) a. MonadFail m =&gt; FilePath -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="hs-string">&quot;cannot use sign without interval qualifier&quot;</span></span><span>
</span><span id="line-665"></span><span>
</span><span id="line-666"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">app</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">special</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">aggregate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">window</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">iden</span><span>
</span><span id="line-667"></span><span>
</span><span id="line-668"></span><span class="hs-identifier">All</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">identifiers</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">some</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-identifier">functions</span><span>
</span><span id="line-669"></span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">reserved</span><span> </span><span class="hs-identifier">keywords</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-670"></span><span>
</span><span id="line-671"></span><span class="hs-identifier">they</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">variations</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">suffixes</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">basic</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">parser</span><span>
</span><span id="line-672"></span><span>
</span><span id="line-673"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">windows</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">suffix</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">app</span><span> </span><span class="hs-identifier">parser</span><span>
</span><span id="line-674"></span><span>
</span><span id="line-675"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">iden</span><span> </span><span class="hs-identifier">prefix</span><span> </span><span class="hs-identifier">term</span><span>
</span><span id="line-676"></span><span>
</span><span id="line-677"></span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">start</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">identifier</span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span class="hs-special">(</span><span class="hs-identifier">todo</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">really</span><span> </span><span class="hs-identifier">put</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">them</span><span> </span><span class="hs-identifier">here</span><span> </span><span class="hs-identifier">instead</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">just</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">them</span><span class="hs-special">)</span><span>
</span><span id="line-680"></span><span>
</span><span id="line-681"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#idenExpr"><span class="hs-identifier hs-type">idenExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-682"></span><span class="hs-operator">&gt;</span><span> </span><span id="idenExpr"><span class="annot"><span class="annottext">idenExpr :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#idenExpr"><span class="hs-identifier hs-var hs-var">idenExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-683"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: work out how to left factor this</span><span>
</span><span id="line-684"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TypeName -&gt; FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TypedLit"><span class="hs-identifier hs-var">TypedLit</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeName -&gt; FilePath -&gt; ScalarExpr)
-&gt; Parser TypeName
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath -&gt; ScalarExpr)
-&gt; Parser FilePath -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-var">singleQuotesOnlyStringTok</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-685"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Iden"><span class="hs-identifier hs-var">Iden</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#app"><span class="hs-identifier hs-var">app</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-686"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120691"><span class="hs-identifier hs-var">keywordFunctionOrIden</span></a></span><span>
</span><span id="line-687"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-688"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- special cases for keywords that can be parsed as an iden or app</span><span>
</span><span id="line-689"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120691"><span class="annot"><span class="annottext">keywordFunctionOrIden :: Parser ScalarExpr
</span><a href="#local-6989586621679120691"><span class="hs-identifier hs-var hs-var">keywordFunctionOrIden</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">(Parser ScalarExpr -&gt; Parser ScalarExpr)
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-690"></span><span class="hs-operator">&gt;</span><span>         </span><span id="local-6989586621679120690"><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; Maybe FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#unquotedIdentifierTok"><span class="hs-identifier hs-var">unquotedIdentifierTok</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-691"></span><span class="hs-operator">&gt;</span><span>         </span><span id="local-6989586621679120688"><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120688"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Dialect
forall (m :: * -&gt; *) s u. Monad m =&gt; ParsecT s u m u
</span><span class="hs-identifier hs-var">getState</span></span><span>
</span><span id="line-692"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679120687"><span class="annot"><span class="annottext">i :: Bool
</span><a href="#local-6989586621679120687"><span class="hs-identifier hs-var hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diIdentifierKeywords"><span class="hs-identifier hs-var hs-var">diIdentifierKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120688"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-693"></span><span class="hs-operator">&gt;</span><span>             </span><span id="local-6989586621679120684"><span class="annot"><span class="annottext">a :: Bool
</span><a href="#local-6989586621679120684"><span class="hs-identifier hs-var hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diAppKeywords"><span class="hs-identifier hs-var hs-var">diAppKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120688"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-694"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-695"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-identifier">_</span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120687"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120684"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Iden"><span class="hs-identifier hs-var">Iden</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#app"><span class="hs-identifier hs-var">app</span></a></span><span>
</span><span id="line-696"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120687"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Iden"><span class="hs-identifier hs-var">Iden</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-697"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120684"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120690"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#app"><span class="hs-identifier hs-var">app</span></a></span><span>
</span><span id="line-698"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a. MonadFail m =&gt; FilePath -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-699"></span><span>
</span><span id="line-700"></span><span>
</span><span id="line-701"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">special</span><span>
</span><span id="line-702"></span><span>
</span><span id="line-703"></span><span class="hs-identifier">These</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">operators</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">don't</span><span> </span><span class="hs-identifier">look</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">normal</span><span> </span><span class="hs-identifier">prefix</span><span class="hs-special">,</span><span>
</span><span id="line-704"></span><span class="hs-identifier">postfix</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">binary</span><span> </span><span class="hs-identifier">operators</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">They</span><span> </span><span class="hs-identifier">mostly</span><span> </span><span class="hs-identifier">look</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">function</span><span>
</span><span id="line-705"></span><span class="hs-identifier">application</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">keywords</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">argument</span><span> </span><span class="hs-identifier">list</span><span> </span><span class="hs-identifier">instead</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">commas</span><span>
</span><span id="line-706"></span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">separate</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">arguments</span><span class="hs-operator">.</span><span>
</span><span id="line-707"></span><span>
</span><span id="line-708"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-identifier">op</span><span> </span><span class="hs-identifier">keywords</span><span>
</span><span id="line-709"></span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">operator</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span>
</span><span id="line-710"></span><span class="hs-identifier">operatorname</span><span class="hs-special">(</span><span class="hs-identifier">firstArg</span><span> </span><span class="hs-identifier">keyword0</span><span> </span><span class="hs-identifier">arg0</span><span> </span><span class="hs-identifier">keyword1</span><span> </span><span class="hs-identifier">arg1</span><span> </span><span class="hs-identifier">etc</span><span class="hs-operator">.</span><span class="hs-special">)</span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">data</span><span> </span><span id="SpecialOpKFirstArg"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SpecialOpKFirstArg"><span class="hs-identifier hs-var">SpecialOpKFirstArg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="SOKNone"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKNone"><span class="hs-identifier hs-var">SOKNone</span></a></span></span><span>
</span><span id="line-713"></span><span class="hs-operator">&gt;</span><span>                         </span><span class="hs-glyph">|</span><span> </span><span id="SOKOptional"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKOptional"><span class="hs-identifier hs-var">SOKOptional</span></a></span></span><span>
</span><span id="line-714"></span><span class="hs-operator">&gt;</span><span>                         </span><span class="hs-glyph">|</span><span> </span><span id="SOKMandatory"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span></span><span>
</span><span id="line-715"></span><span>
</span><span id="line-716"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-type">specialOpK</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- name of the operator</span><span>
</span><span id="line-717"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SpecialOpKFirstArg"><span class="hs-identifier hs-type">SpecialOpKFirstArg</span></a></span><span> </span><span class="hs-comment">-- has a first arg without a keyword</span><span>
</span><span id="line-718"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- the other args with their keywords</span><span>
</span><span id="line-719"></span><span class="hs-operator">&gt;</span><span>                               </span><span class="hs-comment">-- and whether they are optional</span><span>
</span><span id="line-720"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-721"></span><span class="hs-operator">&gt;</span><span> </span><span id="specialOpK"><span class="annot"><span class="annottext">specialOpK :: FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var hs-var">specialOpK</span></a></span></span><span> </span><span id="local-6989586621679120677"><span class="annot"><span class="annottext">opName :: FilePath
</span><a href="#local-6989586621679120677"><span class="hs-identifier hs-var">opName</span></a></span></span><span> </span><span id="local-6989586621679120676"><span class="annot"><span class="annottext">firstArg :: SpecialOpKFirstArg
</span><a href="#local-6989586621679120676"><span class="hs-identifier hs-var">firstArg</span></a></span></span><span> </span><span id="local-6989586621679120675"><span class="annot"><span class="annottext">kws :: [(FilePath, Bool)]
</span><a href="#local-6989586621679120675"><span class="hs-identifier hs-var">kws</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-722"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120677"><span class="hs-identifier hs-var">opName</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-723"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var">openParen</span></a></span><span>
</span><span id="line-724"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679120674"><span class="annot"><span class="annottext">pfa :: Parser ScalarExpr
</span><a href="#local-6989586621679120674"><span class="hs-identifier hs-var hs-var">pfa</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-725"></span><span class="hs-operator">&gt;</span><span>               </span><span id="local-6989586621679120673"><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120673"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-726"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-comment">-- check we haven't parsed the first</span><span>
</span><span id="line-727"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-comment">-- keyword as an identifier</span><span>
</span><span id="line-728"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120673"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[(FilePath, Bool)]
</span><a href="#local-6989586621679120675"><span class="hs-identifier hs-var">kws</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-729"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Iden"><span class="hs-identifier hs-type">Iden</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span id="local-6989586621679120672"><span class="annot"><span class="annottext">i :: FilePath
</span><a href="#local-6989586621679120672"><span class="hs-identifier hs-var">i</span></a></span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120671"><span class="annot"><span class="annottext">k :: FilePath
</span><a href="#local-6989586621679120671"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><span id="line-730"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120672"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120671"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-731"></span><span class="hs-operator">&gt;</span><span>                           </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (m :: * -&gt; *) a. MonadFail m =&gt; FilePath -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(FilePath
 -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ())
-&gt; FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;cannot use keyword here: &quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120672"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-732"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-733"></span><span class="hs-operator">&gt;</span><span>               </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120673"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-734"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120670"><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120670"><span class="hs-identifier hs-var">fa</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="#local-6989586621679120676"><span class="hs-identifier hs-var">firstArg</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-735"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKNone"><span class="hs-identifier hs-type">SOKNone</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-736"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKOptional"><span class="hs-identifier hs-type">SOKOptional</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120674"><span class="hs-identifier hs-var">pfa</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-737"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-type">SOKMandatory</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Maybe ScalarExpr
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120674"><span class="hs-identifier hs-var">pfa</span></a></span><span>
</span><span id="line-738"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120669"><span class="annot"><span class="annottext">[Maybe (FilePath, ScalarExpr)]
</span><a href="#local-6989586621679120669"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">((FilePath, Bool)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (Maybe (FilePath, ScalarExpr)))
-&gt; [(FilePath, Bool)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [Maybe (FilePath, ScalarExpr)]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">(FilePath, Bool)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, ScalarExpr))
</span><a href="#local-6989586621679120667"><span class="hs-identifier hs-var">parseArg</span></a></span><span> </span><span class="annot"><span class="annottext">[(FilePath, Bool)]
</span><a href="#local-6989586621679120675"><span class="hs-identifier hs-var">kws</span></a></span><span>
</span><span id="line-739"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span>
</span><span id="line-740"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Parser ScalarExpr)
-&gt; ScalarExpr -&gt; Parser ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; Maybe ScalarExpr -&gt; [(FilePath, ScalarExpr)] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SpecialOpK"><span class="hs-identifier hs-var">SpecialOpK</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120677"><span class="hs-identifier hs-var">opName</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120670"><span class="hs-identifier hs-var">fa</span></a></span><span> </span><span class="annot"><span class="annottext">([(FilePath, ScalarExpr)] -&gt; ScalarExpr)
-&gt; [(FilePath, ScalarExpr)] -&gt; ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (FilePath, ScalarExpr)] -&gt; [(FilePath, ScalarExpr)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (FilePath, ScalarExpr)]
</span><a href="#local-6989586621679120669"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-741"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-742"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120667"><span class="annot"><span class="annottext">parseArg :: (FilePath, Bool)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, ScalarExpr))
</span><a href="#local-6989586621679120667"><span class="hs-identifier hs-var hs-var">parseArg</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120664"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120664"><span class="hs-identifier hs-var">nm</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120663"><span class="annot"><span class="annottext">mand :: Bool
</span><a href="#local-6989586621679120663"><span class="hs-identifier hs-var">mand</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-743"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679120662"><span class="annot"><span class="annottext">p :: Parser ScalarExpr
</span><a href="#local-6989586621679120662"><span class="hs-identifier hs-var hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120664"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-744"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; (FilePath, ScalarExpr))
-&gt; Maybe ScalarExpr -&gt; Maybe (FilePath, ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120664"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe ScalarExpr -&gt; Maybe (FilePath, ScalarExpr))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, ScalarExpr))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120663"><span class="hs-identifier hs-var">mand</span></a></span><span>
</span><span id="line-745"></span><span class="hs-operator">&gt;</span><span>                           </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Maybe ScalarExpr
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120662"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-746"></span><span class="hs-operator">&gt;</span><span>                           </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120662"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-747"></span><span>
</span><span id="line-748"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">actual</span><span> </span><span class="hs-identifier">operators</span><span class="hs-glyph">:</span><span>
</span><span id="line-749"></span><span>
</span><span id="line-750"></span><span class="hs-identifier">EXTRACT</span><span class="hs-special">(</span><span> </span><span class="hs-identifier">date_part</span><span> </span><span class="hs-identifier">FROM</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-751"></span><span>
</span><span id="line-752"></span><span class="hs-identifier">POSITION</span><span class="hs-special">(</span><span> </span><span class="hs-identifier">string1</span><span> </span><span class="hs-identifier">IN</span><span> </span><span class="hs-identifier">string2</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-753"></span><span>
</span><span id="line-754"></span><span class="hs-identifier">SUBSTRING</span><span class="hs-special">(</span><span class="hs-identifier">extraction_string</span><span> </span><span class="hs-identifier">FROM</span><span> </span><span class="hs-identifier">starting_position</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FOR</span><span> </span><span class="hs-identifier">length</span><span class="hs-special">]</span><span>
</span><span id="line-755"></span><span class="hs-special">[</span><span class="hs-identifier">COLLATE</span><span> </span><span class="hs-identifier">collation_name</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-756"></span><span>
</span><span id="line-757"></span><span class="hs-identifier">CONVERT</span><span class="hs-special">(</span><span class="hs-identifier">char_value</span><span> </span><span class="hs-identifier">USING</span><span> </span><span class="hs-identifier">conversion_char_name</span><span class="hs-special">)</span><span>
</span><span id="line-758"></span><span>
</span><span id="line-759"></span><span class="hs-identifier">TRANSLATE</span><span class="hs-special">(</span><span class="hs-identifier">char_value</span><span> </span><span class="hs-identifier">USING</span><span> </span><span class="hs-identifier">translation_name</span><span class="hs-special">)</span><span>
</span><span id="line-760"></span><span>
</span><span id="line-761"></span><span class="hs-identifier">OVERLAY</span><span class="hs-special">(</span><span class="hs-identifier">string</span><span> </span><span class="hs-identifier">PLACING</span><span> </span><span class="hs-identifier">embedded_string</span><span> </span><span class="hs-identifier">FROM</span><span> </span><span class="hs-identifier">start</span><span>
</span><span id="line-762"></span><span class="hs-special">[</span><span class="hs-identifier">FOR</span><span> </span><span class="hs-identifier">length</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-763"></span><span>
</span><span id="line-764"></span><span class="hs-identifier">TRIM</span><span class="hs-special">(</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">[</span><span class="hs-special">{</span><span class="hs-identifier">LEADING</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">TRAILING</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">BOTH</span><span class="hs-special">}</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">removal_char</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">FROM</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-765"></span><span class="hs-identifier">target_string</span><span>
</span><span id="line-766"></span><span class="hs-special">[</span><span class="hs-identifier">COLLATE</span><span> </span><span class="hs-identifier">collation_name</span><span class="hs-special">]</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#specialOpKs"><span class="hs-identifier hs-type">specialOpKs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-769"></span><span class="hs-operator">&gt;</span><span> </span><span id="specialOpKs"><span class="annot"><span class="annottext">specialOpKs :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpKs"><span class="hs-identifier hs-var hs-var">specialOpKs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="annot"><span class="annottext">([Parser ScalarExpr] -&gt; Parser ScalarExpr)
-&gt; [Parser ScalarExpr] -&gt; Parser ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Parser ScalarExpr -&gt; Parser ScalarExpr)
-&gt; [Parser ScalarExpr] -&gt; [Parser ScalarExpr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span>
</span><span id="line-770"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#extract"><span class="hs-identifier hs-var">extract</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#position"><span class="hs-identifier hs-var">position</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#substring"><span class="hs-identifier hs-var">substring</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#convert"><span class="hs-identifier hs-var">convert</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#translate"><span class="hs-identifier hs-var">translate</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#overlay"><span class="hs-identifier hs-var">overlay</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#trim"><span class="hs-identifier hs-var">trim</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-771"></span><span>
</span><span id="line-772"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#extract"><span class="hs-identifier hs-type">extract</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-773"></span><span class="hs-operator">&gt;</span><span> </span><span id="extract"><span class="annot"><span class="annottext">extract :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#extract"><span class="hs-identifier hs-var hs-var">extract</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;extract&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-774"></span><span>
</span><span id="line-775"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#position"><span class="hs-identifier hs-type">position</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-776"></span><span class="hs-operator">&gt;</span><span> </span><span id="position"><span class="annot"><span class="annottext">position :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#position"><span class="hs-identifier hs-var hs-var">position</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;position&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;in&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-777"></span><span>
</span><span id="line-778"></span><span class="hs-identifier">strictly</span><span> </span><span class="hs-identifier">speaking</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">substring</span><span> </span><span class="hs-identifier">must</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">least</span><span> </span><span class="hs-identifier">one</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">and</span><span>
</span><span id="line-779"></span><span class="hs-identifier">for</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">doens't</span><span> </span><span class="hs-identifier">enforce</span><span> </span><span class="hs-identifier">this</span><span>
</span><span id="line-780"></span><span>
</span><span id="line-781"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#substring"><span class="hs-identifier hs-type">substring</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-782"></span><span class="hs-operator">&gt;</span><span> </span><span id="substring"><span class="annot"><span class="annottext">substring :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#substring"><span class="hs-identifier hs-var hs-var">substring</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;substring&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span>
</span><span id="line-783"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;for&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-784"></span><span>
</span><span id="line-785"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#convert"><span class="hs-identifier hs-type">convert</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-786"></span><span class="hs-operator">&gt;</span><span> </span><span id="convert"><span class="annot"><span class="annottext">convert :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#convert"><span class="hs-identifier hs-var hs-var">convert</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;convert&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;using&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-787"></span><span>
</span><span id="line-788"></span><span>
</span><span id="line-789"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#translate"><span class="hs-identifier hs-type">translate</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-790"></span><span class="hs-operator">&gt;</span><span> </span><span id="translate"><span class="annot"><span class="annottext">translate :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#translate"><span class="hs-identifier hs-var hs-var">translate</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;translate&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;using&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-791"></span><span>
</span><span id="line-792"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#overlay"><span class="hs-identifier hs-type">overlay</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-793"></span><span class="hs-operator">&gt;</span><span> </span><span id="overlay"><span class="annot"><span class="annottext">overlay :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#overlay"><span class="hs-identifier hs-var hs-var">overlay</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; SpecialOpKFirstArg -&gt; [(FilePath, Bool)] -&gt; Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpK"><span class="hs-identifier hs-var">specialOpK</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;overlay&quot;</span></span><span> </span><span class="annot"><span class="annottext">SpecialOpKFirstArg
</span><a href="Language.SQL.SimpleSQL.Parse.html#SOKMandatory"><span class="hs-identifier hs-var">SOKMandatory</span></a></span><span>
</span><span id="line-794"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;placing&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;for&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-795"></span><span>
</span><span id="line-796"></span><span class="hs-identifier">trim</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">too</span><span> </span><span class="hs-identifier">different</span><span> </span><span class="hs-identifier">because</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">char</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">so</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">custom</span><span> </span><span class="hs-identifier">parser</span><span>
</span><span id="line-797"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">both</span><span> </span><span class="hs-char">' '</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">filled</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-keyword">default</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">either</span><span> </span><span class="hs-identifier">parts</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">missing</span><span>
</span><span id="line-798"></span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">source</span><span>
</span><span id="line-799"></span><span>
</span><span id="line-800"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#trim"><span class="hs-identifier hs-type">trim</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-801"></span><span class="hs-operator">&gt;</span><span> </span><span id="trim"><span class="annot"><span class="annottext">trim :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#trim"><span class="hs-identifier hs-var hs-var">trim</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-802"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;trim&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-803"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120653"><span class="hs-identifier hs-var">mkTrim</span></a></span><span>
</span><span id="line-804"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">(FilePath -&gt; FilePath -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath -&gt; Parser FilePath
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="hs-string">&quot;both&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="#local-6989586621679120652"><span class="hs-identifier hs-var">sides</span></a></span><span>
</span><span id="line-805"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath -&gt; Parser FilePath
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-var">singleQuotesOnlyStringTok</span></a></span><span>
</span><span id="line-806"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-807"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-808"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120652"><span class="annot"><span class="annottext">sides :: Parser FilePath
</span><a href="#local-6989586621679120652"><span class="hs-identifier hs-var hs-var">sides</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser FilePath] -&gt; Parser FilePath
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;leading&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;leading&quot;</span></span><span>
</span><span id="line-809"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;trailing&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;trailing&quot;</span></span><span>
</span><span id="line-810"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;both&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;both&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-811"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120653"><span class="annot"><span class="annottext">mkTrim :: FilePath -&gt; FilePath -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120653"><span class="hs-identifier hs-var hs-var">mkTrim</span></a></span></span><span> </span><span id="local-6989586621679120651"><span class="annot"><span class="annottext">fa :: FilePath
</span><a href="#local-6989586621679120651"><span class="hs-identifier hs-var">fa</span></a></span></span><span> </span><span id="local-6989586621679120650"><span class="annot"><span class="annottext">ch :: FilePath
</span><a href="#local-6989586621679120650"><span class="hs-identifier hs-var">ch</span></a></span></span><span> </span><span id="local-6989586621679120649"><span class="annot"><span class="annottext">fr :: ScalarExpr
</span><a href="#local-6989586621679120649"><span class="hs-identifier hs-var">fr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-812"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><span class="annottext">[Name]
-&gt; Maybe ScalarExpr -&gt; [(FilePath, ScalarExpr)] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SpecialOpK"><span class="hs-identifier hs-var">SpecialOpK</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="hs-string">&quot;trim&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-813"></span><span class="hs-operator">&gt;</span><span>           </span><span class="annot"><span class="annottext">([(FilePath, ScalarExpr)] -&gt; ScalarExpr)
-&gt; [(FilePath, ScalarExpr)] -&gt; ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Maybe (FilePath, ScalarExpr)] -&gt; [(FilePath, ScalarExpr)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">(FilePath, ScalarExpr) -&gt; Maybe (FilePath, ScalarExpr)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120651"><span class="hs-identifier hs-var">fa</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#StringLit"><span class="hs-identifier hs-var">StringLit</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120650"><span class="hs-identifier hs-var">ch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-814"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(FilePath, ScalarExpr) -&gt; Maybe (FilePath, ScalarExpr)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120649"><span class="hs-identifier hs-var">fr</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-815"></span><span>
</span><span id="line-816"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">app</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">aggregate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">window</span><span>
</span><span id="line-817"></span><span>
</span><span id="line-818"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">parses</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">variations</span><span class="hs-glyph">:</span><span>
</span><span id="line-819"></span><span class="hs-identifier">normal</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">application</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">just</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">csv</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">exprs</span><span>
</span><span id="line-820"></span><span class="hs-identifier">aggregate</span><span> </span><span class="hs-identifier">variations</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">distinct</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">order</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">parens</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">filter</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-821"></span><span>  </span><span class="hs-identifier">suffixes</span><span class="hs-special">)</span><span>
</span><span id="line-822"></span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">apps</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">fn</span><span class="hs-operator">/</span><span class="hs-identifier">agg</span><span> </span><span class="hs-identifier">followed</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">over</span><span class="hs-special">)</span><span>
</span><span id="line-823"></span><span>
</span><span id="line-824"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">little</span><span> </span><span class="hs-identifier">dense</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">because</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-825"></span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factoring</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">later</span><span> </span><span class="hs-identifier">they</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">even</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">partially</span><span> </span><span class="hs-identifier">combined</span><span>
</span><span id="line-826"></span><span class="hs-identifier">together</span><span class="hs-operator">.</span><span>
</span><span id="line-827"></span><span>
</span><span id="line-828"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#app"><span class="hs-identifier hs-type">app</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-829"></span><span class="hs-operator">&gt;</span><span> </span><span id="app"><span class="annot"><span class="annottext">app :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#app"><span class="hs-identifier hs-var hs-var">app</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-830"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var">openParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   ([Name] -&gt; ScalarExpr)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-831"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-var">duplicates</span></a></span><span>
</span><span id="line-832"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">Parser SetQuantifier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-833"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var">orderBy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-834"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec]
      -&gt; [ScalarExpr] -&gt; SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#afilter"><span class="hs-identifier hs-var">afilter</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ([Name]
    -&gt; SetQuantifier
    -&gt; [ScalarExpr]
    -&gt; [SortSpec]
    -&gt; Maybe ScalarExpr
    -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec]
      -&gt; [ScalarExpr] -&gt; SetQuantifier -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) e a b c d t.
Applicative f =&gt;
f e -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; t) -&gt; f (d -&gt; c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; SetQuantifier
-&gt; [ScalarExpr]
-&gt; [SortSpec]
-&gt; Maybe ScalarExpr
-&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AggregateApp"><span class="hs-identifier hs-var">AggregateApp</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-835"></span><span class="hs-operator">&gt;</span><span>      </span><span class="hs-comment">-- separate cases with no all or distinct which must have at</span><span>
</span><span id="line-836"></span><span class="hs-operator">&gt;</span><span>      </span><span class="hs-comment">-- least one scalar expr</span><span>
</span><span id="line-837"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-838"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-839"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-840"></span><span class="hs-operator">&gt;</span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#window"><span class="hs-identifier hs-var">window</span></a></span><span>
</span><span id="line-841"></span><span class="hs-operator">&gt;</span><span>                          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#withinGroup"><span class="hs-identifier hs-var">withinGroup</span></a></span><span>
</span><span id="line-842"></span><span class="hs-operator">&gt;</span><span>                          </span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScalarExpr -&gt; Maybe ScalarExpr
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#afilter"><span class="hs-identifier hs-var">afilter</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ([Name] -&gt; [ScalarExpr] -&gt; Maybe ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) c a b t.
Applicative f =&gt;
f c -&gt; (a -&gt; b -&gt; c -&gt; t) -&gt; f (b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; Maybe ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120641"><span class="hs-identifier hs-var">aggAppWithoutDupeOrd</span></a></span><span>
</span><span id="line-843"></span><span class="hs-operator">&gt;</span><span>                          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Name] -&gt; [ScalarExpr] -&gt; ScalarExpr)
-&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#App"><span class="hs-identifier hs-var">App</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-844"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var">orderBy</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span>
</span><span id="line-845"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#afilter"><span class="hs-identifier hs-var">afilter</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ([Name]
    -&gt; [ScalarExpr] -&gt; [SortSpec] -&gt; Maybe ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) d a b c t.
Applicative f =&gt;
f d -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; t) -&gt; f (c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; [ScalarExpr] -&gt; [SortSpec] -&gt; Maybe ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120639"><span class="hs-identifier hs-var">aggAppWithoutDupe</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-846"></span><span class="hs-operator">&gt;</span><span>      </span><span class="hs-comment">-- no scalarExprs: duplicates and order by not allowed</span><span>
</span><span id="line-847"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[ScalarExpr]
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Name] -&gt; [ScalarExpr] -&gt; ScalarExpr)
-&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#App"><span class="hs-identifier hs-var">App</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#window"><span class="hs-identifier hs-var">window</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#withinGroup"><span class="hs-identifier hs-var">withinGroup</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-848"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">]</span><span>
</span><span id="line-849"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-850"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120641"><span class="annot"><span class="annottext">aggAppWithoutDupeOrd :: [Name] -&gt; [ScalarExpr] -&gt; Maybe ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120641"><span class="hs-identifier hs-var hs-var">aggAppWithoutDupeOrd</span></a></span></span><span> </span><span id="local-6989586621679120638"><span class="annot"><span class="annottext">n :: [Name]
</span><a href="#local-6989586621679120638"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679120637"><span class="annot"><span class="annottext">es :: [ScalarExpr]
</span><a href="#local-6989586621679120637"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span id="local-6989586621679120636"><span class="annot"><span class="annottext">f :: Maybe ScalarExpr
</span><a href="#local-6989586621679120636"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; SetQuantifier
-&gt; [ScalarExpr]
-&gt; [SortSpec]
-&gt; Maybe ScalarExpr
-&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AggregateApp"><span class="hs-identifier hs-var">AggregateApp</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120638"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SQDefault"><span class="hs-identifier hs-var">SQDefault</span></a></span><span> </span><span class="annot"><span class="annottext">[ScalarExpr]
</span><a href="#local-6989586621679120637"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120636"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-851"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120639"><span class="annot"><span class="annottext">aggAppWithoutDupe :: [Name]
-&gt; [ScalarExpr] -&gt; [SortSpec] -&gt; Maybe ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120639"><span class="hs-identifier hs-var hs-var">aggAppWithoutDupe</span></a></span></span><span> </span><span id="local-6989586621679120634"><span class="annot"><span class="annottext">n :: [Name]
</span><a href="#local-6989586621679120634"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; SetQuantifier
-&gt; [ScalarExpr]
-&gt; [SortSpec]
-&gt; Maybe ScalarExpr
-&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AggregateApp"><span class="hs-identifier hs-var">AggregateApp</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120634"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SQDefault"><span class="hs-identifier hs-var">SQDefault</span></a></span><span>
</span><span id="line-852"></span><span>
</span><span id="line-853"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#afilter"><span class="hs-identifier hs-type">afilter</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-854"></span><span class="hs-operator">&gt;</span><span> </span><span id="afilter"><span class="annot"><span class="annottext">afilter :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#afilter"><span class="hs-identifier hs-var hs-var">afilter</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;filter&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;where&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-855"></span><span>
</span><span id="line-856"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#withinGroup"><span class="hs-identifier hs-type">withinGroup</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-857"></span><span class="hs-operator">&gt;</span><span> </span><span id="withinGroup"><span class="annot"><span class="annottext">withinGroup :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#withinGroup"><span class="hs-identifier hs-var hs-var">withinGroup</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-858"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;within&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;group&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var">orderBy</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ([Name] -&gt; [ScalarExpr] -&gt; [SortSpec] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) c a b t.
Applicative f =&gt;
f c -&gt; (a -&gt; b -&gt; c -&gt; t) -&gt; f (b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; [SortSpec] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AggregateAppGroup"><span class="hs-identifier hs-var">AggregateAppGroup</span></a></span><span>
</span><span id="line-859"></span><span>
</span><span id="line-860"></span><span class="hs-operator">====</span><span> </span><span class="hs-identifier">window</span><span>
</span><span id="line-861"></span><span>
</span><span id="line-862"></span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">call</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">suffix</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">regular</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">call</span><span>
</span><span id="line-863"></span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">looks</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">this</span><span class="hs-glyph">:</span><span>
</span><span id="line-864"></span><span class="hs-identifier">functionname</span><span class="hs-special">(</span><span class="hs-identifier">args</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">over</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-identifier">partition</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">ids</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">order</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">orderitems</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-865"></span><span>
</span><span id="line-866"></span><span class="hs-identifier">No</span><span> </span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">explicit</span><span> </span><span class="hs-identifier">frames</span><span> </span><span class="hs-identifier">yet</span><span class="hs-operator">.</span><span>
</span><span id="line-867"></span><span>
</span><span id="line-868"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">add</span><span> </span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">aggregate</span><span> </span><span class="hs-identifier">variations</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">needs</span><span> </span><span class="hs-identifier">some</span><span>
</span><span id="line-869"></span><span class="hs-identifier">changes</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">also</span><span>
</span><span id="line-870"></span><span>
</span><span id="line-871"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#window"><span class="hs-identifier hs-type">window</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-872"></span><span class="hs-operator">&gt;</span><span> </span><span id="window"><span class="annot"><span class="annottext">window :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#window"><span class="hs-identifier hs-var hs-var">window</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-873"></span><span class="hs-operator">&gt;</span><span>   </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;over&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Char -&gt; Parser Char
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var">openParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
</span><a href="#local-6989586621679120632"><span class="hs-identifier hs-var">partitionBy</span></a></span><span>
</span><span id="line-874"></span><span class="hs-operator">&gt;</span><span>   </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var">orderBy</span></a></span><span>
</span><span id="line-875"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec]
      -&gt; [ScalarExpr] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Frame
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Frame)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Frame
</span><a href="#local-6989586621679120631"><span class="hs-identifier hs-var">frameClause</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Frame)
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Frame)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Frame)
-&gt; ([Name]
    -&gt; [ScalarExpr]
    -&gt; [ScalarExpr]
    -&gt; [SortSpec]
    -&gt; Maybe Frame
    -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec]
      -&gt; [ScalarExpr] -&gt; [ScalarExpr] -&gt; [Name] -&gt; ScalarExpr)
forall (f :: * -&gt; *) e a b c d t.
Applicative f =&gt;
f e -&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; t) -&gt; f (d -&gt; c -&gt; b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; [ScalarExpr]
-&gt; [ScalarExpr]
-&gt; [SortSpec]
-&gt; Maybe Frame
-&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#WindowApp"><span class="hs-identifier hs-var">WindowApp</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-876"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-877"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120632"><span class="annot"><span class="annottext">partitionBy :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
</span><a href="#local-6989586621679120632"><span class="hs-identifier hs-var hs-var">partitionBy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;partition&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;by&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-878"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120631"><span class="annot"><span class="annottext">frameClause :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Frame
</span><a href="#local-6989586621679120631"><span class="hs-identifier hs-var hs-var">frameClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-879"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
</span><a href="#local-6989586621679120629"><span class="hs-identifier hs-var">frameRowsRange</span></a></span><span> </span><span class="hs-comment">-- TODO: this 'and' could be an issue</span><span>
</span><span id="line-880"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FrameRows -&gt; Frame)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Frame
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   (FrameRows -&gt; Frame)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FrameRows -&gt; Frame)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;between&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
</span><a href="#local-6989586621679120628"><span class="hs-identifier hs-var">frameLimit</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-881"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FramePos -&gt; FrameRows -&gt; Frame)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FrameRows -&gt; Frame)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;and&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
</span><a href="#local-6989586621679120628"><span class="hs-identifier hs-var">frameLimit</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-882"></span><span class="hs-operator">&gt;</span><span>                             </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; (FrameRows -&gt; FramePos -&gt; FramePos -&gt; Frame)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FramePos -&gt; FrameRows -&gt; Frame)
forall (f :: * -&gt; *) c a b t.
Applicative f =&gt;
f c -&gt; (a -&gt; b -&gt; c -&gt; t) -&gt; f (b -&gt; a -&gt; t)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%24%3E"><span class="hs-operator hs-var">&lt;$$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">FrameRows -&gt; FramePos -&gt; FramePos -&gt; Frame
</span><a href="Language.SQL.SimpleSQL.Syntax.html#FrameBetween"><span class="hs-identifier hs-var">FrameBetween</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-883"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="hs-comment">-- maybe this should still use a b expression</span><span>
</span><span id="line-884"></span><span class="hs-operator">&gt;</span><span>                       </span><span class="hs-comment">-- for consistency</span><span>
</span><span id="line-885"></span><span class="hs-operator">&gt;</span><span>                      </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
</span><a href="#local-6989586621679120628"><span class="hs-identifier hs-var">frameLimit</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FramePos -&gt; FrameRows -&gt; Frame)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FrameRows -&gt; Frame)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">(FramePos -&gt; FrameRows -&gt; Frame)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FramePos -&gt; FrameRows -&gt; Frame)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(FrameRows -&gt; FramePos -&gt; Frame) -&gt; FramePos -&gt; FrameRows -&gt; Frame
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">FrameRows -&gt; FramePos -&gt; Frame
</span><a href="Language.SQL.SimpleSQL.Syntax.html#FrameFrom"><span class="hs-identifier hs-var">FrameFrom</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-886"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120629"><span class="annot"><span class="annottext">frameRowsRange :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
</span><a href="#local-6989586621679120629"><span class="hs-identifier hs-var hs-var">frameRowsRange</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FrameRows
</span><a href="Language.SQL.SimpleSQL.Syntax.html#FrameRows"><span class="hs-identifier hs-var">FrameRows</span></a></span><span> </span><span class="annot"><span class="annottext">FrameRows
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;rows&quot;</span></span><span>
</span><span id="line-887"></span><span class="hs-operator">&gt;</span><span>                      </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">FrameRows
</span><a href="Language.SQL.SimpleSQL.Syntax.html#FrameRange"><span class="hs-identifier hs-var">FrameRange</span></a></span><span> </span><span class="annot"><span class="annottext">FrameRows
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FrameRows
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;range&quot;</span></span><span>
</span><span id="line-888"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120628"><span class="annot"><span class="annottext">frameLimit :: Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
</span><a href="#local-6989586621679120628"><span class="hs-identifier hs-var hs-var">frameLimit</span></a></span></span><span> </span><span id="local-6989586621679120623"><span class="annot"><span class="annottext">useB :: Bool
</span><a href="#local-6989586621679120623"><span class="hs-identifier hs-var">useB</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-889"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FramePos]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-890"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FramePos
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Current"><span class="hs-identifier hs-var">Current</span></a></span><span> </span><span class="annot"><span class="annottext">FramePos
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;current&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;row&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-891"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- todo: create an automatic left factor for stuff like this</span><span>
</span><span id="line-892"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unbounded&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-893"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity FramePos]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FramePos
</span><a href="Language.SQL.SimpleSQL.Syntax.html#UnboundedPreceding"><span class="hs-identifier hs-var">UnboundedPreceding</span></a></span><span> </span><span class="annot"><span class="annottext">FramePos
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;preceding&quot;</span></span><span>
</span><span id="line-894"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FramePos
</span><a href="Language.SQL.SimpleSQL.Syntax.html#UnboundedFollowing"><span class="hs-identifier hs-var">UnboundedFollowing</span></a></span><span> </span><span class="annot"><span class="annottext">FramePos
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;following&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-895"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120623"><span class="hs-identifier hs-var">useB</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExprB"><span class="hs-identifier hs-var">scalarExprB</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-896"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; FramePos)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity FramePos
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ScalarExpr -&gt; FramePos
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Preceding"><span class="hs-identifier hs-var">Preceding</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; FramePos)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; FramePos)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;preceding&quot;</span></span><span>
</span><span id="line-897"></span><span class="hs-operator">&gt;</span><span>                </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; FramePos)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; FramePos)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; FramePos)
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; FramePos
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Following"><span class="hs-identifier hs-var">Following</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; FramePos)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; FramePos)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;following&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-898"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">]</span><span>
</span><span id="line-899"></span><span>
</span><span id="line-900"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">suffixes</span><span>
</span><span id="line-901"></span><span>
</span><span id="line-902"></span><span class="hs-identifier">These</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">generic</span><span> </span><span class="hs-identifier">suffixes</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expr</span><span>
</span><span id="line-903"></span><span>
</span><span id="line-904"></span><span class="hs-operator">===</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span class="hs-keyword">in</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">two</span><span> </span><span class="hs-identifier">variations</span><span class="hs-glyph">:</span><span>
</span><span id="line-907"></span><span class="hs-identifier">a</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">expr0</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">expr1</span><span class="hs-special">,</span><span> </span><span class="hs-operator">...</span><span class="hs-special">)</span><span>
</span><span id="line-908"></span><span class="hs-identifier">a</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">queryexpr</span><span class="hs-special">)</span><span>
</span><span id="line-909"></span><span>
</span><span id="line-910"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#inSuffix"><span class="hs-identifier hs-type">inSuffix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-911"></span><span class="hs-operator">&gt;</span><span> </span><span id="inSuffix"><span class="annot"><span class="annottext">inSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#inSuffix"><span class="hs-identifier hs-var hs-var">inSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-912"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Bool -&gt; InPredValue -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120615"><span class="hs-identifier hs-var">mkIn</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; InPredValue -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (InPredValue -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
</span><a href="#local-6989586621679120614"><span class="hs-identifier hs-var">inty</span></a></span><span>
</span><span id="line-913"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (InPredValue -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity InPredValue]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-914"></span><span class="hs-operator">&gt;</span><span>                      </span><span class="hs-special">[</span><span class="annot"><span class="annottext">QueryExpr -&gt; InPredValue
</span><a href="Language.SQL.SimpleSQL.Syntax.html#InQueryExpr"><span class="hs-identifier hs-var">InQueryExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; InPredValue)
-&gt; Parser QueryExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-915"></span><span class="hs-operator">&gt;</span><span>                      </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[ScalarExpr] -&gt; InPredValue
</span><a href="Language.SQL.SimpleSQL.Syntax.html#InList"><span class="hs-identifier hs-var">InList</span></a></span><span> </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; InPredValue)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InPredValue
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-916"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-917"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120614"><span class="annot"><span class="annottext">inty :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
</span><a href="#local-6989586621679120614"><span class="hs-identifier hs-var hs-var">inty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;in&quot;</span></span><span>
</span><span id="line-918"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;in&quot;</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-919"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120615"><span class="annot"><span class="annottext">mkIn :: Bool -&gt; InPredValue -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120615"><span class="hs-identifier hs-var hs-var">mkIn</span></a></span></span><span> </span><span id="local-6989586621679120611"><span class="annot"><span class="annottext">i :: Bool
</span><a href="#local-6989586621679120611"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679120610"><span class="annot"><span class="annottext">v :: InPredValue
</span><a href="#local-6989586621679120610"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120609"><span class="annot"><span class="annottext">e :: ScalarExpr
</span><a href="#local-6989586621679120609"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; ScalarExpr -&gt; InPredValue -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#In"><span class="hs-identifier hs-var">In</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120611"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120609"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">InPredValue
</span><a href="#local-6989586621679120610"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-920"></span><span>
</span><span id="line-921"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">between</span><span>
</span><span id="line-922"></span><span>
</span><span id="line-923"></span><span class="hs-identifier">between</span><span class="hs-glyph">:</span><span>
</span><span id="line-924"></span><span class="hs-identifier">expr</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-identifier">expr</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">expr</span><span>
</span><span id="line-925"></span><span>
</span><span id="line-926"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">complication</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">second</span><span>
</span><span id="line-927"></span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">ambiguous</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">hit</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">and'</span><span> </span><span class="hs-identifier">whether</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-928"></span><span class="hs-identifier">binary</span><span> </span><span class="hs-identifier">operator</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">part</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">between</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">follows</span><span> </span><span class="hs-identifier">what</span><span>
</span><span id="line-929"></span><span class="hs-identifier">postgres</span><span> </span><span class="hs-identifier">does</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-identifier">across</span><span> </span><span class="hs-identifier">SQL</span><span> </span><span class="hs-identifier">implementations</span><span class="hs-special">,</span><span>
</span><span id="line-930"></span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">that</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">can't</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">binary</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">operator</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">middle</span><span>
</span><span id="line-931"></span><span class="hs-identifier">expression</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-identifier">unless</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">wrapped</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">parens</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">bExpr</span><span>
</span><span id="line-932"></span><span class="hs-identifier">parsing'</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">create</span><span> </span><span class="hs-identifier">alternative</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">which</span><span>
</span><span id="line-933"></span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">identical</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">normal</span><span> </span><span class="hs-identifier">one</span><span> </span><span class="hs-identifier">expect</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">doesn't</span><span> </span><span class="hs-identifier">recognise</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">binary</span><span>
</span><span id="line-934"></span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">operator</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">call</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">scalarExprB</span><span class="hs-operator">.</span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#betweenSuffix"><span class="hs-identifier hs-type">betweenSuffix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-937"></span><span class="hs-operator">&gt;</span><span> </span><span id="betweenSuffix"><span class="annot"><span class="annottext">betweenSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#betweenSuffix"><span class="hs-identifier hs-var hs-var">betweenSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-938"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Name -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120606"><span class="hs-identifier hs-var">makeOp</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; (FilePath -&gt; Name)
-&gt; FilePath
-&gt; ScalarExpr
-&gt; ScalarExpr
-&gt; ScalarExpr
-&gt; ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="#local-6989586621679120605"><span class="hs-identifier hs-var">opName</span></a></span><span>
</span><span id="line-939"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExprB"><span class="hs-identifier hs-var">scalarExprB</span></a></span><span>
</span><span id="line-940"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;and&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExprB"><span class="hs-identifier hs-var">scalarExprB</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-941"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-942"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120605"><span class="annot"><span class="annottext">opName :: Parser FilePath
</span><a href="#local-6989586621679120605"><span class="hs-identifier hs-var hs-var">opName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser FilePath] -&gt; Parser FilePath
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-943"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;between&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;between&quot;</span></span><span>
</span><span id="line-944"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;not between&quot;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser FilePath
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;between&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-945"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120606"><span class="annot"><span class="annottext">makeOp :: Name -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="#local-6989586621679120606"><span class="hs-identifier hs-var hs-var">makeOp</span></a></span></span><span> </span><span id="local-6989586621679120604"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679120604"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679120603"><span class="annot"><span class="annottext">b :: ScalarExpr
</span><a href="#local-6989586621679120603"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679120602"><span class="annot"><span class="annottext">c :: ScalarExpr
</span><a href="#local-6989586621679120602"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120601"><span class="annot"><span class="annottext">a :: ScalarExpr
</span><a href="#local-6989586621679120601"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SpecialOp"><span class="hs-identifier hs-var">SpecialOp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679120604"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120601"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120603"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120602"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-946"></span><span>
</span><span id="line-947"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">quantified</span><span> </span><span class="hs-identifier">comparison</span><span>
</span><span id="line-948"></span><span>
</span><span id="line-949"></span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">select</span><span> </span><span class="hs-operator">*</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span>
</span><span id="line-950"></span><span>
</span><span id="line-951"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#quantifiedComparisonSuffix"><span class="hs-identifier hs-type">quantifiedComparisonSuffix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-952"></span><span class="hs-operator">&gt;</span><span> </span><span id="quantifiedComparisonSuffix"><span class="annot"><span class="annottext">quantifiedComparisonSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#quantifiedComparisonSuffix"><span class="hs-identifier hs-var hs-var">quantifiedComparisonSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-953"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120599"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679120599"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="#local-6989586621679120598"><span class="hs-identifier hs-var">comp</span></a></span><span>
</span><span id="line-954"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120597"><span class="annot"><span class="annottext">CompPredQuantifier
</span><a href="#local-6989586621679120597"><span class="hs-identifier hs-var">cq</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
</span><a href="#local-6989586621679120596"><span class="hs-identifier hs-var">compQuan</span></a></span><span>
</span><span id="line-955"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120595"><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120595"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-956"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((ScalarExpr -&gt; ScalarExpr)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (ScalarExpr -&gt; ScalarExpr))
-&gt; (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120594"><span class="annot"><span class="annottext">v :: ScalarExpr
</span><a href="#local-6989586621679120594"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
-&gt; [Name] -&gt; CompPredQuantifier -&gt; QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#QuantifiedComparison"><span class="hs-identifier hs-var">QuantifiedComparison</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120594"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679120599"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">CompPredQuantifier
</span><a href="#local-6989586621679120597"><span class="hs-identifier hs-var">cq</span></a></span><span> </span><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120595"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-957"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-958"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120598"><span class="annot"><span class="annottext">comp :: Parser Name
</span><a href="#local-6989586621679120598"><span class="hs-identifier hs-var hs-var">comp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; Parser FilePath -&gt; Parser Name
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Parser FilePath] -&gt; Parser FilePath
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(FilePath -&gt; Parser FilePath) -&gt; [FilePath] -&gt; [Parser FilePath]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span>
</span><span id="line-959"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;=&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;&gt;&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;=&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;&gt;&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;&gt;=&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-960"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120596"><span class="annot"><span class="annottext">compQuan :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
</span><a href="#local-6989586621679120596"><span class="hs-identifier hs-var hs-var">compQuan</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   CompPredQuantifier]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-961"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">[</span><span class="annot"><span class="annottext">CompPredQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CPAny"><span class="hs-identifier hs-var">CPAny</span></a></span><span> </span><span class="annot"><span class="annottext">CompPredQuantifier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;any&quot;</span></span><span>
</span><span id="line-962"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">CompPredQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CPSome"><span class="hs-identifier hs-var">CPSome</span></a></span><span> </span><span class="annot"><span class="annottext">CompPredQuantifier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;some&quot;</span></span><span>
</span><span id="line-963"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">CompPredQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CPAll"><span class="hs-identifier hs-var">CPAll</span></a></span><span> </span><span class="annot"><span class="annottext">CompPredQuantifier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CompPredQuantifier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;all&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-964"></span><span>
</span><span id="line-965"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">match</span><span>
</span><span id="line-966"></span><span>
</span><span id="line-967"></span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">match</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span>
</span><span id="line-968"></span><span>
</span><span id="line-969"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#matchPredicateSuffix"><span class="hs-identifier hs-type">matchPredicateSuffix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-970"></span><span class="hs-operator">&gt;</span><span> </span><span id="matchPredicateSuffix"><span class="annot"><span class="annottext">matchPredicateSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#matchPredicateSuffix"><span class="hs-identifier hs-var hs-var">matchPredicateSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-971"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;match&quot;</span></span><span>
</span><span id="line-972"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120588"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120588"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unique&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-973"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120587"><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120587"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-974"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((ScalarExpr -&gt; ScalarExpr)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (ScalarExpr -&gt; ScalarExpr))
-&gt; (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120586"><span class="annot"><span class="annottext">v :: ScalarExpr
</span><a href="#local-6989586621679120586"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Bool -&gt; QueryExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Match"><span class="hs-identifier hs-var">Match</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120586"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120588"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120587"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-975"></span><span>
</span><span id="line-976"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">array</span><span> </span><span class="hs-identifier">subscript</span><span>
</span><span id="line-977"></span><span>
</span><span id="line-978"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#arraySuffix"><span class="hs-identifier hs-type">arraySuffix</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-979"></span><span class="hs-operator">&gt;</span><span> </span><span id="arraySuffix"><span class="annot"><span class="annottext">arraySuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#arraySuffix"><span class="hs-identifier hs-var hs-var">arraySuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-980"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120583"><span class="annot"><span class="annottext">[ScalarExpr]
</span><a href="#local-6989586621679120583"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-981"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((ScalarExpr -&gt; ScalarExpr)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (ScalarExpr -&gt; ScalarExpr))
-&gt; (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120582"><span class="annot"><span class="annottext">v :: ScalarExpr
</span><a href="#local-6989586621679120582"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; [ScalarExpr] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Array"><span class="hs-identifier hs-var">Array</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120582"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">[ScalarExpr]
</span><a href="#local-6989586621679120583"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-982"></span><span>
</span><span id="line-983"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">escape</span><span>
</span><span id="line-984"></span><span>
</span><span id="line-985"></span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">going</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">really</span><span> </span><span class="hs-identifier">difficult</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">arbitrary</span><span> </span><span class="hs-identifier">character</span><span>
</span><span id="line-986"></span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">escape</span><span> </span><span class="hs-identifier">now</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">separate</span><span> </span><span class="hs-identifier">lexer</span><span> </span><span class="hs-operator">...</span><span>
</span><span id="line-987"></span><span>
</span><span id="line-988"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">needs</span><span> </span><span class="hs-identifier">fixing</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Escape</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">part</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">nodes</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-989"></span><span class="hs-identifier">separate</span><span> </span><span class="hs-identifier">suffix</span><span class="hs-operator">.</span><span>
</span><span id="line-990"></span><span>
</span><span id="line-991"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-comment">{-escapeSuffix :: Parser (ScalarExpr -&gt; ScalarExpr)
&gt; escapeSuffix = do
&gt;     ctor &lt;- choice
&gt;             [Escape &lt;$ keyword_ &quot;escape&quot;
&gt;             ,UEscape &lt;$ keyword_ &quot;uescape&quot;]
&gt;     c &lt;- escapeChar
&gt;     pure $ \v -&gt; ctor v c
&gt;   where
&gt;     escapeChar :: Parser Char
&gt;     escapeChar = (identifierTok [] Nothing &lt;|&gt; symbolTok Nothing) &gt;&gt;= oneOnly
&gt;     oneOnly :: String -&gt; Parser Char
&gt;     oneOnly c = case c of
&gt;                    [c'] -&gt; return c'
&gt;                    _ -&gt; fail &quot;escape char must be single char&quot;
&gt; -}</span><span>
</span><span id="line-1006"></span><span>
</span><span id="line-1007"></span><span class="hs-operator">===</span><span> </span><span class="hs-identifier">collate</span><span>
</span><span id="line-1008"></span><span>
</span><span id="line-1009"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#collateSuffix"><span class="hs-identifier hs-type">collateSuffix</span></a></span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1010"></span><span class="hs-operator">&gt;</span><span> </span><span id="collateSuffix"><span class="annot"><span class="annottext">collateSuffix :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#collateSuffix"><span class="hs-identifier hs-var hs-var">collateSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1011"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;collate&quot;</span></span><span>
</span><span id="line-1012"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120580"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120580"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1013"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((ScalarExpr -&gt; ScalarExpr)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (ScalarExpr -&gt; ScalarExpr))
-&gt; (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679120579"><span class="annot"><span class="annottext">v :: ScalarExpr
</span><a href="#local-6989586621679120579"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; [Name] -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Collate"><span class="hs-identifier hs-var">Collate</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120579"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120580"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-1014"></span><span>
</span><span id="line-1015"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">odbc</span><span> </span><span class="hs-identifier">syntax</span><span>
</span><span id="line-1016"></span><span>
</span><span id="line-1017"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">supports</span><span> </span><span class="hs-identifier">three</span><span> </span><span class="hs-identifier">kinds</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">odbc</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">two</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">are</span><span>
</span><span id="line-1018"></span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expressions</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">variation</span><span> </span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">joins</span><span class="hs-special">)</span><span>
</span><span id="line-1019"></span><span>
</span><span id="line-1020"></span><span>
</span><span id="line-1021"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#odbcExpr"><span class="hs-identifier hs-type">odbcExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1022"></span><span class="hs-operator">&gt;</span><span> </span><span id="odbcExpr"><span class="annot"><span class="annottext">odbcExpr :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#odbcExpr"><span class="hs-identifier hs-var hs-var">odbcExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; Parser FilePath -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u open close a.
Stream s m t =&gt;
ParsecT s u m open
-&gt; ParsecT s u m close -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">between</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;{&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;}&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1023"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120576"><span class="hs-identifier hs-var">odbcTimeLit</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120575"><span class="hs-identifier hs-var">odbcFunc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1024"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1025"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120576"><span class="annot"><span class="annottext">odbcTimeLit :: Parser ScalarExpr
</span><a href="#local-6989586621679120576"><span class="hs-identifier hs-var hs-var">odbcTimeLit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1026"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">OdbcLiteralType -&gt; FilePath -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#OdbcLiteral"><span class="hs-identifier hs-var">OdbcLiteral</span></a></span><span> </span><span class="annot"><span class="annottext">(OdbcLiteralType -&gt; FilePath -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath -&gt; ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">OdbcLiteralType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#OLDate"><span class="hs-identifier hs-var">OLDate</span></a></span><span> </span><span class="annot"><span class="annottext">OdbcLiteralType
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;d&quot;</span></span><span>
</span><span id="line-1027"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">OdbcLiteralType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#OLTime"><span class="hs-identifier hs-var">OLTime</span></a></span><span> </span><span class="annot"><span class="annottext">OdbcLiteralType
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;t&quot;</span></span><span>
</span><span id="line-1028"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">OdbcLiteralType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#OLTimestamp"><span class="hs-identifier hs-var">OLTimestamp</span></a></span><span> </span><span class="annot"><span class="annottext">OdbcLiteralType
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity OdbcLiteralType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;ts&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1029"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath -&gt; ScalarExpr)
-&gt; Parser FilePath -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-var">singleQuotesOnlyStringTok</span></a></span><span>
</span><span id="line-1030"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: this parser is too general, the expr part</span><span>
</span><span id="line-1031"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- should be only a function call (from a whitelist of functions)</span><span>
</span><span id="line-1032"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- or the extract operator</span><span>
</span><span id="line-1033"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120575"><span class="annot"><span class="annottext">odbcFunc :: Parser ScalarExpr
</span><a href="#local-6989586621679120575"><span class="hs-identifier hs-var hs-var">odbcFunc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#OdbcFunc"><span class="hs-identifier hs-var">OdbcFunc</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;fn&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1034"></span><span>
</span><span id="line-1035"></span><span class="hs-operator">==</span><span>  </span><span class="hs-identifier">operators</span><span>
</span><span id="line-1036"></span><span>
</span><span id="line-1037"></span><span class="hs-identifier">The</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">regular'</span><span> </span><span class="hs-identifier">operators</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">abstract</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">are</span><span>
</span><span id="line-1038"></span><span class="hs-identifier">unary</span><span> </span><span class="hs-identifier">prefix</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unary</span><span> </span><span class="hs-identifier">postfix</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">binary</span><span> </span><span class="hs-keyword">infix</span><span> </span><span class="hs-identifier">operators</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">operators</span><span>
</span><span id="line-1039"></span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">symbols</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">+</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">single</span><span> </span><span class="hs-identifier">keywords</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">multiple</span><span> </span><span class="hs-identifier">keywords</span><span>
</span><span id="line-1040"></span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">similar</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-1041"></span><span>
</span><span id="line-1042"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">carefully</span><span> </span><span class="hs-identifier">review</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">precedences</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">associativities</span><span class="hs-operator">.</span><span>
</span><span id="line-1043"></span><span>
</span><span id="line-1044"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">completely</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">I</span><span> </span><span class="hs-identifier">think</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">need</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">parse</span><span>
</span><span id="line-1045"></span><span class="hs-identifier">without</span><span> </span><span class="hs-identifier">precedence</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">associativity</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">up</span><span> </span><span class="hs-identifier">afterwards</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">since</span><span> </span><span class="hs-identifier">SQL</span><span>
</span><span id="line-1046"></span><span class="hs-identifier">syntax</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">way</span><span> </span><span class="hs-identifier">too</span><span> </span><span class="hs-identifier">messy</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">possible</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">avoid</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">we</span><span>
</span><span id="line-1047"></span><span class="hs-identifier">wanted</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">avoid</span><span> </span><span class="hs-identifier">extensibility</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">concerned</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">error</span><span>
</span><span id="line-1048"></span><span class="hs-identifier">messages</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">both</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">these</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">too</span><span> </span><span class="hs-identifier">important</span><span class="hs-operator">.</span><span>
</span><span id="line-1049"></span><span>
</span><span id="line-1050"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#opTable"><span class="hs-identifier hs-type">opTable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">E.Operator</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Identity</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1051"></span><span class="hs-operator">&gt;</span><span> </span><span id="opTable"><span class="annot"><span class="annottext">opTable :: Bool
-&gt; [[Operator
       [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]]
</span><a href="Language.SQL.SimpleSQL.Parse.html#opTable"><span class="hs-identifier hs-var hs-var">opTable</span></a></span></span><span> </span><span id="local-6989586621679120566"><span class="annot"><span class="annottext">bExpr :: Bool
</span><a href="#local-6989586621679120566"><span class="hs-identifier hs-var">bExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1052"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">[</span><span class="hs-comment">-- parse match and quantified comparisons as postfix ops</span><span>
</span><span id="line-1053"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-comment">-- todo: left factor the quantified comparison with regular</span><span>
</span><span id="line-1054"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-comment">-- binary comparison, somehow</span><span>
</span><span id="line-1055"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Postfix</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   (ScalarExpr -&gt; ScalarExpr)
 -&gt; Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#quantifiedComparisonSuffix"><span class="hs-identifier hs-var">quantifiedComparisonSuffix</span></a></span><span>
</span><span id="line-1056"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Postfix</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#matchPredicateSuffix"><span class="hs-identifier hs-var">matchPredicateSuffix</span></a></span><span>
</span><span id="line-1057"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">]</span><span>
</span><span id="line-1058"></span><span>
</span><span id="line-1059"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;.&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1060"></span><span>
</span><span id="line-1061"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120562"><span class="hs-identifier hs-var">postfix'</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#arraySuffix"><span class="hs-identifier hs-var">arraySuffix</span></a></span><span>
</span><span id="line-1062"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120562"><span class="hs-identifier hs-var">postfix'</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#collateSuffix"><span class="hs-identifier hs-var">collateSuffix</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1063"></span><span>
</span><span id="line-1064"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120561"><span class="hs-identifier hs-var">prefixSym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;+&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120561"><span class="hs-identifier hs-var">prefixSym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1065"></span><span>
</span><span id="line-1066"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;^&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1067"></span><span>
</span><span id="line-1068"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;*&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span>
</span><span id="line-1069"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;/&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span>
</span><span id="line-1070"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;%&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1071"></span><span>
</span><span id="line-1072"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;+&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span>
</span><span id="line-1073"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1074"></span><span>
</span><span id="line-1075"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;||&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span>
</span><span id="line-1076"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120561"><span class="hs-identifier hs-var">prefixSym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;~&quot;</span></span><span>
</span><span id="line-1077"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&amp;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span>
</span><span id="line-1078"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;|&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span class="hs-special">]</span><span>
</span><span id="line-1079"></span><span>
</span><span id="line-1080"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120559"><span class="hs-identifier hs-var">binaryKeyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;overlaps&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span class="hs-special">]</span><span>
</span><span id="line-1081"></span><span>
</span><span id="line-1082"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120559"><span class="hs-identifier hs-var">binaryKeyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;like&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1083"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- have to use try with inSuffix because of a conflict</span><span>
</span><span id="line-1084"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- with 'in' in position function, and not between</span><span>
</span><span id="line-1085"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- between also has a try in it to deal with 'not'</span><span>
</span><span id="line-1086"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- ambiguity</span><span>
</span><span id="line-1087"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Postfix</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   (ScalarExpr -&gt; ScalarExpr)
 -&gt; Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr)
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#inSuffix"><span class="hs-identifier hs-var">inSuffix</span></a></span><span>
</span><span id="line-1088"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Postfix</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#betweenSuffix"><span class="hs-identifier hs-var">betweenSuffix</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1089"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- todo: figure out where to put the try?</span><span>
</span><span id="line-1090"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">[Operator
   [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *).
ParsecT s u m [FilePath] -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120557"><span class="hs-identifier hs-var">binaryKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
 -&gt; Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span>
</span><span id="line-1091"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;not like&quot;</span></span><span>
</span><span id="line-1092"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is similar to&quot;</span></span><span>
</span><span id="line-1093"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not similar to&quot;</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1094"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">[Operator
   [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Operator
  [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120556"><span class="hs-identifier hs-var">multisetBinOp</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1095"></span><span>
</span><span id="line-1096"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1097"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&gt;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1098"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&gt;=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1099"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1100"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;!=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span>
</span><span id="line-1101"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;&lt;&gt;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span>
</span><span id="line-1102"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var">binarySym</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocRight</span></span><span class="hs-special">]</span><span>
</span><span id="line-1103"></span><span>
</span><span id="line-1104"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s (m :: * -&gt; *) t u.
Stream s m t =&gt;
ParsecT s u m [FilePath] -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120555"><span class="hs-identifier hs-var">postfixKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
 -&gt; Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span>
</span><span id="line-1105"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;is null&quot;</span></span><span>
</span><span id="line-1106"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not null&quot;</span></span><span>
</span><span id="line-1107"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is true&quot;</span></span><span>
</span><span id="line-1108"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not true&quot;</span></span><span>
</span><span id="line-1109"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is false&quot;</span></span><span>
</span><span id="line-1110"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not false&quot;</span></span><span>
</span><span id="line-1111"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is unknown&quot;</span></span><span>
</span><span id="line-1112"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not unknown&quot;</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1113"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">[Operator
   [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
-&gt; [Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *).
ParsecT s u m [FilePath] -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120557"><span class="hs-identifier hs-var">binaryKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
 -&gt; Operator
      [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span>
</span><span id="line-1114"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;is distinct from&quot;</span></span><span>
</span><span id="line-1115"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;is not distinct from&quot;</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1116"></span><span>
</span><span id="line-1117"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120554"><span class="hs-identifier hs-var">prefixKeyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1118"></span><span>
</span><span id="line-1119"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120566"><span class="hs-identifier hs-var">bExpr</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120559"><span class="hs-identifier hs-var">binaryKeyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;and&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1120"></span><span>
</span><span id="line-1121"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120559"><span class="hs-identifier hs-var">binaryKeyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;or&quot;</span></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span class="hs-special">]</span><span>
</span><span id="line-1122"></span><span>
</span><span id="line-1123"></span><span class="hs-operator">&gt;</span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-1124"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1125"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120564"><span class="annot"><span class="annottext">binarySym :: FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120564"><span class="hs-identifier hs-var hs-var">binarySym</span></a></span></span><span> </span><span id="local-6989586621679120553"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120553"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679120552"><span class="annot"><span class="annottext">assoc :: Assoc
</span><a href="#local-6989586621679120552"><span class="hs-identifier hs-var">assoc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; Assoc -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120551"><span class="hs-identifier hs-var">binary</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-var">symbol_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120553"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120553"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><a href="#local-6989586621679120552"><span class="hs-identifier hs-var">assoc</span></a></span><span>
</span><span id="line-1126"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120559"><span class="annot"><span class="annottext">binaryKeyword :: FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120559"><span class="hs-identifier hs-var hs-var">binaryKeyword</span></a></span></span><span> </span><span id="local-6989586621679120550"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120550"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679120549"><span class="annot"><span class="annottext">assoc :: Assoc
</span><a href="#local-6989586621679120549"><span class="hs-identifier hs-var">assoc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; FilePath
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; Assoc -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120551"><span class="hs-identifier hs-var">binary</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120550"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120550"><span class="hs-identifier hs-var">nm</span></a></span><span> </span><span class="annot"><span class="annottext">Assoc
</span><a href="#local-6989586621679120549"><span class="hs-identifier hs-var">assoc</span></a></span><span>
</span><span id="line-1127"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120557"><span class="annot"><span class="annottext">binaryKeywords :: ParsecT s u m [FilePath] -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120557"><span class="hs-identifier hs-var hs-var">binaryKeywords</span></a></span></span><span> </span><span id="local-6989586621679120548"><span class="annot"><span class="annottext">p :: ParsecT s u m [FilePath]
</span><a href="#local-6989586621679120548"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1128"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Assoc -&gt; Operator s u m ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a -&gt; a) -&gt; Assoc -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Infix</span></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">do</span><span>
</span><span id="line-1129"></span><span class="hs-operator">&gt;</span><span>                  </span><span id="local-6989586621679120546"><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120546"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT s u m [FilePath] -&gt; ParsecT s u m [FilePath]
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m [FilePath]
</span><a href="#local-6989586621679120548"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1130"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120545"><span class="annot"><span class="annottext">a :: ScalarExpr
</span><a href="#local-6989586621679120545"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679120544"><span class="annot"><span class="annottext">b :: ScalarExpr
</span><a href="#local-6989586621679120544"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; [Name] -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#BinOp"><span class="hs-identifier hs-var">BinOp</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120545"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; FilePath
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120546"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120544"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1131"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocNone</span></span><span>
</span><span id="line-1132"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120555"><span class="annot"><span class="annottext">postfixKeywords :: ParsecT s u m [FilePath] -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120555"><span class="hs-identifier hs-var hs-var">postfixKeywords</span></a></span></span><span> </span><span id="local-6989586621679120542"><span class="annot"><span class="annottext">p :: ParsecT s u m [FilePath]
</span><a href="#local-6989586621679120542"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1133"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><span class="annottext">ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator s u m ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120562"><span class="hs-identifier hs-var">postfix'</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
 -&gt; Operator s u m ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator s u m ScalarExpr
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1134"></span><span class="hs-operator">&gt;</span><span>           </span><span id="local-6989586621679120541"><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120541"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT s u m [FilePath] -&gt; ParsecT s u m [FilePath]
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m [FilePath]
</span><a href="#local-6989586621679120542"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1135"></span><span class="hs-operator">&gt;</span><span>           </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">((ScalarExpr -&gt; ScalarExpr)
 -&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr))
-&gt; (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PostfixOp"><span class="hs-identifier hs-var">PostfixOp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Name) -&gt; FilePath -&gt; Name
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; FilePath
</span><span class="hs-identifier hs-var">unwords</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120541"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1136"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120551"><span class="annot"><span class="annottext">binary :: ParsecT s u m a -&gt; FilePath -&gt; Assoc -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120551"><span class="hs-identifier hs-var hs-var">binary</span></a></span></span><span> </span><span id="local-6989586621679120539"><span class="annot"><span class="annottext">p :: ParsecT s u m a
</span><a href="#local-6989586621679120539"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679120538"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120538"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679120537"><span class="annot"><span class="annottext">assoc :: Assoc
</span><a href="#local-6989586621679120537"><span class="hs-identifier hs-var">assoc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1137"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><span class="annottext">ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Assoc -&gt; Operator s u m ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a -&gt; a) -&gt; Assoc -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Infix</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT s u m a
</span><a href="#local-6989586621679120539"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m a
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120536"><span class="annot"><span class="annottext">a :: ScalarExpr
</span><a href="#local-6989586621679120536"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679120535"><span class="annot"><span class="annottext">b :: ScalarExpr
</span><a href="#local-6989586621679120535"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; [Name] -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#BinOp"><span class="hs-identifier hs-var">BinOp</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120536"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120538"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120535"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Assoc
</span><a href="#local-6989586621679120537"><span class="hs-identifier hs-var">assoc</span></a></span><span>
</span><span id="line-1138"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120556"><span class="annot"><span class="annottext">multisetBinOp :: Operator
  [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120556"><span class="hs-identifier hs-var hs-var">multisetBinOp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; Assoc
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a -&gt; a) -&gt; Assoc -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Infix</span></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">do</span><span>
</span><span id="line-1139"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;multiset&quot;</span></span><span>
</span><span id="line-1140"></span><span class="hs-operator">&gt;</span><span>         </span><span id="local-6989586621679120534"><span class="annot"><span class="annottext">SetOperatorName
</span><a href="#local-6989586621679120534"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Union"><span class="hs-identifier hs-var">Union</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;union&quot;</span></span><span>
</span><span id="line-1141"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Intersect"><span class="hs-identifier hs-var">Intersect</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;intersect&quot;</span></span><span>
</span><span id="line-1142"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Except"><span class="hs-identifier hs-var">Except</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;except&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1143"></span><span class="hs-operator">&gt;</span><span>         </span><span id="local-6989586621679120530"><span class="annot"><span class="annottext">SetQuantifier
</span><a href="#local-6989586621679120530"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">SetQuantifier -&gt; Parser SetQuantifier -&gt; Parser SetQuantifier
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SQDefault"><span class="hs-identifier hs-var">SQDefault</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-var">duplicates</span></a></span><span>
</span><span id="line-1144"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120529"><span class="annot"><span class="annottext">a :: ScalarExpr
</span><a href="#local-6989586621679120529"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679120528"><span class="annot"><span class="annottext">b :: ScalarExpr
</span><a href="#local-6989586621679120528"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ScalarExpr
-&gt; SetOperatorName -&gt; SetQuantifier -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MultisetBinOp"><span class="hs-identifier hs-var">MultisetBinOp</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120529"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="#local-6989586621679120534"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="#local-6989586621679120530"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">ScalarExpr
</span><a href="#local-6989586621679120528"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1145"></span><span class="hs-operator">&gt;</span><span>           </span><span class="annot"><span class="annottext">Assoc
</span><span class="hs-identifier hs-var">E.AssocLeft</span></span><span>
</span><span id="line-1146"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120554"><span class="annot"><span class="annottext">prefixKeyword :: FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120554"><span class="hs-identifier hs-var hs-var">prefixKeyword</span></a></span></span><span> </span><span id="local-6989586621679120526"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120526"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; FilePath -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120525"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120526"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120526"><span class="hs-identifier hs-var">nm</span></a></span><span>
</span><span id="line-1147"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120561"><span class="annot"><span class="annottext">prefixSym :: FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
</span><a href="#local-6989586621679120561"><span class="hs-identifier hs-var hs-var">prefixSym</span></a></span></span><span> </span><span id="local-6989586621679120524"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120524"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; FilePath
-&gt; Operator
     [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; FilePath -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120525"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-var">symbol_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120524"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120524"><span class="hs-identifier hs-var">nm</span></a></span><span>
</span><span id="line-1148"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120525"><span class="annot"><span class="annottext">prefix :: ParsecT s u m a -&gt; FilePath -&gt; Operator s u m ScalarExpr
</span><a href="#local-6989586621679120525"><span class="hs-identifier hs-var hs-var">prefix</span></a></span></span><span> </span><span id="local-6989586621679120523"><span class="annot"><span class="annottext">p :: ParsecT s u m a
</span><a href="#local-6989586621679120523"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679120522"><span class="annot"><span class="annottext">nm :: FilePath
</span><a href="#local-6989586621679120522"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
-&gt; Operator s u m ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120521"><span class="hs-identifier hs-var">prefix'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT s u m a
</span><a href="#local-6989586621679120523"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m a
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ScalarExpr)
-&gt; ParsecT s u m (ScalarExpr -&gt; ScalarExpr)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr -&gt; ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrefixOp"><span class="hs-identifier hs-var">PrefixOp</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath) -&gt; FilePath -&gt; Name
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-var">Name</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120522"><span class="hs-identifier hs-var">nm</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1149"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- hack from here</span><span>
</span><span id="line-1150"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- http://stackoverflow.com/questions/10475337/parsec-expr-repeated-prefix-postfix-operator-not-supported</span><span>
</span><span id="line-1151"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- not implemented properly yet</span><span>
</span><span id="line-1152"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- I don't think this will be enough for all cases</span><span>
</span><span id="line-1153"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- at least it works for 'not not a'</span><span>
</span><span id="line-1154"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- ok: &quot;x is not true is not true&quot;</span><span>
</span><span id="line-1155"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- no work: &quot;x is not true is not null&quot;</span><span>
</span><span id="line-1156"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120521"><span class="annot"><span class="annottext">prefix' :: ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120521"><span class="hs-identifier hs-var hs-var">prefix'</span></a></span></span><span>  </span><span id="local-6989586621679120519"><span class="annot"><span class="annottext">p :: ParsecT s u m (a -&gt; a)
</span><a href="#local-6989586621679120519"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Prefix</span></span><span>  </span><span class="annot"><span class="annottext">(ParsecT s u m (a -&gt; a) -&gt; Operator s u m a)
-&gt; (ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
    -&gt; ParsecT s u m (a -&gt; a))
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; Operator s u m a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; ParsecT s u m (a -&gt; a)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (a -&gt; a -&gt; a) -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">chainl1</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a)
</span><a href="#local-6989586621679120519"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
 -&gt; Operator s u m a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; Operator s u m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>       </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">(.)</span></span><span>
</span><span id="line-1157"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120562"><span class="annot"><span class="annottext">postfix' :: ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><a href="#local-6989586621679120562"><span class="hs-identifier hs-var hs-var">postfix'</span></a></span></span><span> </span><span id="local-6989586621679120517"><span class="annot"><span class="annottext">p :: ParsecT s u m (a -&gt; a)
</span><a href="#local-6989586621679120517"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
forall s u (m :: * -&gt; *) a.
ParsecT s u m (a -&gt; a) -&gt; Operator s u m a
</span><span class="hs-identifier hs-var">E.Postfix</span></span><span> </span><span class="annot"><span class="annottext">(ParsecT s u m (a -&gt; a) -&gt; Operator s u m a)
-&gt; (ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
    -&gt; ParsecT s u m (a -&gt; a))
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; Operator s u m a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; ParsecT s u m (a -&gt; a)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (a -&gt; a -&gt; a) -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">chainl1</span></span><span> </span><span class="annot"><span class="annottext">ParsecT s u m (a -&gt; a)
</span><a href="#local-6989586621679120517"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">(ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
 -&gt; Operator s u m a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; Operator s u m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
-&gt; ParsecT s u m ((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a) -&gt; (a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; (a -&gt; a) -&gt; a -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">(.)</span></span><span class="hs-special">)</span><span>
</span><span id="line-1158"></span><span>
</span><span id="line-1159"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">top</span><span> </span><span class="hs-identifier">level</span><span>
</span><span id="line-1160"></span><span>
</span><span id="line-1161"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">parses</span><span> </span><span class="hs-identifier">most</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">exprs</span><span class="hs-operator">.</span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">order</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">parsers</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">use</span><span>
</span><span id="line-1162"></span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">carefully</span><span> </span><span class="hs-identifier">done</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">make</span><span> </span><span class="hs-identifier">everything</span><span> </span><span class="hs-identifier">work</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">little</span><span>
</span><span id="line-1163"></span><span class="hs-identifier">fragile</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">could</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">least</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">heavy</span><span> </span><span class="hs-identifier">explanation</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Update</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">the</span><span>
</span><span id="line-1164"></span><span class="hs-special">'</span><span class="hs-identifier">try's</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">migrated</span><span> </span><span class="hs-identifier">into</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">individual</span><span> </span><span class="hs-identifier">parsers</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">they</span><span> </span><span class="hs-identifier">still</span><span> </span><span class="hs-identifier">need</span><span>
</span><span id="line-1165"></span><span class="hs-identifier">documenting</span><span class="hs-operator">/</span><span class="hs-identifier">fixing</span><span class="hs-operator">.</span><span>
</span><span id="line-1166"></span><span>
</span><span id="line-1167"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-type">scalarExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1168"></span><span class="hs-operator">&gt;</span><span> </span><span id="scalarExpr"><span class="annot"><span class="annottext">scalarExpr :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var hs-var">scalarExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[Operator
    [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]]
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
OperatorTable s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">E.buildExpressionParser</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
-&gt; [[Operator
       [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]]
</span><a href="Language.SQL.SimpleSQL.Parse.html#opTable"><span class="hs-identifier hs-var">opTable</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#term"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-1169"></span><span>
</span><span id="line-1170"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#term"><span class="hs-identifier hs-type">term</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1171"></span><span class="hs-operator">&gt;</span><span> </span><span id="term"><span class="annot"><span class="annottext">term :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#term"><span class="hs-identifier hs-var hs-var">term</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser ScalarExpr] -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#simpleLiteral"><span class="hs-identifier hs-var">simpleLiteral</span></a></span><span>
</span><span id="line-1172"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parameter"><span class="hs-identifier hs-var">parameter</span></a></span><span>
</span><span id="line-1173"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#positionalArg"><span class="hs-identifier hs-var">positionalArg</span></a></span><span>
</span><span id="line-1174"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#star"><span class="hs-identifier hs-var">star</span></a></span><span>
</span><span id="line-1175"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#parensExpr"><span class="hs-identifier hs-var">parensExpr</span></a></span><span>
</span><span id="line-1176"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#caseExpr"><span class="hs-identifier hs-var">caseExpr</span></a></span><span>
</span><span id="line-1177"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#cast"><span class="hs-identifier hs-var">cast</span></a></span><span>
</span><span id="line-1178"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#arrayCtor"><span class="hs-identifier hs-var">arrayCtor</span></a></span><span>
</span><span id="line-1179"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#multisetCtor"><span class="hs-identifier hs-var">multisetCtor</span></a></span><span>
</span><span id="line-1180"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#nextValueFor"><span class="hs-identifier hs-var">nextValueFor</span></a></span><span>
</span><span id="line-1181"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#subquery"><span class="hs-identifier hs-var">subquery</span></a></span><span>
</span><span id="line-1182"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#intervalLit"><span class="hs-identifier hs-var">intervalLit</span></a></span><span>
</span><span id="line-1183"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#specialOpKs"><span class="hs-identifier hs-var">specialOpKs</span></a></span><span>
</span><span id="line-1184"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#idenExpr"><span class="hs-identifier hs-var">idenExpr</span></a></span><span>
</span><span id="line-1185"></span><span class="hs-operator">&gt;</span><span>               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#odbcExpr"><span class="hs-identifier hs-var">odbcExpr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1186"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; FilePath -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;scalar expression&quot;</span></span><span>
</span><span id="line-1187"></span><span>
</span><span id="line-1188"></span><span class="hs-identifier">expose</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">window</span><span> </span><span class="hs-identifier">frame</span><span> </span><span class="hs-identifier">clause</span><span> </span><span class="hs-identifier">range</span><span> </span><span class="hs-identifier">between</span><span>
</span><span id="line-1189"></span><span>
</span><span id="line-1190"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#scalarExprB"><span class="hs-identifier hs-type">scalarExprB</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1191"></span><span class="hs-operator">&gt;</span><span> </span><span id="scalarExprB"><span class="annot"><span class="annottext">scalarExprB :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExprB"><span class="hs-identifier hs-var hs-var">scalarExprB</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[Operator
    [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]]
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
OperatorTable s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">E.buildExpressionParser</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
-&gt; [[Operator
       [((FilePath, Int, Int), Token)] Dialect Identity ScalarExpr]]
</span><a href="Language.SQL.SimpleSQL.Parse.html#opTable"><span class="hs-identifier hs-var">opTable</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#term"><span class="hs-identifier hs-var">term</span></a></span><span>
</span><span id="line-1192"></span><span>
</span><span id="line-1193"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">helper</span><span> </span><span class="hs-identifier">parsers</span><span>
</span><span id="line-1194"></span><span>
</span><span id="line-1195"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-identifier">literals</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">interval</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">names</span><span class="hs-operator">.</span><span>
</span><span id="line-1196"></span><span>
</span><span id="line-1197"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#intervalQualifier"><span class="hs-identifier hs-type">intervalQualifier</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#IntervalTypeField"><span class="hs-identifier hs-type">IntervalTypeField</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#IntervalTypeField"><span class="hs-identifier hs-type">IntervalTypeField</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1198"></span><span class="hs-operator">&gt;</span><span> </span><span id="intervalQualifier"><span class="annot"><span class="annottext">intervalQualifier :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (IntervalTypeField, Maybe IntervalTypeField)
</span><a href="Language.SQL.SimpleSQL.Parse.html#intervalQualifier"><span class="hs-identifier hs-var hs-var">intervalQualifier</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1199"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(IntervalTypeField
 -&gt; Maybe IntervalTypeField
 -&gt; (IntervalTypeField, Maybe IntervalTypeField))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe IntervalTypeField
      -&gt; (IntervalTypeField, Maybe IntervalTypeField))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
</span><a href="#local-6989586621679120514"><span class="hs-identifier hs-var">intervalField</span></a></span><span>
</span><span id="line-1200"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe IntervalTypeField
   -&gt; (IntervalTypeField, Maybe IntervalTypeField))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe IntervalTypeField)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (IntervalTypeField, Maybe IntervalTypeField)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe IntervalTypeField)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;to&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
</span><a href="#local-6989586621679120514"><span class="hs-identifier hs-var">intervalField</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1201"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1202"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120514"><span class="annot"><span class="annottext">intervalField :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
</span><a href="#local-6989586621679120514"><span class="hs-identifier hs-var hs-var">intervalField</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1203"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe (Integer, Maybe Integer) -&gt; IntervalTypeField
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Itf"><span class="hs-identifier hs-var">Itf</span></a></span><span>
</span><span id="line-1204"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(FilePath -&gt; Maybe (Integer, Maybe Integer) -&gt; IntervalTypeField)
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (Integer, Maybe Integer) -&gt; IntervalTypeField)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#datetimeField"><span class="hs-identifier hs-var">datetimeField</span></a></span><span>
</span><span id="line-1205"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe (Integer, Maybe Integer) -&gt; IntervalTypeField)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (Integer, Maybe Integer))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IntervalTypeField
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer, Maybe Integer)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (Integer, Maybe Integer))
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span>
</span><span id="line-1206"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer, Maybe Integer)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer, Maybe Integer)
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; Maybe Integer -&gt; (Integer, Maybe Integer))
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Integer -&gt; (Integer, Maybe Integer))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span>
</span><span id="line-1207"></span><span class="hs-operator">&gt;</span><span>                          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Integer -&gt; (Integer, Maybe Integer))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer, Maybe Integer)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1208"></span><span>
</span><span id="line-1209"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">extract</span><span> </span><span class="hs-identifier">also</span><span>
</span><span id="line-1210"></span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-keyword">data</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">datetime</span><span> </span><span class="hs-identifier">field</span><span class="hs-operator">?</span><span>
</span><span id="line-1211"></span><span>
</span><span id="line-1212"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#datetimeField"><span class="hs-identifier hs-type">datetimeField</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1213"></span><span class="hs-operator">&gt;</span><span> </span><span id="datetimeField"><span class="annot"><span class="annottext">datetimeField :: Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#datetimeField"><span class="hs-identifier hs-var hs-var">datetimeField</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser FilePath] -&gt; Parser FilePath
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(FilePath -&gt; Parser FilePath) -&gt; [FilePath] -&gt; [Parser FilePath]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;year&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;month&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;day&quot;</span></span><span>
</span><span id="line-1214"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;hour&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;minute&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;second&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1215"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">Parser FilePath -&gt; FilePath -&gt; Parser FilePath
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;datetime field&quot;</span></span><span>
</span><span id="line-1216"></span><span>
</span><span id="line-1217"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">multiset</span><span> </span><span class="hs-identifier">operations</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">scalar</span><span> </span><span class="hs-identifier">expr</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">selects</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expr</span><span class="hs-special">)</span><span>
</span><span id="line-1218"></span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">set</span><span> </span><span class="hs-identifier">operations</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expr</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-1219"></span><span>
</span><span id="line-1220"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-type">duplicates</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#SetQuantifier"><span class="hs-identifier hs-type">SetQuantifier</span></a></span><span>
</span><span id="line-1221"></span><span class="hs-operator">&gt;</span><span> </span><span id="duplicates"><span class="annot"><span class="annottext">duplicates :: Parser SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-var hs-var">duplicates</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1222"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Parser SetQuantifier] -&gt; Parser SetQuantifier
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#All"><span class="hs-identifier hs-var">All</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser SetQuantifier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;all&quot;</span></span><span>
</span><span id="line-1223"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-special">,</span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Distinct"><span class="hs-identifier hs-var">Distinct</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier -&gt; Parser FilePath -&gt; Parser SetQuantifier
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;distinct&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1224"></span><span>
</span><span id="line-1225"></span><span class="hs-comment">-------------------------------------------------</span><span>
</span><span id="line-1226"></span><span>
</span><span id="line-1227"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-1228"></span><span>
</span><span id="line-1229"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">lists</span><span>
</span><span id="line-1230"></span><span>
</span><span id="line-1231"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#selectItem"><span class="hs-identifier hs-type">selectItem</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1232"></span><span class="hs-operator">&gt;</span><span> </span><span id="selectItem"><span class="annot"><span class="annottext">selectItem :: Parser (ScalarExpr, Maybe Name)
</span><a href="Language.SQL.SimpleSQL.Parse.html#selectItem"><span class="hs-identifier hs-var hs-var">selectItem</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe Name -&gt; (ScalarExpr, Maybe Name))
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Name -&gt; (ScalarExpr, Maybe Name))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Name -&gt; (ScalarExpr, Maybe Name))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
-&gt; Parser (ScalarExpr, Maybe Name)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="#local-6989586621679120508"><span class="hs-identifier hs-var">als</span></a></span><span>
</span><span id="line-1233"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679120508"><span class="annot"><span class="annottext">als :: Parser Name
</span><a href="#local-6989586621679120508"><span class="hs-identifier hs-var hs-var">als</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1234"></span><span>
</span><span id="line-1235"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#selectList"><span class="hs-identifier hs-type">selectList</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1236"></span><span class="hs-operator">&gt;</span><span> </span><span id="selectList"><span class="annot"><span class="annottext">selectList :: Parser [(ScalarExpr, Maybe Name)]
</span><a href="Language.SQL.SimpleSQL.Parse.html#selectList"><span class="hs-identifier hs-var hs-var">selectList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser (ScalarExpr, Maybe Name)
-&gt; Parser [(ScalarExpr, Maybe Name)]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser (ScalarExpr, Maybe Name)
</span><a href="Language.SQL.SimpleSQL.Parse.html#selectItem"><span class="hs-identifier hs-var">selectItem</span></a></span><span>
</span><span id="line-1237"></span><span>
</span><span id="line-1238"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">from</span><span>
</span><span id="line-1239"></span><span>
</span><span id="line-1240"></span><span class="hs-identifier">Here</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">rough</span><span> </span><span class="hs-identifier">grammar</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">joins</span><span>
</span><span id="line-1241"></span><span>
</span><span id="line-1242"></span><span class="hs-identifier">tref</span><span>
</span><span id="line-1243"></span><span class="hs-special">(</span><span class="hs-identifier">cross</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">natural</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-identifier">inner</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">left</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">right</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">full</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">outer</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">join</span><span>
</span><span id="line-1244"></span><span class="hs-identifier">tref</span><span>
</span><span id="line-1245"></span><span class="hs-special">[</span><span class="hs-identifier">on</span><span> </span><span class="hs-identifier">expr</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">using</span><span> </span><span class="hs-special">(</span><span class="hs-operator">...</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1246"></span><span>
</span><span id="line-1247"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">either</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">explicit</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">operator</span><span> </span><span class="hs-identifier">precedence'</span><span> </span><span class="hs-identifier">parsers</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">build</span><span>
</span><span id="line-1248"></span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">tref</span><span> </span><span class="hs-identifier">operators'</span><span> </span><span class="hs-identifier">such</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">joins</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">lateral</span><span class="hs-special">,</span><span>
</span><span id="line-1249"></span><span class="hs-identifier">aliases</span><span class="hs-operator">.</span><span>
</span><span id="line-1250"></span><span>
</span><span id="line-1251"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#from"><span class="hs-identifier hs-type">from</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#TableRef"><span class="hs-identifier hs-type">TableRef</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1252"></span><span class="hs-operator">&gt;</span><span> </span><span id="from"><span class="annot"><span class="annottext">from :: Parser [TableRef]
</span><a href="Language.SQL.SimpleSQL.Parse.html#from"><span class="hs-identifier hs-var hs-var">from</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [TableRef] -&gt; Parser [TableRef]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TableRef -&gt; Parser [TableRef]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120505"><span class="hs-identifier hs-var">tref</span></a></span><span>
</span><span id="line-1253"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1254"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- TODO: use P (a-&gt;) for the join tref suffix</span><span>
</span><span id="line-1255"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- chainl or buildexpressionparser</span><span>
</span><span id="line-1256"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120505"><span class="annot"><span class="annottext">tref :: Parser TableRef
</span><a href="#local-6989586621679120505"><span class="hs-identifier hs-var hs-var">tref</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120504"><span class="hs-identifier hs-var">nonJoinTref</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TableRef -&gt; (TableRef -&gt; Parser TableRef) -&gt; Parser TableRef
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; Parser TableRef) -&gt; TableRef -&gt; Parser TableRef
forall a t s. (a -&gt; GenParser t s a) -&gt; a -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#optionSuffix"><span class="hs-identifier hs-var">optionSuffix</span></a></span><span> </span><span class="annot"><span class="annottext">TableRef -&gt; Parser TableRef
</span><a href="#local-6989586621679120502"><span class="hs-identifier hs-var">joinTrefSuffix</span></a></span><span>
</span><span id="line-1257"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120504"><span class="annot"><span class="annottext">nonJoinTref :: Parser TableRef
</span><a href="#local-6989586621679120504"><span class="hs-identifier hs-var hs-var">nonJoinTref</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser TableRef] -&gt; Parser TableRef
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1258"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser TableRef -&gt; Parser TableRef
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser TableRef -&gt; Parser TableRef)
-&gt; Parser TableRef -&gt; Parser TableRef
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Parser TableRef] -&gt; Parser TableRef
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1259"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">[</span><span class="annot"><span class="annottext">QueryExpr -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRQueryExpr"><span class="hs-identifier hs-var">TRQueryExpr</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; TableRef) -&gt; Parser QueryExpr -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-1260"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">,</span><span class="annot"><span class="annottext">TableRef -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRParens"><span class="hs-identifier hs-var">TRParens</span></a></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; TableRef) -&gt; Parser TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120505"><span class="hs-identifier hs-var">tref</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1261"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">TableRef -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRLateral"><span class="hs-identifier hs-var">TRLateral</span></a></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; TableRef) -&gt; Parser TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;lateral&quot;</span></span><span>
</span><span id="line-1262"></span><span class="hs-operator">&gt;</span><span>                         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120504"><span class="hs-identifier hs-var">nonJoinTref</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1263"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="hs-keyword">do</span><span>
</span><span id="line-1264"></span><span class="hs-operator">&gt;</span><span>          </span><span id="local-6989586621679120498"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120498"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1265"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">[Parser TableRef] -&gt; Parser TableRef
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[Name] -&gt; [ScalarExpr] -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRFunction"><span class="hs-identifier hs-var">TRFunction</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120498"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1266"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">([ScalarExpr] -&gt; TableRef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1267"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="hs-special">,</span><span class="annot"><span class="annottext">TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; Parser TableRef) -&gt; TableRef -&gt; Parser TableRef
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRSimple"><span class="hs-identifier hs-var">TRSimple</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120498"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1268"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- todo: I think you can only have outer joins inside the oj,</span><span>
</span><span id="line-1269"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- not sure.</span><span>
</span><span id="line-1270"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">TableRef -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TROdbc"><span class="hs-identifier hs-var">TROdbc</span></a></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; TableRef) -&gt; Parser TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;{&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;oj&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser TableRef -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120505"><span class="hs-identifier hs-var">tref</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TableRef -&gt; Parser FilePath -&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;}&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1271"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser TableRef
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TableRef -&gt; TableRef)
-&gt; Parser TableRef
forall t s a.
GenParser t s a -&gt; GenParser t s (a -&gt; a) -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%3F%3F%3E"><span class="hs-operator hs-var">&lt;??&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">GenParser
  ((FilePath, Int, Int), Token) Dialect (TableRef -&gt; TableRef)
</span><a href="#local-6989586621679120493"><span class="hs-identifier hs-var">aliasSuffix</span></a></span><span>
</span><span id="line-1272"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120493"><span class="annot"><span class="annottext">aliasSuffix :: GenParser
  ((FilePath, Int, Int), Token) Dialect (TableRef -&gt; TableRef)
</span><a href="#local-6989586621679120493"><span class="hs-identifier hs-var hs-var">aliasSuffix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser Alias
</span><a href="Language.SQL.SimpleSQL.Parse.html#fromAlias"><span class="hs-identifier hs-var">fromAlias</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Alias
-&gt; (TableRef -&gt; Alias -&gt; TableRef)
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (TableRef -&gt; TableRef)
forall (f :: * -&gt; *) b a c.
Applicative f =&gt;
f b -&gt; (a -&gt; b -&gt; c) -&gt; f (a -&gt; c)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%3E"><span class="hs-operator hs-var">&lt;$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">TableRef -&gt; Alias -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRAlias"><span class="hs-identifier hs-var">TRAlias</span></a></span><span>
</span><span id="line-1273"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120502"><span class="annot"><span class="annottext">joinTrefSuffix :: TableRef -&gt; Parser TableRef
</span><a href="#local-6989586621679120502"><span class="hs-identifier hs-var hs-var">joinTrefSuffix</span></a></span></span><span> </span><span id="local-6989586621679120490"><span class="annot"><span class="annottext">t :: TableRef
</span><a href="#local-6989586621679120490"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1274"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TableRef
-&gt; Bool -&gt; JoinType -&gt; TableRef -&gt; Maybe JoinCondition -&gt; TableRef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TRJoin"><span class="hs-identifier hs-var">TRJoin</span></a></span><span> </span><span class="annot"><span class="annottext">TableRef
</span><a href="#local-6989586621679120490"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; JoinType -&gt; TableRef -&gt; Maybe JoinCondition -&gt; TableRef)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (JoinType -&gt; TableRef -&gt; Maybe JoinCondition -&gt; TableRef)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;natural&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1275"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (JoinType -&gt; TableRef -&gt; Maybe JoinCondition -&gt; TableRef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TableRef -&gt; Maybe JoinCondition -&gt; TableRef)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
</span><a href="Language.SQL.SimpleSQL.Parse.html#joinType"><span class="hs-identifier hs-var">joinType</span></a></span><span>
</span><span id="line-1276"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TableRef -&gt; Maybe JoinCondition -&gt; TableRef)
-&gt; Parser TableRef
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe JoinCondition -&gt; TableRef)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TableRef
</span><a href="#local-6989586621679120504"><span class="hs-identifier hs-var">nonJoinTref</span></a></span><span>
</span><span id="line-1277"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe JoinCondition -&gt; TableRef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe JoinCondition)
-&gt; Parser TableRef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe JoinCondition)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
</span><a href="Language.SQL.SimpleSQL.Parse.html#joinCondition"><span class="hs-identifier hs-var">joinCondition</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1278"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">Parser TableRef -&gt; (TableRef -&gt; Parser TableRef) -&gt; Parser TableRef
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">(TableRef -&gt; Parser TableRef) -&gt; TableRef -&gt; Parser TableRef
forall a t s. (a -&gt; GenParser t s a) -&gt; a -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#optionSuffix"><span class="hs-identifier hs-var">optionSuffix</span></a></span><span> </span><span class="annot"><span class="annottext">TableRef -&gt; Parser TableRef
</span><a href="#local-6989586621679120502"><span class="hs-identifier hs-var">joinTrefSuffix</span></a></span><span>
</span><span id="line-1279"></span><span>
</span><span id="line-1280"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">factor</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">join</span><span> </span><span class="hs-identifier">stuff</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">produce</span><span> </span><span class="hs-identifier">better</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">make</span><span>
</span><span id="line-1281"></span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">more</span><span> </span><span class="hs-identifier">readable</span><span class="hs-special">)</span><span>
</span><span id="line-1282"></span><span>
</span><span id="line-1283"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#joinType"><span class="hs-identifier hs-type">joinType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#JoinType"><span class="hs-identifier hs-type">JoinType</span></a></span><span>
</span><span id="line-1284"></span><span class="hs-operator">&gt;</span><span> </span><span id="joinType"><span class="annot"><span class="annottext">joinType :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
</span><a href="Language.SQL.SimpleSQL.Parse.html#joinType"><span class="hs-identifier hs-var hs-var">joinType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1285"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JCross"><span class="hs-identifier hs-var">JCross</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cross&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span>
</span><span id="line-1286"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JInner"><span class="hs-identifier hs-var">JInner</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;inner&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span>
</span><span id="line-1287"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JLeft"><span class="hs-identifier hs-var">JLeft</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;left&quot;</span></span><span>
</span><span id="line-1288"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;outer&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1289"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span>
</span><span id="line-1290"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JRight"><span class="hs-identifier hs-var">JRight</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;right&quot;</span></span><span>
</span><span id="line-1291"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;outer&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1292"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span>
</span><span id="line-1293"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JFull"><span class="hs-identifier hs-var">JFull</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;full&quot;</span></span><span>
</span><span id="line-1294"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;outer&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1295"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span>
</span><span id="line-1296"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">JoinType
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JInner"><span class="hs-identifier hs-var">JInner</span></a></span><span> </span><span class="annot"><span class="annottext">JoinType
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinType
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;join&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1297"></span><span>
</span><span id="line-1298"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#joinCondition"><span class="hs-identifier hs-type">joinCondition</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#JoinCondition"><span class="hs-identifier hs-type">JoinCondition</span></a></span><span>
</span><span id="line-1299"></span><span class="hs-operator">&gt;</span><span> </span><span id="joinCondition"><span class="annot"><span class="annottext">joinCondition :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
</span><a href="Language.SQL.SimpleSQL.Parse.html#joinCondition"><span class="hs-identifier hs-var hs-var">joinCondition</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1300"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;on&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; JoinCondition
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JoinOn"><span class="hs-identifier hs-var">JoinOn</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; JoinCondition)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1301"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;using&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; JoinCondition
</span><a href="Language.SQL.SimpleSQL.Syntax.html#JoinUsing"><span class="hs-identifier hs-var">JoinUsing</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; JoinCondition)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity JoinCondition
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1302"></span><span>
</span><span id="line-1303"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#fromAlias"><span class="hs-identifier hs-type">fromAlias</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Alias"><span class="hs-identifier hs-type">Alias</span></a></span><span>
</span><span id="line-1304"></span><span class="hs-operator">&gt;</span><span> </span><span id="fromAlias"><span class="annot"><span class="annottext">fromAlias :: Parser Alias
</span><a href="Language.SQL.SimpleSQL.Parse.html#fromAlias"><span class="hs-identifier hs-var hs-var">fromAlias</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe [Name] -&gt; Alias
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Alias"><span class="hs-identifier hs-var">Alias</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Maybe [Name] -&gt; Alias)
-&gt; Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name] -&gt; Alias)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="#local-6989586621679120478"><span class="hs-identifier hs-var">tableAlias</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name] -&gt; Alias)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; Parser Alias
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
</span><a href="#local-6989586621679120477"><span class="hs-identifier hs-var">columnAliases</span></a></span><span>
</span><span id="line-1305"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1306"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120478"><span class="annot"><span class="annottext">tableAlias :: Parser Name
</span><a href="#local-6989586621679120478"><span class="hs-identifier hs-var hs-var">tableAlias</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1307"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120477"><span class="annot"><span class="annottext">columnAliases :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
</span><a href="#local-6989586621679120477"><span class="hs-identifier hs-var hs-var">columnAliases</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">(Parser [Name]
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name]))
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1308"></span><span>
</span><span id="line-1309"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">simple</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">parts</span><span>
</span><span id="line-1310"></span><span>
</span><span id="line-1311"></span><span class="hs-identifier">Parsers</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-keyword">where</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">group</span><span> </span><span class="hs-identifier">by</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">having</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">order</span><span> </span><span class="hs-identifier">by</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">limit</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">are</span><span>
</span><span id="line-1312"></span><span class="hs-identifier">pretty</span><span> </span><span class="hs-identifier">trivial</span><span class="hs-operator">.</span><span>
</span><span id="line-1313"></span><span>
</span><span id="line-1314"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#whereClause"><span class="hs-identifier hs-type">whereClause</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1315"></span><span class="hs-operator">&gt;</span><span> </span><span id="whereClause"><span class="annot"><span class="annottext">whereClause :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#whereClause"><span class="hs-identifier hs-var hs-var">whereClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;where&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1316"></span><span>
</span><span id="line-1317"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#groupByClause"><span class="hs-identifier hs-type">groupByClause</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#GroupingExpr"><span class="hs-identifier hs-type">GroupingExpr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1318"></span><span class="hs-operator">&gt;</span><span> </span><span id="groupByClause"><span class="annot"><span class="annottext">groupByClause :: Parser [GroupingExpr]
</span><a href="Language.SQL.SimpleSQL.Parse.html#groupByClause"><span class="hs-identifier hs-var hs-var">groupByClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;group&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;by&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var">groupingExpression</span></a></span><span>
</span><span id="line-1319"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1320"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120474"><span class="annot"><span class="annottext">groupingExpression :: Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var hs-var">groupingExpression</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser GroupingExpr] -&gt; Parser GroupingExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1321"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cube&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser GroupingExpr -&gt; Parser GroupingExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1322"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">[GroupingExpr] -&gt; GroupingExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Cube"><span class="hs-identifier hs-var">Cube</span></a></span><span> </span><span class="annot"><span class="annottext">([GroupingExpr] -&gt; GroupingExpr)
-&gt; Parser [GroupingExpr] -&gt; Parser GroupingExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser GroupingExpr -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var">groupingExpression</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1323"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;rollup&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser GroupingExpr -&gt; Parser GroupingExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1324"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">[GroupingExpr] -&gt; GroupingExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Rollup"><span class="hs-identifier hs-var">Rollup</span></a></span><span> </span><span class="annot"><span class="annottext">([GroupingExpr] -&gt; GroupingExpr)
-&gt; Parser [GroupingExpr] -&gt; Parser GroupingExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser GroupingExpr -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var">groupingExpression</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1325"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[GroupingExpr] -&gt; GroupingExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GroupingParens"><span class="hs-identifier hs-var">GroupingParens</span></a></span><span> </span><span class="annot"><span class="annottext">([GroupingExpr] -&gt; GroupingExpr)
-&gt; Parser [GroupingExpr] -&gt; Parser GroupingExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser GroupingExpr -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var">groupingExpression</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1326"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;grouping&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;sets&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser GroupingExpr -&gt; Parser GroupingExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1327"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">[GroupingExpr] -&gt; GroupingExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GroupingSets"><span class="hs-identifier hs-var">GroupingSets</span></a></span><span> </span><span class="annot"><span class="annottext">([GroupingExpr] -&gt; GroupingExpr)
-&gt; Parser [GroupingExpr] -&gt; Parser GroupingExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser GroupingExpr -&gt; Parser [GroupingExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser GroupingExpr
</span><a href="#local-6989586621679120474"><span class="hs-identifier hs-var">groupingExpression</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1328"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ScalarExpr -&gt; GroupingExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SimpleGroup"><span class="hs-identifier hs-var">SimpleGroup</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; GroupingExpr)
-&gt; Parser ScalarExpr -&gt; Parser GroupingExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1329"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">]</span><span>
</span><span id="line-1330"></span><span>
</span><span id="line-1331"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#having"><span class="hs-identifier hs-type">having</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1332"></span><span class="hs-operator">&gt;</span><span> </span><span id="having"><span class="annot"><span class="annottext">having :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#having"><span class="hs-identifier hs-var hs-var">having</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;having&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1333"></span><span>
</span><span id="line-1334"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-type">orderBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#SortSpec"><span class="hs-identifier hs-type">SortSpec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1335"></span><span class="hs-operator">&gt;</span><span> </span><span id="orderBy"><span class="annot"><span class="annottext">orderBy :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var hs-var">orderBy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;order&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;by&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser SortSpec
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SortSpec
</span><a href="#local-6989586621679120467"><span class="hs-identifier hs-var">ob</span></a></span><span>
</span><span id="line-1336"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1337"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120467"><span class="annot"><span class="annottext">ob :: Parser SortSpec
</span><a href="#local-6989586621679120467"><span class="hs-identifier hs-var hs-var">ob</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Direction -&gt; NullsOrder -&gt; SortSpec
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SortSpec"><span class="hs-identifier hs-var">SortSpec</span></a></span><span>
</span><span id="line-1338"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Direction -&gt; NullsOrder -&gt; SortSpec)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Direction -&gt; NullsOrder -&gt; SortSpec)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1339"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Direction -&gt; NullsOrder -&gt; SortSpec)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (NullsOrder -&gt; SortSpec)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Direction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Direction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DirDefault"><span class="hs-identifier hs-var">DirDefault</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity Direction]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Direction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Asc"><span class="hs-identifier hs-var">Asc</span></a></span><span> </span><span class="annot"><span class="annottext">Direction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;asc&quot;</span></span><span>
</span><span id="line-1340"></span><span class="hs-operator">&gt;</span><span>                                        </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Direction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Desc"><span class="hs-identifier hs-var">Desc</span></a></span><span> </span><span class="annot"><span class="annottext">Direction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Direction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;desc&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1341"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (NullsOrder -&gt; SortSpec)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
-&gt; Parser SortSpec
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">NullsOrder
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">NullsOrder
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NullsOrderDefault"><span class="hs-identifier hs-var">NullsOrderDefault</span></a></span><span>
</span><span id="line-1342"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-comment">-- todo: left factor better</span><span>
</span><span id="line-1343"></span><span class="hs-operator">&gt;</span><span>              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;nulls&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1344"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">NullsOrder
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NullsFirst"><span class="hs-identifier hs-var">NullsFirst</span></a></span><span> </span><span class="annot"><span class="annottext">NullsOrder
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;first&quot;</span></span><span>
</span><span id="line-1345"></span><span class="hs-operator">&gt;</span><span>                            </span><span class="hs-special">,</span><span class="annot"><span class="annottext">NullsOrder
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NullsLast"><span class="hs-identifier hs-var">NullsLast</span></a></span><span> </span><span class="annot"><span class="annottext">NullsOrder
-&gt; Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity NullsOrder
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;last&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1346"></span><span>
</span><span id="line-1347"></span><span class="hs-identifier">allows</span><span> </span><span class="hs-identifier">offset</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">fetch</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">either</span><span> </span><span class="hs-identifier">order</span><span>
</span><span id="line-1348"></span><span class="hs-operator">+</span><span> </span><span class="hs-identifier">postgresql</span><span> </span><span class="hs-identifier">offset</span><span> </span><span class="hs-identifier">without</span><span> </span><span class="hs-identifier">row</span><span class="hs-special">(</span><span class="hs-identifier">s</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">limit</span><span> </span><span class="hs-identifier">instead</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">fetch</span><span> </span><span class="hs-identifier">also</span><span>
</span><span id="line-1349"></span><span>
</span><span id="line-1350"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#offsetFetch"><span class="hs-identifier hs-type">offsetFetch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1351"></span><span class="hs-operator">&gt;</span><span> </span><span id="offsetFetch"><span class="annot"><span class="annottext">offsetFetch :: Parser (Maybe ScalarExpr, Maybe ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#offsetFetch"><span class="hs-identifier hs-var hs-var">offsetFetch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe ScalarExpr, Maybe ScalarExpr)
-&gt; Parser (Maybe ScalarExpr, Maybe ScalarExpr)
forall s tok st a.
Stream s Identity tok =&gt;
StreamPermParser s st a -&gt; Parsec s st a
</span><span class="hs-identifier hs-var">permute</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe ScalarExpr
 -&gt; Maybe ScalarExpr -&gt; (Maybe ScalarExpr, Maybe ScalarExpr))
-&gt; (Maybe ScalarExpr,
    ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (Maybe ScalarExpr))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe ScalarExpr -&gt; (Maybe ScalarExpr, Maybe ScalarExpr))
forall s tok a b st.
Stream s Identity tok =&gt;
(a -&gt; b) -&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;$?&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe ScalarExpr
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Maybe ScalarExpr
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#offset"><span class="hs-identifier hs-var">offset</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1352"></span><span class="hs-operator">&gt;</span><span>                            </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe ScalarExpr -&gt; (Maybe ScalarExpr, Maybe ScalarExpr))
-&gt; (Maybe ScalarExpr,
    ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (Maybe ScalarExpr))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe ScalarExpr, Maybe ScalarExpr)
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe ScalarExpr
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; Maybe ScalarExpr
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; Maybe ScalarExpr)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#fetch"><span class="hs-identifier hs-var">fetch</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1353"></span><span>
</span><span id="line-1354"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#offset"><span class="hs-identifier hs-type">offset</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1355"></span><span class="hs-operator">&gt;</span><span> </span><span id="offset"><span class="annot"><span class="annottext">offset :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#offset"><span class="hs-identifier hs-var hs-var">offset</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;offset&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1356"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;rows&quot;</span></span><span>
</span><span id="line-1357"></span><span class="hs-operator">&gt;</span><span>                               </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;row&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1358"></span><span>
</span><span id="line-1359"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#fetch"><span class="hs-identifier hs-type">fetch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1360"></span><span class="hs-operator">&gt;</span><span> </span><span id="fetch"><span class="annot"><span class="annottext">fetch :: Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#fetch"><span class="hs-identifier hs-var hs-var">fetch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120456"><span class="hs-identifier hs-var">fetchFirst</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="#local-6989586621679120455"><span class="hs-identifier hs-var">limit</span></a></span><span>
</span><span id="line-1361"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1362"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120456"><span class="annot"><span class="annottext">fetchFirst :: Parser ScalarExpr
</span><a href="#local-6989586621679120456"><span class="hs-identifier hs-var hs-var">fetchFirst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Dialect -&gt; Bool)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#guardDialect"><span class="hs-identifier hs-var">guardDialect</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect -&gt; Bool
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diFetchFirst"><span class="hs-identifier hs-var hs-var">diFetchFirst</span></a></span><span>
</span><span id="line-1363"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120452"><span class="hs-identifier hs-var">fs</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120451"><span class="hs-identifier hs-var">ro</span></a></span><span>
</span><span id="line-1364"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120452"><span class="annot"><span class="annottext">fs :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120452"><span class="hs-identifier hs-var hs-var">fs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;fetch first&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;fetch next&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1365"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120451"><span class="annot"><span class="annottext">ro :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120451"><span class="hs-identifier hs-var hs-var">ro</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var">makeKeywordTree</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;rows only&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;row only&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1366"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: not in ansi sql dialect</span><span>
</span><span id="line-1367"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120455"><span class="annot"><span class="annottext">limit :: Parser ScalarExpr
</span><a href="#local-6989586621679120455"><span class="hs-identifier hs-var hs-var">limit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Dialect -&gt; Bool)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#guardDialect"><span class="hs-identifier hs-var">guardDialect</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect -&gt; Bool
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diLimit"><span class="hs-identifier hs-var hs-var">diLimit</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-1368"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;limit&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1369"></span><span>
</span><span id="line-1370"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">common</span><span> </span><span class="hs-identifier">table</span><span> </span><span class="hs-identifier">expressions</span><span>
</span><span id="line-1371"></span><span>
</span><span id="line-1372"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#with"><span class="hs-identifier hs-type">with</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span>
</span><span id="line-1373"></span><span class="hs-operator">&gt;</span><span> </span><span id="with"><span class="annot"><span class="annottext">with :: Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#with"><span class="hs-identifier hs-var hs-var">with</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1374"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Bool -&gt; [(Alias, QueryExpr)] -&gt; QueryExpr -&gt; QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#With"><span class="hs-identifier hs-var">With</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; [(Alias, QueryExpr)] -&gt; QueryExpr -&gt; QueryExpr)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([(Alias, QueryExpr)] -&gt; QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;recursive&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1375"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([(Alias, QueryExpr)] -&gt; QueryExpr -&gt; QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [(Alias, QueryExpr)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser (Alias, QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [(Alias, QueryExpr)]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser (Alias, QueryExpr)
</span><a href="#local-6989586621679120447"><span class="hs-identifier hs-var">withQuery</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; QueryExpr)
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-1376"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1377"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120447"><span class="annot"><span class="annottext">withQuery :: Parser (Alias, QueryExpr)
</span><a href="#local-6989586621679120447"><span class="hs-identifier hs-var hs-var">withQuery</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Alias -&gt; QueryExpr -&gt; (Alias, QueryExpr))
-&gt; Parser Alias
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; (Alias, QueryExpr))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Alias
</span><a href="#local-6989586621679120446"><span class="hs-identifier hs-var">withAlias</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Alias
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Alias
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1378"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; (Alias, QueryExpr))
-&gt; Parser QueryExpr -&gt; Parser (Alias, QueryExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr -&gt; Parser QueryExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-1379"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120446"><span class="annot"><span class="annottext">withAlias :: Parser Alias
</span><a href="#local-6989586621679120446"><span class="hs-identifier hs-var hs-var">withAlias</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe [Name] -&gt; Alias
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Alias"><span class="hs-identifier hs-var">Alias</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Maybe [Name] -&gt; Alias)
-&gt; Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name] -&gt; Alias)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name] -&gt; Alias)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; Parser Alias
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
</span><a href="#local-6989586621679120445"><span class="hs-identifier hs-var">columnAliases</span></a></span><span>
</span><span id="line-1380"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120445"><span class="annot"><span class="annottext">columnAliases :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
</span><a href="#local-6989586621679120445"><span class="hs-identifier hs-var hs-var">columnAliases</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">(Parser [Name]
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name]))
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1381"></span><span>
</span><span id="line-1382"></span><span>
</span><span id="line-1383"></span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expression</span><span>
</span><span id="line-1384"></span><span>
</span><span id="line-1385"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">parses</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expression</span><span> </span><span class="hs-identifier">variant</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">normal</span><span> </span><span class="hs-identifier">select</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">cte</span><span class="hs-special">,</span><span>
</span><span id="line-1386"></span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">union</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">etc</span><span class="hs-glyph">..</span><span>
</span><span id="line-1387"></span><span>
</span><span id="line-1388"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-type">queryExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span>
</span><span id="line-1389"></span><span class="hs-operator">&gt;</span><span> </span><span id="queryExpr"><span class="annot"><span class="annottext">queryExpr :: Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var hs-var">queryExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser QueryExpr] -&gt; Parser QueryExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1390"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#with"><span class="hs-identifier hs-var">with</span></a></span><span>
</span><span id="line-1391"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser QueryExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
-&gt; Parser QueryExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (a -&gt; a -&gt; a) -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">chainr1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Parser QueryExpr] -&gt; Parser QueryExpr
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="#local-6989586621679120444"><span class="hs-identifier hs-var">values</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="#local-6989586621679120443"><span class="hs-identifier hs-var">table</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="#local-6989586621679120442"><span class="hs-identifier hs-var">select</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#setOp"><span class="hs-identifier hs-var">setOp</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1392"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1393"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120442"><span class="annot"><span class="annottext">select :: Parser QueryExpr
</span><a href="#local-6989586621679120442"><span class="hs-identifier hs-var hs-var">select</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;select&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1394"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">SetQuantifier
-&gt; [(ScalarExpr, Maybe Name)] -&gt; Maybe TableExpression -&gt; QueryExpr
</span><a href="#local-6989586621679120440"><span class="hs-identifier hs-var">mkSelect</span></a></span><span>
</span><span id="line-1395"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(SetQuantifier
 -&gt; [(ScalarExpr, Maybe Name)]
 -&gt; Maybe TableExpression
 -&gt; QueryExpr)
-&gt; Parser SetQuantifier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([(ScalarExpr, Maybe Name)] -&gt; Maybe TableExpression -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">SetQuantifier -&gt; Parser SetQuantifier -&gt; Parser SetQuantifier
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SQDefault"><span class="hs-identifier hs-var">SQDefault</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-var">duplicates</span></a></span><span>
</span><span id="line-1396"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([(ScalarExpr, Maybe Name)] -&gt; Maybe TableExpression -&gt; QueryExpr)
-&gt; Parser [(ScalarExpr, Maybe Name)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe TableExpression -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [(ScalarExpr, Maybe Name)]
</span><a href="Language.SQL.SimpleSQL.Parse.html#selectList"><span class="hs-identifier hs-var">selectList</span></a></span><span>
</span><span id="line-1397"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe TableExpression -&gt; QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe TableExpression)
-&gt; Parser QueryExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableExpression
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe TableExpression)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableExpression
</span><a href="Language.SQL.SimpleSQL.Parse.html#tableExpression"><span class="hs-identifier hs-var">tableExpression</span></a></span><span>
</span><span id="line-1398"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120440"><span class="annot"><span class="annottext">mkSelect :: SetQuantifier
-&gt; [(ScalarExpr, Maybe Name)] -&gt; Maybe TableExpression -&gt; QueryExpr
</span><a href="#local-6989586621679120440"><span class="hs-identifier hs-var hs-var">mkSelect</span></a></span></span><span> </span><span id="local-6989586621679120438"><span class="annot"><span class="annottext">d :: SetQuantifier
</span><a href="#local-6989586621679120438"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679120437"><span class="annot"><span class="annottext">sl :: [(ScalarExpr, Maybe Name)]
</span><a href="#local-6989586621679120437"><span class="hs-identifier hs-var">sl</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1399"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#makeSelect"><span class="hs-identifier hs-var">makeSelect</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">qeSetQuantifier :: SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#qeSetQuantifier"><span class="hs-identifier hs-var">qeSetQuantifier</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="#local-6989586621679120438"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">qeSelectList :: [(ScalarExpr, Maybe Name)]
</span><a href="Language.SQL.SimpleSQL.Syntax.html#qeSelectList"><span class="hs-identifier hs-var">qeSelectList</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(ScalarExpr, Maybe Name)]
</span><a href="#local-6989586621679120437"><span class="hs-identifier hs-var">sl</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-1400"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120440"><span class="hs-identifier hs-var">mkSelect</span></a></span><span> </span><span id="local-6989586621679120433"><span class="annot"><span class="annottext">d :: SetQuantifier
</span><a href="#local-6989586621679120433"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679120432"><span class="annot"><span class="annottext">sl :: [(ScalarExpr, Maybe Name)]
</span><a href="#local-6989586621679120432"><span class="hs-identifier hs-var">sl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#TableExpression"><span class="hs-identifier hs-type">TableExpression</span></a></span><span> </span><span id="local-6989586621679120430"><span class="annot"><span class="annottext">f :: [TableRef]
</span><a href="#local-6989586621679120430"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679120429"><span class="annot"><span class="annottext">w :: Maybe ScalarExpr
</span><a href="#local-6989586621679120429"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span id="local-6989586621679120428"><span class="annot"><span class="annottext">g :: [GroupingExpr]
</span><a href="#local-6989586621679120428"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621679120427"><span class="annot"><span class="annottext">h :: Maybe ScalarExpr
</span><a href="#local-6989586621679120427"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621679120426"><span class="annot"><span class="annottext">od :: [SortSpec]
</span><a href="#local-6989586621679120426"><span class="hs-identifier hs-var">od</span></a></span></span><span> </span><span id="local-6989586621679120425"><span class="annot"><span class="annottext">ofs :: Maybe ScalarExpr
</span><a href="#local-6989586621679120425"><span class="hs-identifier hs-var">ofs</span></a></span></span><span> </span><span id="local-6989586621679120424"><span class="annot"><span class="annottext">fe :: Maybe ScalarExpr
</span><a href="#local-6989586621679120424"><span class="hs-identifier hs-var">fe</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1401"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">SetQuantifier
-&gt; [(ScalarExpr, Maybe Name)]
-&gt; [TableRef]
-&gt; Maybe ScalarExpr
-&gt; [GroupingExpr]
-&gt; Maybe ScalarExpr
-&gt; [SortSpec]
-&gt; Maybe ScalarExpr
-&gt; Maybe ScalarExpr
-&gt; QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Select"><span class="hs-identifier hs-var">Select</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="#local-6989586621679120433"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">[(ScalarExpr, Maybe Name)]
</span><a href="#local-6989586621679120432"><span class="hs-identifier hs-var">sl</span></a></span><span> </span><span class="annot"><span class="annottext">[TableRef]
</span><a href="#local-6989586621679120430"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120429"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="annot"><span class="annottext">[GroupingExpr]
</span><a href="#local-6989586621679120428"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120427"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">[SortSpec]
</span><a href="#local-6989586621679120426"><span class="hs-identifier hs-var">od</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120425"><span class="hs-identifier hs-var">ofs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120424"><span class="hs-identifier hs-var">fe</span></a></span><span>
</span><span id="line-1402"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120444"><span class="annot"><span class="annottext">values :: Parser QueryExpr
</span><a href="#local-6989586621679120444"><span class="hs-identifier hs-var hs-var">values</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;values&quot;</span></span><span>
</span><span id="line-1403"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[[ScalarExpr]] -&gt; QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Values"><span class="hs-identifier hs-var">Values</span></a></span><span> </span><span class="annot"><span class="annottext">([[ScalarExpr]] -&gt; QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [[ScalarExpr]]
-&gt; Parser QueryExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [[ScalarExpr]]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1404"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120443"><span class="annot"><span class="annottext">table :: Parser QueryExpr
</span><a href="#local-6989586621679120443"><span class="hs-identifier hs-var hs-var">table</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Table"><span class="hs-identifier hs-var">Table</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; QueryExpr) -&gt; Parser [Name] -&gt; Parser QueryExpr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1405"></span><span>
</span><span id="line-1406"></span><span class="hs-identifier">local</span><span> </span><span class="hs-keyword">data</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">help</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">bit</span><span> </span><span class="hs-identifier">after</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">list</span><span class="hs-special">,</span><span>
</span><span id="line-1407"></span><span class="hs-identifier">called</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">table</span><span> </span><span class="hs-identifier">expression'</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">ansi</span><span> </span><span class="hs-identifier">sql</span><span> </span><span class="hs-identifier">grammar</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">should</span><span>
</span><span id="line-1408"></span><span class="hs-identifier">be</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">public</span><span> </span><span class="hs-identifier">syntax</span><span class="hs-operator">?</span><span>
</span><span id="line-1409"></span><span>
</span><span id="line-1410"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">data</span><span> </span><span id="TableExpression"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#TableExpression"><span class="hs-identifier hs-var">TableExpression</span></a></span></span><span>
</span><span id="line-1411"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-glyph">=</span><span> </span><span id="TableExpression"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#TableExpression"><span class="hs-identifier hs-var">TableExpression</span></a></span></span><span>
</span><span id="line-1412"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">{</span><span id="_teFrom"><span class="annot"><span class="annottext">TableExpression -&gt; [TableRef]
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teFrom"><span class="hs-identifier hs-var hs-var">_teFrom</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#TableRef"><span class="hs-identifier hs-type">TableRef</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1413"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teWhere"><span class="annot"><span class="annottext">TableExpression -&gt; Maybe ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teWhere"><span class="hs-identifier hs-var hs-var">_teWhere</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1414"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teGroupBy"><span class="annot"><span class="annottext">TableExpression -&gt; [GroupingExpr]
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teGroupBy"><span class="hs-identifier hs-var hs-var">_teGroupBy</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#GroupingExpr"><span class="hs-identifier hs-type">GroupingExpr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1415"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teHaving"><span class="annot"><span class="annottext">TableExpression -&gt; Maybe ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teHaving"><span class="hs-identifier hs-var hs-var">_teHaving</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1416"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teOrderBy"><span class="annot"><span class="annottext">TableExpression -&gt; [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teOrderBy"><span class="hs-identifier hs-var hs-var">_teOrderBy</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#SortSpec"><span class="hs-identifier hs-type">SortSpec</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1417"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teOffset"><span class="annot"><span class="annottext">TableExpression -&gt; Maybe ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teOffset"><span class="hs-identifier hs-var hs-var">_teOffset</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span>
</span><span id="line-1418"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">,</span><span id="_teFetchFirst"><span class="annot"><span class="annottext">TableExpression -&gt; Maybe ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#_teFetchFirst"><span class="hs-identifier hs-var hs-var">_teFetchFirst</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ScalarExpr"><span class="hs-identifier hs-type">ScalarExpr</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-1419"></span><span>
</span><span id="line-1420"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#tableExpression"><span class="hs-identifier hs-type">tableExpression</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#TableExpression"><span class="hs-identifier hs-type">TableExpression</span></a></span><span>
</span><span id="line-1421"></span><span class="hs-operator">&gt;</span><span> </span><span id="tableExpression"><span class="annot"><span class="annottext">tableExpression :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableExpression
</span><a href="Language.SQL.SimpleSQL.Parse.html#tableExpression"><span class="hs-identifier hs-var hs-var">tableExpression</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TableRef]
-&gt; Maybe ScalarExpr
-&gt; [GroupingExpr]
-&gt; Maybe ScalarExpr
-&gt; [SortSpec]
-&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
-&gt; TableExpression
</span><a href="#local-6989586621679120413"><span class="hs-identifier hs-var">mkTe</span></a></span><span> </span><span class="annot"><span class="annottext">([TableRef]
 -&gt; Maybe ScalarExpr
 -&gt; [GroupingExpr]
 -&gt; Maybe ScalarExpr
 -&gt; [SortSpec]
 -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
 -&gt; TableExpression)
-&gt; Parser [TableRef]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr
      -&gt; [GroupingExpr]
      -&gt; Maybe ScalarExpr
      -&gt; [SortSpec]
      -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
      -&gt; TableExpression)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [TableRef]
</span><a href="Language.SQL.SimpleSQL.Parse.html#from"><span class="hs-identifier hs-var">from</span></a></span><span>
</span><span id="line-1422"></span><span class="hs-operator">&gt;</span><span>                        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr
   -&gt; [GroupingExpr]
   -&gt; Maybe ScalarExpr
   -&gt; [SortSpec]
   -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
   -&gt; TableExpression)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([GroupingExpr]
      -&gt; Maybe ScalarExpr
      -&gt; [SortSpec]
      -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
      -&gt; TableExpression)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#whereClause"><span class="hs-identifier hs-var">whereClause</span></a></span><span>
</span><span id="line-1423"></span><span class="hs-operator">&gt;</span><span>                        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([GroupingExpr]
   -&gt; Maybe ScalarExpr
   -&gt; [SortSpec]
   -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
   -&gt; TableExpression)
-&gt; Parser [GroupingExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr
      -&gt; [SortSpec]
      -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
      -&gt; TableExpression)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[GroupingExpr] -&gt; Parser [GroupingExpr] -&gt; Parser [GroupingExpr]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parser [GroupingExpr]
</span><a href="Language.SQL.SimpleSQL.Parse.html#groupByClause"><span class="hs-identifier hs-var">groupByClause</span></a></span><span>
</span><span id="line-1424"></span><span class="hs-operator">&gt;</span><span>                        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr
   -&gt; [SortSpec]
   -&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
   -&gt; TableExpression)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SortSpec]
      -&gt; (Maybe ScalarExpr, Maybe ScalarExpr) -&gt; TableExpression)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#having"><span class="hs-identifier hs-var">having</span></a></span><span>
</span><span id="line-1425"></span><span class="hs-operator">&gt;</span><span>                        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([SortSpec]
   -&gt; (Maybe ScalarExpr, Maybe ScalarExpr) -&gt; TableExpression)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ((Maybe ScalarExpr, Maybe ScalarExpr) -&gt; TableExpression)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [SortSpec]
</span><a href="Language.SQL.SimpleSQL.Parse.html#orderBy"><span class="hs-identifier hs-var">orderBy</span></a></span><span>
</span><span id="line-1426"></span><span class="hs-operator">&gt;</span><span>                        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ((Maybe ScalarExpr, Maybe ScalarExpr) -&gt; TableExpression)
-&gt; Parser (Maybe ScalarExpr, Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableExpression
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser (Maybe ScalarExpr, Maybe ScalarExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#offsetFetch"><span class="hs-identifier hs-var">offsetFetch</span></a></span><span>
</span><span id="line-1427"></span><span class="hs-operator">&gt;</span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1428"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120413"><span class="annot"><span class="annottext">mkTe :: [TableRef]
-&gt; Maybe ScalarExpr
-&gt; [GroupingExpr]
-&gt; Maybe ScalarExpr
-&gt; [SortSpec]
-&gt; (Maybe ScalarExpr, Maybe ScalarExpr)
-&gt; TableExpression
</span><a href="#local-6989586621679120413"><span class="hs-identifier hs-var hs-var">mkTe</span></a></span></span><span> </span><span id="local-6989586621679120412"><span class="annot"><span class="annottext">f :: [TableRef]
</span><a href="#local-6989586621679120412"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679120411"><span class="annot"><span class="annottext">w :: Maybe ScalarExpr
</span><a href="#local-6989586621679120411"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span id="local-6989586621679120410"><span class="annot"><span class="annottext">g :: [GroupingExpr]
</span><a href="#local-6989586621679120410"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621679120409"><span class="annot"><span class="annottext">h :: Maybe ScalarExpr
</span><a href="#local-6989586621679120409"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621679120408"><span class="annot"><span class="annottext">od :: [SortSpec]
</span><a href="#local-6989586621679120408"><span class="hs-identifier hs-var">od</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120407"><span class="annot"><span class="annottext">ofs :: Maybe ScalarExpr
</span><a href="#local-6989586621679120407"><span class="hs-identifier hs-var">ofs</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120406"><span class="annot"><span class="annottext">fe :: Maybe ScalarExpr
</span><a href="#local-6989586621679120406"><span class="hs-identifier hs-var">fe</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1429"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[TableRef]
-&gt; Maybe ScalarExpr
-&gt; [GroupingExpr]
-&gt; Maybe ScalarExpr
-&gt; [SortSpec]
-&gt; Maybe ScalarExpr
-&gt; Maybe ScalarExpr
-&gt; TableExpression
</span><a href="Language.SQL.SimpleSQL.Parse.html#TableExpression"><span class="hs-identifier hs-var">TableExpression</span></a></span><span> </span><span class="annot"><span class="annottext">[TableRef]
</span><a href="#local-6989586621679120412"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120411"><span class="hs-identifier hs-var">w</span></a></span><span> </span><span class="annot"><span class="annottext">[GroupingExpr]
</span><a href="#local-6989586621679120410"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120409"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">[SortSpec]
</span><a href="#local-6989586621679120408"><span class="hs-identifier hs-var">od</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120407"><span class="hs-identifier hs-var">ofs</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ScalarExpr
</span><a href="#local-6989586621679120406"><span class="hs-identifier hs-var">fe</span></a></span><span>
</span><span id="line-1430"></span><span>
</span><span id="line-1431"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#setOp"><span class="hs-identifier hs-type">setOp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1432"></span><span class="hs-operator">&gt;</span><span> </span><span id="setOp"><span class="annot"><span class="annottext">setOp :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
</span><a href="Language.SQL.SimpleSQL.Parse.html#setOp"><span class="hs-identifier hs-var hs-var">setOp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; SetQuantifier
-&gt; Corresponding
-&gt; QueryExpr
-&gt; QueryExpr
-&gt; QueryExpr
</span><a href="#local-6989586621679120405"><span class="hs-identifier hs-var">cq</span></a></span><span>
</span><span id="line-1433"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(SetOperatorName
 -&gt; SetQuantifier
 -&gt; Corresponding
 -&gt; QueryExpr
 -&gt; QueryExpr
 -&gt; QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (SetQuantifier
      -&gt; Corresponding -&gt; QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
</span><a href="#local-6989586621679120404"><span class="hs-identifier hs-var">setOpK</span></a></span><span>
</span><span id="line-1434"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (SetQuantifier
   -&gt; Corresponding -&gt; QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
-&gt; Parser SetQuantifier
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Corresponding -&gt; QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">SetQuantifier -&gt; Parser SetQuantifier -&gt; Parser SetQuantifier
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SQDefault"><span class="hs-identifier hs-var">SQDefault</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SetQuantifier
</span><a href="Language.SQL.SimpleSQL.Parse.html#duplicates"><span class="hs-identifier hs-var">duplicates</span></a></span><span>
</span><span id="line-1435"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Corresponding -&gt; QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
</span><a href="#local-6989586621679120403"><span class="hs-identifier hs-var">corr</span></a></span><span>
</span><span id="line-1436"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1437"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120405"><span class="annot"><span class="annottext">cq :: SetOperatorName
-&gt; SetQuantifier
-&gt; Corresponding
-&gt; QueryExpr
-&gt; QueryExpr
-&gt; QueryExpr
</span><a href="#local-6989586621679120405"><span class="hs-identifier hs-var hs-var">cq</span></a></span></span><span> </span><span id="local-6989586621679120402"><span class="annot"><span class="annottext">o :: SetOperatorName
</span><a href="#local-6989586621679120402"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679120401"><span class="annot"><span class="annottext">d :: SetQuantifier
</span><a href="#local-6989586621679120401"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679120400"><span class="annot"><span class="annottext">c :: Corresponding
</span><a href="#local-6989586621679120400"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679120399"><span class="annot"><span class="annottext">q0 :: QueryExpr
</span><a href="#local-6989586621679120399"><span class="hs-identifier hs-var">q0</span></a></span></span><span> </span><span id="local-6989586621679120398"><span class="annot"><span class="annottext">q1 :: QueryExpr
</span><a href="#local-6989586621679120398"><span class="hs-identifier hs-var">q1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">QueryExpr
-&gt; SetOperatorName
-&gt; SetQuantifier
-&gt; Corresponding
-&gt; QueryExpr
-&gt; QueryExpr
</span><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExprSetOp"><span class="hs-identifier hs-var">QueryExprSetOp</span></a></span><span> </span><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120399"><span class="hs-identifier hs-var">q0</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="#local-6989586621679120402"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">SetQuantifier
</span><a href="#local-6989586621679120401"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">Corresponding
</span><a href="#local-6989586621679120400"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">QueryExpr
</span><a href="#local-6989586621679120398"><span class="hs-identifier hs-var">q1</span></a></span><span>
</span><span id="line-1438"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120404"><span class="annot"><span class="annottext">setOpK :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
</span><a href="#local-6989586621679120404"><span class="hs-identifier hs-var hs-var">setOpK</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Union"><span class="hs-identifier hs-var">Union</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;union&quot;</span></span><span>
</span><span id="line-1439"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Intersect"><span class="hs-identifier hs-var">Intersect</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;intersect&quot;</span></span><span>
</span><span id="line-1440"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">SetOperatorName
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Except"><span class="hs-identifier hs-var">Except</span></a></span><span> </span><span class="annot"><span class="annottext">SetOperatorName
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;except&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1441"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
-&gt; FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity SetOperatorName
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;set operator&quot;</span></span><span>
</span><span id="line-1442"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120403"><span class="annot"><span class="annottext">corr :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
</span><a href="#local-6989586621679120403"><span class="hs-identifier hs-var hs-var">corr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Corresponding
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Corresponding
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Respectively"><span class="hs-identifier hs-var">Respectively</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Corresponding
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Corresponding"><span class="hs-identifier hs-var">Corresponding</span></a></span><span> </span><span class="annot"><span class="annottext">Corresponding
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity Corresponding
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;corresponding&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1443"></span><span>
</span><span id="line-1444"></span><span>
</span><span id="line-1445"></span><span class="hs-identifier">wrapper</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">query</span><span> </span><span class="hs-identifier">expr</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">ignores</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">trailing</span><span> </span><span class="hs-identifier">semicolon</span><span class="hs-operator">.</span><span>
</span><span id="line-1446"></span><span>
</span><span id="line-1447"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">change</span><span> </span><span class="hs-identifier">style</span><span>
</span><span id="line-1448"></span><span>
</span><span id="line-1449"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#topLevelQueryExpr"><span class="hs-identifier hs-type">topLevelQueryExpr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#QueryExpr"><span class="hs-identifier hs-type">QueryExpr</span></a></span><span>
</span><span id="line-1450"></span><span class="hs-operator">&gt;</span><span> </span><span id="topLevelQueryExpr"><span class="annot"><span class="annottext">topLevelQueryExpr :: Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#topLevelQueryExpr"><span class="hs-identifier hs-var hs-var">topLevelQueryExpr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; QueryExpr)
-&gt; Parser QueryExpr
forall t s a.
GenParser t s a -&gt; GenParser t s (a -&gt; a) -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%3F%3F%3E"><span class="hs-operator hs-var">&lt;??&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">QueryExpr -&gt; QueryExpr
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; QueryExpr)
-&gt; Parser Char
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; QueryExpr)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#semi"><span class="hs-identifier hs-var">semi</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1451"></span><span>
</span><span id="line-1452"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#topLevelStatement"><span class="hs-identifier hs-type">topLevelStatement</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1453"></span><span class="hs-operator">&gt;</span><span> </span><span id="topLevelStatement"><span class="annot"><span class="annottext">topLevelStatement :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#topLevelStatement"><span class="hs-identifier hs-var hs-var">topLevelStatement</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#statement"><span class="hs-identifier hs-var">statement</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Statement
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (Statement -&gt; Statement)
-&gt; Parser Statement
forall t s a.
GenParser t s a -&gt; GenParser t s (a -&gt; a) -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%3F%3F%3E"><span class="hs-operator hs-var">&lt;??&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Statement -&gt; Statement
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span> </span><span class="annot"><span class="annottext">(Statement -&gt; Statement)
-&gt; Parser Char
-&gt; GenParser
     ((FilePath, Int, Int), Token) Dialect (Statement -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#semi"><span class="hs-identifier hs-var">semi</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1454"></span><span>
</span><span id="line-1455"></span><span class="hs-comment">-------------------------</span><span>
</span><span id="line-1456"></span><span>
</span><span id="line-1457"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Statements</span><span>
</span><span id="line-1458"></span><span>
</span><span id="line-1459"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#statement"><span class="hs-identifier hs-type">statement</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1460"></span><span class="hs-operator">&gt;</span><span> </span><span id="statement"><span class="annot"><span class="annottext">statement :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#statement"><span class="hs-identifier hs-var hs-var">statement</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser Statement] -&gt; Parser Statement
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1461"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;create&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Parser Statement] -&gt; Parser Statement
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createSchema"><span class="hs-identifier hs-var">createSchema</span></a></span><span>
</span><span id="line-1462"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createTable"><span class="hs-identifier hs-var">createTable</span></a></span><span>
</span><span id="line-1463"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createView"><span class="hs-identifier hs-var">createView</span></a></span><span>
</span><span id="line-1464"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createDomain"><span class="hs-identifier hs-var">createDomain</span></a></span><span>
</span><span id="line-1465"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createSequence"><span class="hs-identifier hs-var">createSequence</span></a></span><span>
</span><span id="line-1466"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createRole"><span class="hs-identifier hs-var">createRole</span></a></span><span>
</span><span id="line-1467"></span><span class="hs-operator">&gt;</span><span>                                  </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createAssertion"><span class="hs-identifier hs-var">createAssertion</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1468"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;alter&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Parser Statement] -&gt; Parser Statement
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterTable"><span class="hs-identifier hs-var">alterTable</span></a></span><span>
</span><span id="line-1469"></span><span class="hs-operator">&gt;</span><span>                                 </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterDomain"><span class="hs-identifier hs-var">alterDomain</span></a></span><span>
</span><span id="line-1470"></span><span class="hs-operator">&gt;</span><span>                                 </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterSequence"><span class="hs-identifier hs-var">alterSequence</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1471"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Parser Statement] -&gt; Parser Statement
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropSchema"><span class="hs-identifier hs-var">dropSchema</span></a></span><span>
</span><span id="line-1472"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropTable"><span class="hs-identifier hs-var">dropTable</span></a></span><span>
</span><span id="line-1473"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropView"><span class="hs-identifier hs-var">dropView</span></a></span><span>
</span><span id="line-1474"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropDomain"><span class="hs-identifier hs-var">dropDomain</span></a></span><span>
</span><span id="line-1475"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropSequence"><span class="hs-identifier hs-var">dropSequence</span></a></span><span>
</span><span id="line-1476"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropRole"><span class="hs-identifier hs-var">dropRole</span></a></span><span>
</span><span id="line-1477"></span><span class="hs-operator">&gt;</span><span>                                </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropAssertion"><span class="hs-identifier hs-var">dropAssertion</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1478"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#delete"><span class="hs-identifier hs-var">delete</span></a></span><span>
</span><span id="line-1479"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#truncateSt"><span class="hs-identifier hs-var">truncateSt</span></a></span><span>
</span><span id="line-1480"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#insert"><span class="hs-identifier hs-var">insert</span></a></span><span>
</span><span id="line-1481"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#update"><span class="hs-identifier hs-var">update</span></a></span><span>
</span><span id="line-1482"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#startTransaction"><span class="hs-identifier hs-var">startTransaction</span></a></span><span>
</span><span id="line-1483"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#savepoint"><span class="hs-identifier hs-var">savepoint</span></a></span><span>
</span><span id="line-1484"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#releaseSavepoint"><span class="hs-identifier hs-var">releaseSavepoint</span></a></span><span>
</span><span id="line-1485"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#commit"><span class="hs-identifier hs-var">commit</span></a></span><span>
</span><span id="line-1486"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#rollback"><span class="hs-identifier hs-var">rollback</span></a></span><span>
</span><span id="line-1487"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#grant"><span class="hs-identifier hs-var">grant</span></a></span><span>
</span><span id="line-1488"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#revoke"><span class="hs-identifier hs-var">revoke</span></a></span><span>
</span><span id="line-1489"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">QueryExpr -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SelectStatement"><span class="hs-identifier hs-var">SelectStatement</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; Statement) -&gt; Parser QueryExpr -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span>
</span><span id="line-1490"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">]</span><span>
</span><span id="line-1491"></span><span>
</span><span id="line-1492"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createSchema"><span class="hs-identifier hs-type">createSchema</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1493"></span><span class="hs-operator">&gt;</span><span> </span><span id="createSchema"><span class="annot"><span class="annottext">createSchema :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createSchema"><span class="hs-identifier hs-var hs-var">createSchema</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;schema&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1494"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateSchema"><span class="hs-identifier hs-var">CreateSchema</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; Statement) -&gt; Parser [Name] -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1495"></span><span>
</span><span id="line-1496"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createTable"><span class="hs-identifier hs-type">createTable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1497"></span><span class="hs-operator">&gt;</span><span> </span><span id="createTable"><span class="annot"><span class="annottext">createTable :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createTable"><span class="hs-identifier hs-var hs-var">createTable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1498"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; [TableElement] -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateTable"><span class="hs-identifier hs-var">CreateTable</span></a></span><span>
</span><span id="line-1499"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; [TableElement] -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([TableElement] -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1500"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: is this order mandatory or is it a perm?</span><span>
</span><span id="line-1501"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([TableElement] -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [TableElement]
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [TableElement]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [TableElement]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser TableElement
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [TableElement]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Maybe [Name] -&gt; TableConstraint -&gt; TableElement)
-&gt; (Maybe [Name], TableConstraint) -&gt; TableElement
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Maybe [Name] -&gt; TableConstraint -&gt; TableElement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TableConstraintDef"><span class="hs-identifier hs-var">TableConstraintDef</span></a></span><span> </span><span class="annot"><span class="annottext">((Maybe [Name], TableConstraint) -&gt; TableElement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name], TableConstraint)
-&gt; Parser TableElement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], TableConstraint)
</span><a href="Language.SQL.SimpleSQL.Parse.html#tableConstraintDef"><span class="hs-identifier hs-var">tableConstraintDef</span></a></span><span>
</span><span id="line-1502"></span><span class="hs-operator">&gt;</span><span>                            </span><span class="annot"><span class="annottext">Parser TableElement -&gt; Parser TableElement -&gt; Parser TableElement
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ColumnDef -&gt; TableElement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TableColumnDef"><span class="hs-identifier hs-var">TableColumnDef</span></a></span><span> </span><span class="annot"><span class="annottext">(ColumnDef -&gt; TableElement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
-&gt; Parser TableElement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
</span><a href="Language.SQL.SimpleSQL.Parse.html#columnDef"><span class="hs-identifier hs-var">columnDef</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1503"></span><span>
</span><span id="line-1504"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#columnDef"><span class="hs-identifier hs-type">columnDef</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ColumnDef"><span class="hs-identifier hs-type">ColumnDef</span></a></span><span>
</span><span id="line-1505"></span><span class="hs-operator">&gt;</span><span> </span><span id="columnDef"><span class="annot"><span class="annottext">columnDef :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
</span><a href="Language.SQL.SimpleSQL.Parse.html#columnDef"><span class="hs-identifier hs-var hs-var">columnDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; TypeName
-&gt; Maybe DefaultClause
-&gt; [ColConstraintDef]
-&gt; ColumnDef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColumnDef"><span class="hs-identifier hs-var">ColumnDef</span></a></span><span> </span><span class="annot"><span class="annottext">(Name
 -&gt; TypeName
 -&gt; Maybe DefaultClause
 -&gt; [ColConstraintDef]
 -&gt; ColumnDef)
-&gt; Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TypeName
      -&gt; Maybe DefaultClause -&gt; [ColConstraintDef] -&gt; ColumnDef)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TypeName
   -&gt; Maybe DefaultClause -&gt; [ColConstraintDef] -&gt; ColumnDef)
-&gt; Parser TypeName
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe DefaultClause -&gt; [ColConstraintDef] -&gt; ColumnDef)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span>
</span><span id="line-1506"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe DefaultClause -&gt; [ColConstraintDef] -&gt; ColumnDef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe DefaultClause)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ColConstraintDef] -&gt; ColumnDef)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe DefaultClause)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
</span><a href="#local-6989586621679120355"><span class="hs-identifier hs-var">defaultClause</span></a></span><span>
</span><span id="line-1507"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ColConstraintDef] -&gt; ColumnDef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ColConstraintDef]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ColConstraintDef]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ColConstraintDef]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ColConstraintDef]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraintDef
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ColConstraintDef]
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m [a]
</span><span class="hs-identifier hs-var">many1</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraintDef
</span><a href="Language.SQL.SimpleSQL.Parse.html#colConstraintDef"><span class="hs-identifier hs-var">colConstraintDef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1508"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1509"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120355"><span class="annot"><span class="annottext">defaultClause :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
</span><a href="#local-6989586621679120355"><span class="hs-identifier hs-var hs-var">defaultClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span>
</span><span id="line-1510"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1511"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ScalarExpr -&gt; DefaultClause
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultClause"><span class="hs-identifier hs-var">DefaultClause</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; DefaultClause)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1512"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-comment">-- todo: left factor</span><span>
</span><span id="line-1513"></span><span class="hs-operator">&gt;</span><span>        </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;generated&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;always&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1514"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">ScalarExpr -&gt; DefaultClause
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GenerationClause"><span class="hs-identifier hs-var">GenerationClause</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; DefaultClause)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1515"></span><span class="hs-operator">&gt;</span><span>        </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;generated&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1516"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">IdentityWhen -&gt; [SequenceGeneratorOption] -&gt; DefaultClause
</span><a href="Language.SQL.SimpleSQL.Syntax.html#IdentityColumnSpec"><span class="hs-identifier hs-var">IdentityColumnSpec</span></a></span><span>
</span><span id="line-1517"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(IdentityWhen -&gt; [SequenceGeneratorOption] -&gt; DefaultClause)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SequenceGeneratorOption] -&gt; DefaultClause)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IdentityWhen
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GeneratedAlways"><span class="hs-identifier hs-var">GeneratedAlways</span></a></span><span> </span><span class="annot"><span class="annottext">IdentityWhen
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;always&quot;</span></span><span>
</span><span id="line-1518"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">IdentityWhen
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GeneratedByDefault"><span class="hs-identifier hs-var">GeneratedByDefault</span></a></span><span> </span><span class="annot"><span class="annottext">IdentityWhen
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityWhen
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;by&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1519"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([SequenceGeneratorOption] -&gt; DefaultClause)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DefaultClause
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;identity&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-1520"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">[SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  [SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  [SequenceGeneratorOption]
</span><a href="Language.SQL.SimpleSQL.Parse.html#sequenceGeneratorOptions"><span class="hs-identifier hs-var">sequenceGeneratorOptions</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1521"></span><span class="hs-operator">&gt;</span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-1522"></span><span>
</span><span id="line-1523"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#tableConstraintDef"><span class="hs-identifier hs-type">tableConstraintDef</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#TableConstraint"><span class="hs-identifier hs-type">TableConstraint</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1524"></span><span class="hs-operator">&gt;</span><span> </span><span id="tableConstraintDef"><span class="annot"><span class="annottext">tableConstraintDef :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], TableConstraint)
</span><a href="Language.SQL.SimpleSQL.Parse.html#tableConstraintDef"><span class="hs-identifier hs-var hs-var">tableConstraintDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1525"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span>
</span><span id="line-1526"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(Maybe [Name]
 -&gt; TableConstraint -&gt; (Maybe [Name], TableConstraint))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TableConstraint -&gt; (Maybe [Name], TableConstraint))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1527"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TableConstraint -&gt; (Maybe [Name], TableConstraint))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name], TableConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120347"><span class="hs-identifier hs-var">unique</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120346"><span class="hs-identifier hs-var">primaryKey</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120345"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120344"><span class="hs-identifier hs-var">references</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1528"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1529"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120347"><span class="annot"><span class="annottext">unique :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120347"><span class="hs-identifier hs-var hs-var">unique</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unique&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1530"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[Name] -&gt; TableConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TableUniqueConstraint"><span class="hs-identifier hs-var">TableUniqueConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; TableConstraint)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1531"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120346"><span class="annot"><span class="annottext">primaryKey :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120346"><span class="hs-identifier hs-var hs-var">primaryKey</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;primary&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;key&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1532"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[Name] -&gt; TableConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TablePrimaryKeyConstraint"><span class="hs-identifier hs-var">TablePrimaryKeyConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; TableConstraint)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1533"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120345"><span class="annot"><span class="annottext">check :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120345"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; TableConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TableCheckConstraint"><span class="hs-identifier hs-var">TableCheckConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; TableConstraint)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1534"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120344"><span class="annot"><span class="annottext">references :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
</span><a href="#local-6989586621679120344"><span class="hs-identifier hs-var hs-var">references</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;foreign&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;key&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1535"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120340"><span class="annot"><span class="annottext">cs :: [Name]
</span><a href="#local-6989586621679120340"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679120339"><span class="annot"><span class="annottext">ft :: [Name]
</span><a href="#local-6989586621679120339"><span class="hs-identifier hs-var">ft</span></a></span></span><span> </span><span id="local-6989586621679120338"><span class="annot"><span class="annottext">ftcs :: Maybe [Name]
</span><a href="#local-6989586621679120338"><span class="hs-identifier hs-var">ftcs</span></a></span></span><span> </span><span id="local-6989586621679120337"><span class="annot"><span class="annottext">m :: ReferenceMatch
</span><a href="#local-6989586621679120337"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120336"><span class="annot"><span class="annottext">u :: ReferentialAction
</span><a href="#local-6989586621679120336"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120335"><span class="annot"><span class="annottext">d :: ReferentialAction
</span><a href="#local-6989586621679120335"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; [Name]
-&gt; Maybe [Name]
-&gt; ReferenceMatch
-&gt; ReferentialAction
-&gt; ReferentialAction
-&gt; TableConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#TableReferencesConstraint"><span class="hs-identifier hs-var">TableReferencesConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120340"><span class="hs-identifier hs-var">cs</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120339"><span class="hs-identifier hs-var">ft</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [Name]
</span><a href="#local-6989586621679120338"><span class="hs-identifier hs-var">ftcs</span></a></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="#local-6989586621679120337"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="#local-6989586621679120336"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="#local-6989586621679120335"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1536"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">([Name]
 -&gt; [Name]
 -&gt; Maybe [Name]
 -&gt; ReferenceMatch
 -&gt; (ReferentialAction, ReferentialAction)
 -&gt; TableConstraint)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name]
      -&gt; Maybe [Name]
      -&gt; ReferenceMatch
      -&gt; (ReferentialAction, ReferentialAction)
      -&gt; TableConstraint)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1537"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name]
   -&gt; Maybe [Name]
   -&gt; ReferenceMatch
   -&gt; (ReferentialAction, ReferentialAction)
   -&gt; TableConstraint)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name]
      -&gt; ReferenceMatch
      -&gt; (ReferentialAction, ReferentialAction)
      -&gt; TableConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;references&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1538"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name]
   -&gt; ReferenceMatch
   -&gt; (ReferentialAction, ReferentialAction)
   -&gt; TableConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ReferenceMatch
      -&gt; (ReferentialAction, ReferentialAction) -&gt; TableConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1539"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ReferenceMatch
   -&gt; (ReferentialAction, ReferentialAction) -&gt; TableConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ((ReferentialAction, ReferentialAction) -&gt; TableConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Parse.html#refMatch"><span class="hs-identifier hs-var">refMatch</span></a></span><span>
</span><span id="line-1540"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ((ReferentialAction, ReferentialAction) -&gt; TableConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ReferentialAction, ReferentialAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity TableConstraint
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ReferentialAction, ReferentialAction)
</span><a href="Language.SQL.SimpleSQL.Parse.html#refActions"><span class="hs-identifier hs-var">refActions</span></a></span><span>
</span><span id="line-1541"></span><span>
</span><span id="line-1542"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#refMatch"><span class="hs-identifier hs-type">refMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ReferenceMatch"><span class="hs-identifier hs-type">ReferenceMatch</span></a></span><span>
</span><span id="line-1543"></span><span class="hs-operator">&gt;</span><span> </span><span id="refMatch"><span class="annot"><span class="annottext">refMatch :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Parse.html#refMatch"><span class="hs-identifier hs-var hs-var">refMatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultReferenceMatch"><span class="hs-identifier hs-var">DefaultReferenceMatch</span></a></span><span>
</span><span id="line-1544"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;match&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span>
</span><span id="line-1545"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MatchFull"><span class="hs-identifier hs-var">MatchFull</span></a></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;full&quot;</span></span><span>
</span><span id="line-1546"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MatchPartial"><span class="hs-identifier hs-var">MatchPartial</span></a></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;partial&quot;</span></span><span>
</span><span id="line-1547"></span><span class="hs-operator">&gt;</span><span>                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Syntax.html#MatchSimple"><span class="hs-identifier hs-var">MatchSimple</span></a></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;simple&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1548"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#refActions"><span class="hs-identifier hs-type">refActions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ReferentialAction"><span class="hs-identifier hs-type">ReferentialAction</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ReferentialAction"><span class="hs-identifier hs-type">ReferentialAction</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1549"></span><span class="hs-operator">&gt;</span><span> </span><span id="refActions"><span class="annot"><span class="annottext">refActions :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ReferentialAction, ReferentialAction)
</span><a href="Language.SQL.SimpleSQL.Parse.html#refActions"><span class="hs-identifier hs-var hs-var">refActions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (ReferentialAction, ReferentialAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ReferentialAction, ReferentialAction)
forall s tok st a.
Stream s Identity tok =&gt;
StreamPermParser s st a -&gt; Parsec s st a
</span><span class="hs-identifier hs-var">permute</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(ReferentialAction
 -&gt; ReferentialAction -&gt; (ReferentialAction, ReferentialAction))
-&gt; (ReferentialAction,
    Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction)
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (ReferentialAction -&gt; (ReferentialAction, ReferentialAction))
forall s tok a b st.
Stream s Identity tok =&gt;
(a -&gt; b) -&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;$?&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultReferentialAction"><span class="hs-identifier hs-var">DefaultReferentialAction</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120326"><span class="hs-identifier hs-var">onUpdate</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1550"></span><span class="hs-operator">&gt;</span><span>                           </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (ReferentialAction -&gt; (ReferentialAction, ReferentialAction))
-&gt; (ReferentialAction,
    Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction)
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (ReferentialAction, ReferentialAction)
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultReferentialAction"><span class="hs-identifier hs-var">DefaultReferentialAction</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120325"><span class="hs-identifier hs-var">onDelete</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1551"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1552"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: left factor?</span><span>
</span><span id="line-1553"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120326"><span class="annot"><span class="annottext">onUpdate :: Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120326"><span class="hs-identifier hs-var hs-var">onUpdate</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;on&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;update&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120324"><span class="hs-identifier hs-var">referentialAction</span></a></span><span>
</span><span id="line-1554"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120325"><span class="annot"><span class="annottext">onDelete :: Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120325"><span class="hs-identifier hs-var hs-var">onDelete</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;on&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;delete&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120324"><span class="hs-identifier hs-var">referentialAction</span></a></span><span>
</span><span id="line-1555"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120324"><span class="annot"><span class="annottext">referentialAction :: Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
</span><a href="#local-6989586621679120324"><span class="hs-identifier hs-var hs-var">referentialAction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction]
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span>
</span><span id="line-1556"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RefCascade"><span class="hs-identifier hs-var">RefCascade</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cascade&quot;</span></span><span>
</span><span id="line-1557"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- todo: left factor?</span><span>
</span><span id="line-1558"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RefSetNull"><span class="hs-identifier hs-var">RefSetNull</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;null&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1559"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RefSetDefault"><span class="hs-identifier hs-var">RefSetDefault</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1560"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RefRestrict"><span class="hs-identifier hs-var">RefRestrict</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;restrict&quot;</span></span><span>
</span><span id="line-1561"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RefNoAction"><span class="hs-identifier hs-var">RefNoAction</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parsec [((FilePath, Int, Int), Token)] Dialect ReferentialAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;no&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;action&quot;</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1562"></span><span>
</span><span id="line-1563"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#colConstraintDef"><span class="hs-identifier hs-type">colConstraintDef</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#ColConstraintDef"><span class="hs-identifier hs-type">ColConstraintDef</span></a></span><span>
</span><span id="line-1564"></span><span class="hs-operator">&gt;</span><span> </span><span id="colConstraintDef"><span class="annot"><span class="annottext">colConstraintDef :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraintDef
</span><a href="Language.SQL.SimpleSQL.Parse.html#colConstraintDef"><span class="hs-identifier hs-var hs-var">colConstraintDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1565"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Maybe [Name] -&gt; ColConstraint -&gt; ColConstraintDef
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColConstraintDef"><span class="hs-identifier hs-var">ColConstraintDef</span></a></span><span>
</span><span id="line-1566"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(Maybe [Name] -&gt; ColConstraint -&gt; ColConstraintDef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ColConstraint -&gt; ColConstraintDef)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1567"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ColConstraint -&gt; ColConstraintDef)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraintDef
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120317"><span class="hs-identifier hs-var">notNull</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120316"><span class="hs-identifier hs-var">unique</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120315"><span class="hs-identifier hs-var">primaryKey</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120314"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120313"><span class="hs-identifier hs-var">references</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1568"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1569"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120317"><span class="annot"><span class="annottext">notNull :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120317"><span class="hs-identifier hs-var hs-var">notNull</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ColConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColNotNullConstraint"><span class="hs-identifier hs-var">ColNotNullConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">ColConstraint
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;null&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1570"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120316"><span class="annot"><span class="annottext">unique :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120316"><span class="hs-identifier hs-var hs-var">unique</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ColConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColUniqueConstraint"><span class="hs-identifier hs-var">ColUniqueConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">ColConstraint
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unique&quot;</span></span><span>
</span><span id="line-1571"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120315"><span class="annot"><span class="annottext">primaryKey :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120315"><span class="hs-identifier hs-var hs-var">primaryKey</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ColConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColPrimaryKeyConstraint"><span class="hs-identifier hs-var">ColPrimaryKeyConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">ColConstraint
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;primary&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;key&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1572"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120314"><span class="annot"><span class="annottext">check :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120314"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; ColConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColCheckConstraint"><span class="hs-identifier hs-var">ColCheckConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; ColConstraint)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1573"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120313"><span class="annot"><span class="annottext">references :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
</span><a href="#local-6989586621679120313"><span class="hs-identifier hs-var hs-var">references</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;references&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1574"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120308"><span class="annot"><span class="annottext">t :: [Name]
</span><a href="#local-6989586621679120308"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679120307"><span class="annot"><span class="annottext">c :: Maybe Name
</span><a href="#local-6989586621679120307"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679120306"><span class="annot"><span class="annottext">m :: ReferenceMatch
</span><a href="#local-6989586621679120306"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120305"><span class="annot"><span class="annottext">ou :: ReferentialAction
</span><a href="#local-6989586621679120305"><span class="hs-identifier hs-var">ou</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120304"><span class="annot"><span class="annottext">od :: ReferentialAction
</span><a href="#local-6989586621679120304"><span class="hs-identifier hs-var">od</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Name]
-&gt; Maybe Name
-&gt; ReferenceMatch
-&gt; ReferentialAction
-&gt; ReferentialAction
-&gt; ColConstraint
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ColReferencesConstraint"><span class="hs-identifier hs-var">ColReferencesConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679120308"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Name
</span><a href="#local-6989586621679120307"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ReferenceMatch
</span><a href="#local-6989586621679120306"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="#local-6989586621679120305"><span class="hs-identifier hs-var">ou</span></a></span><span> </span><span class="annot"><span class="annottext">ReferentialAction
</span><a href="#local-6989586621679120304"><span class="hs-identifier hs-var">od</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1575"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">([Name]
 -&gt; Maybe Name
 -&gt; ReferenceMatch
 -&gt; (ReferentialAction, ReferentialAction)
 -&gt; ColConstraint)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Name
      -&gt; ReferenceMatch
      -&gt; (ReferentialAction, ReferentialAction)
      -&gt; ColConstraint)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1576"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Name
   -&gt; ReferenceMatch
   -&gt; (ReferentialAction, ReferentialAction)
   -&gt; ColConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ReferenceMatch
      -&gt; (ReferentialAction, ReferentialAction) -&gt; ColConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser Name
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1577"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ReferenceMatch
   -&gt; (ReferentialAction, ReferentialAction) -&gt; ColConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ((ReferentialAction, ReferentialAction) -&gt; ColConstraint)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity ReferenceMatch
</span><a href="Language.SQL.SimpleSQL.Parse.html#refMatch"><span class="hs-identifier hs-var">refMatch</span></a></span><span>
</span><span id="line-1578"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ((ReferentialAction, ReferentialAction) -&gt; ColConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ReferentialAction, ReferentialAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColConstraint
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ReferentialAction, ReferentialAction)
</span><a href="Language.SQL.SimpleSQL.Parse.html#refActions"><span class="hs-identifier hs-var">refActions</span></a></span><span>
</span><span id="line-1579"></span><span>
</span><span id="line-1580"></span><span class="hs-identifier">slightly</span><span> </span><span class="hs-identifier">hacky</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">signed</span><span> </span><span class="hs-identifier">integers</span><span>
</span><span id="line-1581"></span><span>
</span><span id="line-1582"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-type">signedInteger</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-1583"></span><span class="hs-operator">&gt;</span><span> </span><span id="signedInteger"><span class="annot"><span class="annottext">signedInteger :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var hs-var">signedInteger</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1584"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Integer -&gt; Integer -&gt; Integer
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(*)</span></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; Integer -&gt; Integer)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Integer -&gt; Integer)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">Integer
-&gt; Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;+&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">-</span><span class="annot"><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Integer
-&gt; Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;-&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1585"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Integer -&gt; Integer)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var">unsignedInteger</span></a></span><span>
</span><span id="line-1586"></span><span>
</span><span id="line-1587"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#sequenceGeneratorOptions"><span class="hs-identifier hs-type">sequenceGeneratorOptions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#SequenceGeneratorOption"><span class="hs-identifier hs-type">SequenceGeneratorOption</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1588"></span><span class="hs-operator">&gt;</span><span> </span><span id="sequenceGeneratorOptions"><span class="annot"><span class="annottext">sequenceGeneratorOptions :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  [SequenceGeneratorOption]
</span><a href="Language.SQL.SimpleSQL.Parse.html#sequenceGeneratorOptions"><span class="hs-identifier hs-var hs-var">sequenceGeneratorOptions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1589"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- todo: could try to combine exclusive options</span><span>
</span><span id="line-1590"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- such as cycle and nocycle</span><span>
</span><span id="line-1591"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- sort out options which are sometimes not allowed</span><span>
</span><span id="line-1592"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-comment">-- as datatype, and restart with</span><span>
</span><span id="line-1593"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)] Dialect [SequenceGeneratorOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
forall s tok st a.
Stream s Identity tok =&gt;
StreamPermParser s st a -&gt; Parsec s st a
</span><span class="hs-identifier hs-var">permute</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120300"><span class="annot"><span class="annottext">a :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120300"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679120299"><span class="annot"><span class="annottext">b :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120299"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679120298"><span class="annot"><span class="annottext">c :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120298"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679120297"><span class="annot"><span class="annottext">d :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120297"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span id="local-6989586621679120296"><span class="annot"><span class="annottext">e :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120296"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679120295"><span class="annot"><span class="annottext">f :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120295"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679120294"><span class="annot"><span class="annottext">g :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120294"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621679120293"><span class="annot"><span class="annottext">h :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120293"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621679120292"><span class="annot"><span class="annottext">j :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120292"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span id="local-6989586621679120291"><span class="annot"><span class="annottext">k :: Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120291"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[Maybe SequenceGeneratorOption] -&gt; [SequenceGeneratorOption]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120300"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120299"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120298"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120297"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120296"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120295"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120294"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120293"><span class="hs-identifier hs-var">h</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120292"><span class="hs-identifier hs-var">j</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Maybe SequenceGeneratorOption
</span><a href="#local-6989586621679120291"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1594"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">(Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; Maybe SequenceGeneratorOption
 -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok a b st.
Stream s Identity tok =&gt;
(a -&gt; b) -&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;$?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120289"><span class="hs-identifier hs-var">startWith</span></a></span><span>
</span><span id="line-1595"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120288"><span class="hs-identifier hs-var">dataType</span></a></span><span>
</span><span id="line-1596"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120287"><span class="hs-identifier hs-var">restart</span></a></span><span>
</span><span id="line-1597"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120286"><span class="hs-identifier hs-var">incrementBy</span></a></span><span>
</span><span id="line-1598"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120285"><span class="hs-identifier hs-var">maxValue</span></a></span><span>
</span><span id="line-1599"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120284"><span class="hs-identifier hs-var">noMaxValue</span></a></span><span>
</span><span id="line-1600"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption
      -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120283"><span class="hs-identifier hs-var">minValue</span></a></span><span>
</span><span id="line-1601"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption
   -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption
      -&gt; Maybe SequenceGeneratorOption -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120282"><span class="hs-identifier hs-var">noMinValue</span></a></span><span>
</span><span id="line-1602"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption
   -&gt; Maybe SequenceGeneratorOption -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)]
     Dialect
     (Maybe SequenceGeneratorOption -&gt; [SequenceGeneratorOption])
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120281"><span class="hs-identifier hs-var">scycle</span></a></span><span>
</span><span id="line-1603"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">StreamPermParser
  [((FilePath, Int, Int), Token)]
  Dialect
  (Maybe SequenceGeneratorOption -&gt; [SequenceGeneratorOption])
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
-&gt; StreamPermParser
     [((FilePath, Int, Int), Token)] Dialect [SequenceGeneratorOption]
forall s tok st a b.
Stream s Identity tok =&gt;
StreamPermParser s st (a -&gt; b)
-&gt; (a, Parsec s st a) -&gt; StreamPermParser s st b
</span><span class="hs-operator hs-var">&lt;|?&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
-&gt; (Maybe SequenceGeneratorOption,
    Parsec
      [((FilePath, Int, Int), Token)]
      Dialect
      (Maybe SequenceGeneratorOption))
forall (f :: * -&gt; *) a a.
Functor f =&gt;
f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var">nj</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120280"><span class="hs-identifier hs-var">noCycle</span></a></span><span>
</span><span id="line-1604"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="hs-special">)</span><span>
</span><span id="line-1605"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1606"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120290"><span class="annot"><span class="annottext">nj :: f a -&gt; (Maybe a, f (Maybe a))
</span><a href="#local-6989586621679120290"><span class="hs-identifier hs-var hs-var">nj</span></a></span></span><span> </span><span id="local-6989586621679120279"><span class="annot"><span class="annottext">p :: f a
</span><a href="#local-6989586621679120279"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; f a -&gt; f (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679120279"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1607"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120289"><span class="annot"><span class="annottext">startWith :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120289"><span class="hs-identifier hs-var hs-var">startWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;start&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1608"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">Integer -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGOStartWith"><span class="hs-identifier hs-var">SGOStartWith</span></a></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; SequenceGeneratorOption)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var">signedInteger</span></a></span><span>
</span><span id="line-1609"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120288"><span class="annot"><span class="annottext">dataType :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120288"><span class="hs-identifier hs-var hs-var">dataType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1610"></span><span class="hs-operator">&gt;</span><span>                </span><span class="annot"><span class="annottext">TypeName -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGODataType"><span class="hs-identifier hs-var">SGODataType</span></a></span><span> </span><span class="annot"><span class="annottext">(TypeName -&gt; SequenceGeneratorOption)
-&gt; Parser TypeName
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span>
</span><span id="line-1611"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120287"><span class="annot"><span class="annottext">restart :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120287"><span class="hs-identifier hs-var hs-var">restart</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;restart&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1612"></span><span class="hs-operator">&gt;</span><span>               </span><span class="annot"><span class="annottext">Maybe Integer -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGORestart"><span class="hs-identifier hs-var">SGORestart</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe Integer -&gt; SequenceGeneratorOption)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Integer)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var">signedInteger</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1613"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120286"><span class="annot"><span class="annottext">incrementBy :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120286"><span class="hs-identifier hs-var hs-var">incrementBy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;increment&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;by&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1614"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">Integer -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGOIncrementBy"><span class="hs-identifier hs-var">SGOIncrementBy</span></a></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; SequenceGeneratorOption)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var">signedInteger</span></a></span><span>
</span><span id="line-1615"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120285"><span class="annot"><span class="annottext">maxValue :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120285"><span class="hs-identifier hs-var hs-var">maxValue</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;maxvalue&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1616"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">Integer -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGOMaxValue"><span class="hs-identifier hs-var">SGOMaxValue</span></a></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; SequenceGeneratorOption)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var">signedInteger</span></a></span><span>
</span><span id="line-1617"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120284"><span class="annot"><span class="annottext">noMaxValue :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120284"><span class="hs-identifier hs-var hs-var">noMaxValue</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGONoMaxValue"><span class="hs-identifier hs-var">SGONoMaxValue</span></a></span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;no&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;maxvalue&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1618"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120283"><span class="annot"><span class="annottext">minValue :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120283"><span class="hs-identifier hs-var hs-var">minValue</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;minvalue&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1619"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">Integer -&gt; SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGOMinValue"><span class="hs-identifier hs-var">SGOMinValue</span></a></span><span> </span><span class="annot"><span class="annottext">(Integer -&gt; SequenceGeneratorOption)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#signedInteger"><span class="hs-identifier hs-var">signedInteger</span></a></span><span>
</span><span id="line-1620"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120282"><span class="annot"><span class="annottext">noMinValue :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120282"><span class="hs-identifier hs-var hs-var">noMinValue</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGONoMinValue"><span class="hs-identifier hs-var">SGONoMinValue</span></a></span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;no&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;minvalue&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1621"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120281"><span class="annot"><span class="annottext">scycle :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120281"><span class="hs-identifier hs-var hs-var">scycle</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGOCycle"><span class="hs-identifier hs-var">SGOCycle</span></a></span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cycle&quot;</span></span><span>
</span><span id="line-1622"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120280"><span class="annot"><span class="annottext">noCycle :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  SequenceGeneratorOption
</span><a href="#local-6989586621679120280"><span class="hs-identifier hs-var hs-var">noCycle</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SGONoCycle"><span class="hs-identifier hs-var">SGONoCycle</span></a></span><span> </span><span class="annot"><span class="annottext">SequenceGeneratorOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     SequenceGeneratorOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;no&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;cycle&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1623"></span><span>
</span><span id="line-1624"></span><span>
</span><span id="line-1625"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#alterTable"><span class="hs-identifier hs-type">alterTable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1626"></span><span class="hs-operator">&gt;</span><span> </span><span id="alterTable"><span class="annot"><span class="annottext">alterTable :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterTable"><span class="hs-identifier hs-var hs-var">alterTable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1627"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- the choices have been ordered so that it works</span><span>
</span><span id="line-1628"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; AlterTableAction -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterTable"><span class="hs-identifier hs-var">AlterTable</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; AlterTableAction -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (AlterTableAction -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (AlterTableAction -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120267"><span class="hs-identifier hs-var">addConstraint</span></a></span><span>
</span><span id="line-1629"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120266"><span class="hs-identifier hs-var">dropConstraint</span></a></span><span>
</span><span id="line-1630"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120265"><span class="hs-identifier hs-var">addColumnDef</span></a></span><span>
</span><span id="line-1631"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120264"><span class="hs-identifier hs-var">alterColumn</span></a></span><span>
</span><span id="line-1632"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120263"><span class="hs-identifier hs-var">dropColumn</span></a></span><span>
</span><span id="line-1633"></span><span class="hs-operator">&gt;</span><span>                                     </span><span class="hs-special">]</span><span>
</span><span id="line-1634"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1635"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120265"><span class="annot"><span class="annottext">addColumnDef :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120265"><span class="hs-identifier hs-var hs-var">addColumnDef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;add&quot;</span></span><span>
</span><span id="line-1636"></span><span class="hs-operator">&gt;</span><span>                         </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;column&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1637"></span><span class="hs-operator">&gt;</span><span>                    </span><span class="annot"><span class="annottext">ColumnDef -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AddColumnDef"><span class="hs-identifier hs-var">AddColumnDef</span></a></span><span> </span><span class="annot"><span class="annottext">(ColumnDef -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ColumnDef
</span><a href="Language.SQL.SimpleSQL.Parse.html#columnDef"><span class="hs-identifier hs-var">columnDef</span></a></span><span>
</span><span id="line-1638"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120264"><span class="annot"><span class="annottext">alterColumn :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120264"><span class="hs-identifier hs-var hs-var">alterColumn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;alter&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;column&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1639"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;**&gt;</span></span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   (Name -&gt; AlterTableAction)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120261"><span class="hs-identifier hs-var">setDefault</span></a></span><span>
</span><span id="line-1640"></span><span class="hs-operator">&gt;</span><span>                                    </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120260"><span class="hs-identifier hs-var">dropDefault</span></a></span><span>
</span><span id="line-1641"></span><span class="hs-operator">&gt;</span><span>                                    </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120259"><span class="hs-identifier hs-var">setNotNull</span></a></span><span>
</span><span id="line-1642"></span><span class="hs-operator">&gt;</span><span>                                    </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120258"><span class="hs-identifier hs-var">dropNotNull</span></a></span><span>
</span><span id="line-1643"></span><span class="hs-operator">&gt;</span><span>                                    </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120257"><span class="hs-identifier hs-var">setDataType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1644"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120261"><span class="hs-identifier hs-type">setDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#AlterTableAction"><span class="hs-identifier hs-type">AlterTableAction</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1645"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: left factor</span><span>
</span><span id="line-1646"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120261"><span class="annot"><span class="annottext">setDefault :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120261"><span class="hs-identifier hs-var hs-var">setDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1647"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; (Name -&gt; ScalarExpr -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (f :: * -&gt; *) b a c.
Applicative f =&gt;
f b -&gt; (a -&gt; b -&gt; c) -&gt; f (a -&gt; c)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%3E"><span class="hs-operator hs-var">&lt;$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; ScalarExpr -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterColumnSetDefault"><span class="hs-identifier hs-var">AlterColumnSetDefault</span></a></span><span>
</span><span id="line-1648"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120260"><span class="annot"><span class="annottext">dropDefault :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120260"><span class="hs-identifier hs-var hs-var">dropDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterColumnDropDefault"><span class="hs-identifier hs-var">AlterColumnDropDefault</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; AlterTableAction)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1649"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120259"><span class="annot"><span class="annottext">setNotNull :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120259"><span class="hs-identifier hs-var hs-var">setNotNull</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterColumnSetNotNull"><span class="hs-identifier hs-var">AlterColumnSetNotNull</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; AlterTableAction)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;null&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1650"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120258"><span class="annot"><span class="annottext">dropNotNull :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120258"><span class="hs-identifier hs-var hs-var">dropNotNull</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterColumnDropNotNull"><span class="hs-identifier hs-var">AlterColumnDropNotNull</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; AlterTableAction)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;not&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;null&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1651"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120257"><span class="annot"><span class="annottext">setDataType :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Name -&gt; AlterTableAction)
</span><a href="#local-6989586621679120257"><span class="hs-identifier hs-var hs-var">setDataType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;data&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;type&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1652"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
-&gt; (Name -&gt; TypeName -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Name -&gt; AlterTableAction)
forall (f :: * -&gt; *) b a c.
Applicative f =&gt;
f b -&gt; (a -&gt; b -&gt; c) -&gt; f (a -&gt; c)
</span><a href="Language.SQL.SimpleSQL.Combinators.html#%3C%24%24%3E"><span class="hs-operator hs-var">&lt;$$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; TypeName -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterColumnSetDataType"><span class="hs-identifier hs-var">AlterColumnSetDataType</span></a></span><span>
</span><span id="line-1653"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120263"><span class="annot"><span class="annottext">dropColumn :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120263"><span class="hs-identifier hs-var hs-var">dropColumn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;column&quot;</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1654"></span><span class="hs-operator">&gt;</span><span>                  </span><span class="annot"><span class="annottext">Name -&gt; DropBehaviour -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropColumn"><span class="hs-identifier hs-var">DropColumn</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; DropBehaviour -&gt; AlterTableAction)
-&gt; Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; AlterTableAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1655"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-comment">-- todo: left factor, this try is especially bad</span><span>
</span><span id="line-1656"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120267"><span class="annot"><span class="annottext">addConstraint :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120267"><span class="hs-identifier hs-var hs-var">addConstraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;add&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1657"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">(Maybe [Name] -&gt; TableConstraint -&gt; AlterTableAction)
-&gt; (Maybe [Name], TableConstraint) -&gt; AlterTableAction
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">Maybe [Name] -&gt; TableConstraint -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AddTableConstraintDef"><span class="hs-identifier hs-var">AddTableConstraintDef</span></a></span><span> </span><span class="annot"><span class="annottext">((Maybe [Name], TableConstraint) -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name], TableConstraint)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], TableConstraint)
</span><a href="Language.SQL.SimpleSQL.Parse.html#tableConstraintDef"><span class="hs-identifier hs-var">tableConstraintDef</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1658"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120266"><span class="annot"><span class="annottext">dropConstraint :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
</span><a href="#local-6989586621679120266"><span class="hs-identifier hs-var hs-var">dropConstraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1659"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; AlterTableAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropTableConstraintDef"><span class="hs-identifier hs-var">DropTableConstraintDef</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; AlterTableAction)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; AlterTableAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; AlterTableAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterTableAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1660"></span><span>
</span><span id="line-1661"></span><span>
</span><span id="line-1662"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropSchema"><span class="hs-identifier hs-type">dropSchema</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1663"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropSchema"><span class="annot"><span class="annottext">dropSchema :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropSchema"><span class="hs-identifier hs-var hs-var">dropSchema</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;schema&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1664"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropSchema"><span class="hs-identifier hs-var">DropSchema</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1665"></span><span>
</span><span id="line-1666"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropTable"><span class="hs-identifier hs-type">dropTable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1667"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropTable"><span class="annot"><span class="annottext">dropTable :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropTable"><span class="hs-identifier hs-var hs-var">dropTable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1668"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropTable"><span class="hs-identifier hs-var">DropTable</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1669"></span><span>
</span><span id="line-1670"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createView"><span class="hs-identifier hs-type">createView</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1671"></span><span class="hs-operator">&gt;</span><span> </span><span id="createView"><span class="annot"><span class="annottext">createView :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createView"><span class="hs-identifier hs-var hs-var">createView</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1672"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Bool
-&gt; [Name]
-&gt; Maybe [Name]
-&gt; QueryExpr
-&gt; Maybe CheckOption
-&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateView"><span class="hs-identifier hs-var">CreateView</span></a></span><span>
</span><span id="line-1673"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">(Bool
 -&gt; [Name]
 -&gt; Maybe [Name]
 -&gt; QueryExpr
 -&gt; Maybe CheckOption
 -&gt; Statement)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name]
      -&gt; Maybe [Name] -&gt; QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;recursive&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Bool
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;view&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1674"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name]
   -&gt; Maybe [Name] -&gt; QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name] -&gt; QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1675"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name] -&gt; QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1676"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (QueryExpr -&gt; Maybe CheckOption -&gt; Statement)
-&gt; Parser QueryExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe CheckOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser QueryExpr -&gt; Parser QueryExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1677"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe CheckOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe CheckOption)
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity CheckOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe CheckOption)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity CheckOption]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CheckOption
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span>
</span><span id="line-1678"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-comment">-- todo: left factor</span><span>
</span><span id="line-1679"></span><span class="hs-operator">&gt;</span><span>             </span><span class="annot"><span class="annottext">CheckOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultCheckOption"><span class="hs-identifier hs-var">DefaultCheckOption</span></a></span><span> </span><span class="annot"><span class="annottext">CheckOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CheckOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1680"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-special">,</span><span class="annot"><span class="annottext">CheckOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CascadedCheckOption"><span class="hs-identifier hs-var">CascadedCheckOption</span></a></span><span> </span><span class="annot"><span class="annottext">CheckOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CheckOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;cascaded&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1681"></span><span class="hs-operator">&gt;</span><span>            </span><span class="hs-special">,</span><span class="annot"><span class="annottext">CheckOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#LocalCheckOption"><span class="hs-identifier hs-var">LocalCheckOption</span></a></span><span> </span><span class="annot"><span class="annottext">CheckOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity CheckOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;local&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1682"></span><span class="hs-operator">&gt;</span><span>             </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1683"></span><span>
</span><span id="line-1684"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropView"><span class="hs-identifier hs-type">dropView</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1685"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropView"><span class="annot"><span class="annottext">dropView :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropView"><span class="hs-identifier hs-var hs-var">dropView</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;view&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1686"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropView"><span class="hs-identifier hs-var">DropView</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1687"></span><span>
</span><span id="line-1688"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createDomain"><span class="hs-identifier hs-type">createDomain</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1689"></span><span class="hs-operator">&gt;</span><span> </span><span id="createDomain"><span class="annot"><span class="annottext">createDomain :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createDomain"><span class="hs-identifier hs-var hs-var">createDomain</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;domain&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1690"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name]
-&gt; TypeName
-&gt; Maybe ScalarExpr
-&gt; [(Maybe [Name], ScalarExpr)]
-&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateDomain"><span class="hs-identifier hs-var">CreateDomain</span></a></span><span>
</span><span id="line-1691"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name]
 -&gt; TypeName
 -&gt; Maybe ScalarExpr
 -&gt; [(Maybe [Name], ScalarExpr)]
 -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (TypeName
      -&gt; Maybe ScalarExpr -&gt; [(Maybe [Name], ScalarExpr)] -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1692"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (TypeName
   -&gt; Maybe ScalarExpr -&gt; [(Maybe [Name], ScalarExpr)] -&gt; Statement)
-&gt; Parser TypeName
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr -&gt; [(Maybe [Name], ScalarExpr)] -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser TypeName -&gt; Parser TypeName
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser TypeName
</span><a href="Language.SQL.SimpleSQL.Parse.html#typeName"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1693"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr -&gt; [(Maybe [Name], ScalarExpr)] -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([(Maybe [Name], ScalarExpr)] -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1694"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([(Maybe [Name], ScalarExpr)] -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [(Maybe [Name], ScalarExpr)]
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], ScalarExpr)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [(Maybe [Name], ScalarExpr)]
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], ScalarExpr)
</span><a href="#local-6989586621679120239"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-1695"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1696"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120239"><span class="annot"><span class="annottext">con :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name], ScalarExpr)
</span><a href="#local-6989586621679120239"><span class="hs-identifier hs-var hs-var">con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe [Name] -&gt; ScalarExpr -&gt; (Maybe [Name], ScalarExpr))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; (Maybe [Name], ScalarExpr))
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1697"></span><span class="hs-operator">&gt;</span><span>           </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; (Maybe [Name], ScalarExpr))
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name], ScalarExpr)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1698"></span><span>
</span><span id="line-1699"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#alterDomain"><span class="hs-identifier hs-type">alterDomain</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1700"></span><span class="hs-operator">&gt;</span><span> </span><span id="alterDomain"><span class="annot"><span class="annottext">alterDomain :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterDomain"><span class="hs-identifier hs-var hs-var">alterDomain</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;domain&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1701"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; AlterDomainAction -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterDomain"><span class="hs-identifier hs-var">AlterDomain</span></a></span><span>
</span><span id="line-1702"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; AlterDomainAction -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (AlterDomainAction -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1703"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (AlterDomainAction -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120237"><span class="hs-identifier hs-var">setDefault</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120236"><span class="hs-identifier hs-var">constraint</span></a></span><span>
</span><span id="line-1704"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;drop&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120235"><span class="hs-identifier hs-var">dropDefault</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120234"><span class="hs-identifier hs-var">dropConstraint</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1705"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1706"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120237"><span class="annot"><span class="annottext">setDefault :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120237"><span class="hs-identifier hs-var hs-var">setDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ScalarExpr -&gt; AlterDomainAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ADSetDefault"><span class="hs-identifier hs-var">ADSetDefault</span></a></span><span> </span><span class="annot"><span class="annottext">(ScalarExpr -&gt; AlterDomainAction)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span>
</span><span id="line-1707"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120236"><span class="annot"><span class="annottext">constraint :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120236"><span class="hs-identifier hs-var hs-var">constraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;add&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1708"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">Maybe [Name] -&gt; ScalarExpr -&gt; AlterDomainAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ADAddConstraint"><span class="hs-identifier hs-var">ADAddConstraint</span></a></span><span>
</span><span id="line-1709"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">(Maybe [Name] -&gt; ScalarExpr -&gt; AlterDomainAction)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; AlterDomainAction)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1710"></span><span class="hs-operator">&gt;</span><span>        </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; AlterDomainAction)
-&gt; Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1711"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120235"><span class="annot"><span class="annottext">dropDefault :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120235"><span class="hs-identifier hs-var hs-var">dropDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">AlterDomainAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ADDropDefault"><span class="hs-identifier hs-var">ADDropDefault</span></a></span><span> </span><span class="annot"><span class="annottext">AlterDomainAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span>
</span><span id="line-1712"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120234"><span class="annot"><span class="annottext">dropConstraint :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
</span><a href="#local-6989586621679120234"><span class="hs-identifier hs-var hs-var">dropConstraint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;constraint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; AlterDomainAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ADDropConstraint"><span class="hs-identifier hs-var">ADDropConstraint</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; AlterDomainAction)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AlterDomainAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1713"></span><span>
</span><span id="line-1714"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropDomain"><span class="hs-identifier hs-type">dropDomain</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1715"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropDomain"><span class="annot"><span class="annottext">dropDomain :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropDomain"><span class="hs-identifier hs-var hs-var">dropDomain</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;domain&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1716"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropDomain"><span class="hs-identifier hs-var">DropDomain</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1717"></span><span>
</span><span id="line-1718"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createSequence"><span class="hs-identifier hs-type">createSequence</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1719"></span><span class="hs-operator">&gt;</span><span> </span><span id="createSequence"><span class="annot"><span class="annottext">createSequence :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createSequence"><span class="hs-identifier hs-var hs-var">createSequence</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;sequence&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1720"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; [SequenceGeneratorOption] -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateSequence"><span class="hs-identifier hs-var">CreateSequence</span></a></span><span>
</span><span id="line-1721"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; [SequenceGeneratorOption] -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SequenceGeneratorOption] -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1722"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([SequenceGeneratorOption] -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  [SequenceGeneratorOption]
</span><a href="Language.SQL.SimpleSQL.Parse.html#sequenceGeneratorOptions"><span class="hs-identifier hs-var">sequenceGeneratorOptions</span></a></span><span>
</span><span id="line-1723"></span><span>
</span><span id="line-1724"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#alterSequence"><span class="hs-identifier hs-type">alterSequence</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1725"></span><span class="hs-operator">&gt;</span><span> </span><span id="alterSequence"><span class="annot"><span class="annottext">alterSequence :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#alterSequence"><span class="hs-identifier hs-var hs-var">alterSequence</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;sequence&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1726"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; [SequenceGeneratorOption] -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AlterSequence"><span class="hs-identifier hs-var">AlterSequence</span></a></span><span>
</span><span id="line-1727"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; [SequenceGeneratorOption] -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SequenceGeneratorOption] -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1728"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([SequenceGeneratorOption] -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     [SequenceGeneratorOption]
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  [SequenceGeneratorOption]
</span><a href="Language.SQL.SimpleSQL.Parse.html#sequenceGeneratorOptions"><span class="hs-identifier hs-var">sequenceGeneratorOptions</span></a></span><span>
</span><span id="line-1729"></span><span>
</span><span id="line-1730"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropSequence"><span class="hs-identifier hs-type">dropSequence</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1731"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropSequence"><span class="annot"><span class="annottext">dropSequence :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropSequence"><span class="hs-identifier hs-var hs-var">dropSequence</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;sequence&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1732"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropSequence"><span class="hs-identifier hs-var">DropSequence</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1733"></span><span>
</span><span id="line-1734"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createAssertion"><span class="hs-identifier hs-type">createAssertion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1735"></span><span class="hs-operator">&gt;</span><span> </span><span id="createAssertion"><span class="annot"><span class="annottext">createAssertion :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createAssertion"><span class="hs-identifier hs-var hs-var">createAssertion</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;assertion&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1736"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateAssertion"><span class="hs-identifier hs-var">CreateAssertion</span></a></span><span>
</span><span id="line-1737"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; ScalarExpr -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1738"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; Statement)
-&gt; Parser ScalarExpr -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;check&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr -&gt; Parser ScalarExpr
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1739"></span><span>
</span><span id="line-1740"></span><span>
</span><span id="line-1741"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropAssertion"><span class="hs-identifier hs-type">dropAssertion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1742"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropAssertion"><span class="annot"><span class="annottext">dropAssertion :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropAssertion"><span class="hs-identifier hs-var hs-var">dropAssertion</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;assertion&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1743"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropAssertion"><span class="hs-identifier hs-var">DropAssertion</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1744"></span><span>
</span><span id="line-1745"></span><span class="hs-comment">-----------------</span><span>
</span><span id="line-1746"></span><span>
</span><span id="line-1747"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">dml</span><span>
</span><span id="line-1748"></span><span>
</span><span id="line-1749"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#delete"><span class="hs-identifier hs-type">delete</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1750"></span><span class="hs-operator">&gt;</span><span> </span><span id="delete"><span class="annot"><span class="annottext">delete :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#delete"><span class="hs-identifier hs-var hs-var">delete</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;delete&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1751"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; Maybe Name -&gt; Maybe ScalarExpr -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Delete"><span class="hs-identifier hs-var">Delete</span></a></span><span>
</span><span id="line-1752"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; Maybe Name -&gt; Maybe ScalarExpr -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Name -&gt; Maybe ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1753"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Name -&gt; Maybe ScalarExpr -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1754"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;where&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1755"></span><span>
</span><span id="line-1756"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#truncateSt"><span class="hs-identifier hs-type">truncateSt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1757"></span><span class="hs-operator">&gt;</span><span> </span><span id="truncateSt"><span class="annot"><span class="annottext">truncateSt :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#truncateSt"><span class="hs-identifier hs-var hs-var">truncateSt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;truncate&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1758"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; IdentityRestart -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Truncate"><span class="hs-identifier hs-var">Truncate</span></a></span><span>
</span><span id="line-1759"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; IdentityRestart -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (IdentityRestart -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1760"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (IdentityRestart -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">IdentityRestart
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">IdentityRestart
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultIdentityRestart"><span class="hs-identifier hs-var">DefaultIdentityRestart</span></a></span><span>
</span><span id="line-1761"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IdentityRestart
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ContinueIdentity"><span class="hs-identifier hs-var">ContinueIdentity</span></a></span><span> </span><span class="annot"><span class="annottext">IdentityRestart
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;continue&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;identity&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1762"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">IdentityRestart
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RestartIdentity"><span class="hs-identifier hs-var">RestartIdentity</span></a></span><span> </span><span class="annot"><span class="annottext">IdentityRestart
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity IdentityRestart
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;restart&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;identity&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1763"></span><span>
</span><span id="line-1764"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#insert"><span class="hs-identifier hs-type">insert</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1765"></span><span class="hs-operator">&gt;</span><span> </span><span id="insert"><span class="annot"><span class="annottext">insert :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#insert"><span class="hs-identifier hs-var hs-var">insert</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;insert&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;into&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1766"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; Maybe [Name] -&gt; InsertSource -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Insert"><span class="hs-identifier hs-var">Insert</span></a></span><span>
</span><span id="line-1767"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name] -&gt; Maybe [Name] -&gt; InsertSource -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe [Name] -&gt; InsertSource -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1768"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe [Name] -&gt; InsertSource -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (InsertSource -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe [Name])
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1769"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (InsertSource -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InsertSource
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultInsertValues"><span class="hs-identifier hs-var">DefaultInsertValues</span></a></span><span> </span><span class="annot"><span class="annottext">InsertSource
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;default&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;values&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1770"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">QueryExpr -&gt; InsertSource
</span><a href="Language.SQL.SimpleSQL.Syntax.html#InsertQuery"><span class="hs-identifier hs-var">InsertQuery</span></a></span><span> </span><span class="annot"><span class="annottext">(QueryExpr -&gt; InsertSource)
-&gt; Parser QueryExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity InsertSource
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser QueryExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#queryExpr"><span class="hs-identifier hs-var">queryExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1771"></span><span>
</span><span id="line-1772"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#update"><span class="hs-identifier hs-type">update</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1773"></span><span class="hs-operator">&gt;</span><span> </span><span id="update"><span class="annot"><span class="annottext">update :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#update"><span class="hs-identifier hs-var hs-var">update</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;update&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1774"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[Name]
-&gt; Maybe Name -&gt; [SetClause] -&gt; Maybe ScalarExpr -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Update"><span class="hs-identifier hs-var">Update</span></a></span><span>
</span><span id="line-1775"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">([Name]
 -&gt; Maybe Name -&gt; [SetClause] -&gt; Maybe ScalarExpr -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe Name -&gt; [SetClause] -&gt; Maybe ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1776"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe Name -&gt; [SetClause] -&gt; Maybe ScalarExpr -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([SetClause] -&gt; Maybe ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;as&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1777"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([SetClause] -&gt; Maybe ScalarExpr -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SetClause]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe ScalarExpr -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;set&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SetClause]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SetClause]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser SetClause
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [SetClause]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SetClause
</span><a href="#local-6989586621679120214"><span class="hs-identifier hs-var">setClause</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1778"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (Maybe ScalarExpr -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe ScalarExpr)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;where&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1779"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1780"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120214"><span class="annot"><span class="annottext">setClause :: Parser SetClause
</span><a href="#local-6989586621679120214"><span class="hs-identifier hs-var hs-var">setClause</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser SetClause
</span><a href="#local-6989586621679120213"><span class="hs-identifier hs-var">multipleSet</span></a></span><span> </span><span class="annot"><span class="annottext">Parser SetClause -&gt; Parser SetClause -&gt; Parser SetClause
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser SetClause
</span><a href="#local-6989586621679120212"><span class="hs-identifier hs-var">singleSet</span></a></span><span>
</span><span id="line-1781"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120213"><span class="annot"><span class="annottext">multipleSet :: Parser SetClause
</span><a href="#local-6989586621679120213"><span class="hs-identifier hs-var hs-var">multipleSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[[Name]] -&gt; [ScalarExpr] -&gt; SetClause
</span><a href="Language.SQL.SimpleSQL.Syntax.html#SetMultiple"><span class="hs-identifier hs-var">SetMultiple</span></a></span><span>
</span><span id="line-1782"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">([[Name]] -&gt; [ScalarExpr] -&gt; SetClause)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [[Name]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([ScalarExpr] -&gt; SetClause)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [[Name]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [[Name]]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [[Name]]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1783"></span><span class="hs-operator">&gt;</span><span>                   </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([ScalarExpr] -&gt; SetClause)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; Parser SetClause
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser ScalarExpr
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [ScalarExpr]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var">commaSep1</span></a></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1784"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120212"><span class="annot"><span class="annottext">singleSet :: Parser SetClause
</span><a href="#local-6989586621679120212"><span class="hs-identifier hs-var hs-var">singleSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ScalarExpr -&gt; SetClause
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Set"><span class="hs-identifier hs-var">Set</span></a></span><span>
</span><span id="line-1785"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">([Name] -&gt; ScalarExpr -&gt; SetClause)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (ScalarExpr -&gt; SetClause)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1786"></span><span class="hs-operator">&gt;</span><span>                 </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (ScalarExpr -&gt; SetClause)
-&gt; Parser ScalarExpr -&gt; Parser SetClause
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;=&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; Parser ScalarExpr -&gt; Parser ScalarExpr
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser ScalarExpr
</span><a href="Language.SQL.SimpleSQL.Parse.html#scalarExpr"><span class="hs-identifier hs-var">scalarExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1787"></span><span>
</span><span id="line-1788"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-type">dropBehaviour</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#DropBehaviour"><span class="hs-identifier hs-type">DropBehaviour</span></a></span><span>
</span><span id="line-1789"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropBehaviour"><span class="annot"><span class="annottext">dropBehaviour :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var hs-var">dropBehaviour</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1790"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DefaultDropBehaviour"><span class="hs-identifier hs-var">DefaultDropBehaviour</span></a></span><span>
</span><span id="line-1791"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Restrict"><span class="hs-identifier hs-var">Restrict</span></a></span><span> </span><span class="annot"><span class="annottext">DropBehaviour
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;restrict&quot;</span></span><span>
</span><span id="line-1792"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Cascade"><span class="hs-identifier hs-var">Cascade</span></a></span><span> </span><span class="annot"><span class="annottext">DropBehaviour
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;cascade&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1793"></span><span>
</span><span id="line-1794"></span><span class="hs-comment">-----------------------------</span><span>
</span><span id="line-1795"></span><span>
</span><span id="line-1796"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">transaction</span><span> </span><span class="hs-identifier">management</span><span>
</span><span id="line-1797"></span><span>
</span><span id="line-1798"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#startTransaction"><span class="hs-identifier hs-type">startTransaction</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1799"></span><span class="hs-operator">&gt;</span><span> </span><span id="startTransaction"><span class="annot"><span class="annottext">startTransaction :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#startTransaction"><span class="hs-identifier hs-var hs-var">startTransaction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#StartTransaction"><span class="hs-identifier hs-var">StartTransaction</span></a></span><span> </span><span class="annot"><span class="annottext">Statement
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;start&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;transaction&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1800"></span><span>
</span><span id="line-1801"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#savepoint"><span class="hs-identifier hs-type">savepoint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1802"></span><span class="hs-operator">&gt;</span><span> </span><span id="savepoint"><span class="annot"><span class="annottext">savepoint :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#savepoint"><span class="hs-identifier hs-var hs-var">savepoint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;savepoint&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1803"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Name -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Savepoint"><span class="hs-identifier hs-var">Savepoint</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Statement) -&gt; Parser Name -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1804"></span><span>
</span><span id="line-1805"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#releaseSavepoint"><span class="hs-identifier hs-type">releaseSavepoint</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1806"></span><span class="hs-operator">&gt;</span><span> </span><span id="releaseSavepoint"><span class="annot"><span class="annottext">releaseSavepoint :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#releaseSavepoint"><span class="hs-identifier hs-var hs-var">releaseSavepoint</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;release&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;savepoint&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1807"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Name -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#ReleaseSavepoint"><span class="hs-identifier hs-var">ReleaseSavepoint</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Statement) -&gt; Parser Name -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1808"></span><span>
</span><span id="line-1809"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#commit"><span class="hs-identifier hs-type">commit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1810"></span><span class="hs-operator">&gt;</span><span> </span><span id="commit"><span class="annot"><span class="annottext">commit :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#commit"><span class="hs-identifier hs-var hs-var">commit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Commit"><span class="hs-identifier hs-var">Commit</span></a></span><span> </span><span class="annot"><span class="annottext">Statement
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;commit&quot;</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;work&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1811"></span><span>
</span><span id="line-1812"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#rollback"><span class="hs-identifier hs-type">rollback</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1813"></span><span class="hs-operator">&gt;</span><span> </span><span id="rollback"><span class="annot"><span class="annottext">rollback :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#rollback"><span class="hs-identifier hs-var hs-var">rollback</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;rollback&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;work&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1814"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Maybe Name -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#Rollback"><span class="hs-identifier hs-var">Rollback</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe Name -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity (Maybe Name)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m (Maybe a)
</span><span class="hs-identifier hs-var">optionMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;to&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;savepoint&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Name -&gt; Parser Name
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1815"></span><span>
</span><span id="line-1816"></span><span>
</span><span id="line-1817"></span><span class="hs-comment">------------------------------</span><span>
</span><span id="line-1818"></span><span>
</span><span id="line-1819"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Access</span><span> </span><span class="hs-identifier">control</span><span>
</span><span id="line-1820"></span><span>
</span><span id="line-1821"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">on'</span><span>
</span><span id="line-1822"></span><span>
</span><span id="line-1823"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#grant"><span class="hs-identifier hs-type">grant</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1824"></span><span class="hs-operator">&gt;</span><span> </span><span id="grant"><span class="annot"><span class="annottext">grant :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#grant"><span class="hs-identifier hs-var hs-var">grant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;grant&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Statement -&gt; Parser Statement
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="#local-6989586621679120201"><span class="hs-identifier hs-var">priv</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Statement -&gt; Parser Statement -&gt; Parser Statement
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="#local-6989586621679120200"><span class="hs-keyword hs-var">role</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1825"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1826"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120201"><span class="annot"><span class="annottext">priv :: Parser Statement
</span><a href="#local-6989586621679120201"><span class="hs-identifier hs-var hs-var">priv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[PrivilegeAction]
-&gt; PrivilegeObject -&gt; [Name] -&gt; GrantOption -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GrantPrivilege"><span class="hs-identifier hs-var">GrantPrivilege</span></a></span><span>
</span><span id="line-1827"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">([PrivilegeAction]
 -&gt; PrivilegeObject -&gt; [Name] -&gt; GrantOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [PrivilegeAction]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (PrivilegeObject -&gt; [Name] -&gt; GrantOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser PrivilegeAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [PrivilegeAction]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeAction"><span class="hs-identifier hs-var">privilegeAction</span></a></span><span>
</span><span id="line-1828"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (PrivilegeObject -&gt; [Name] -&gt; GrantOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; GrantOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;on&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeObject"><span class="hs-identifier hs-var">privilegeObject</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1829"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; GrantOption -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (GrantOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;to&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1830"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (GrantOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOption
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">GrantOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOption
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">GrantOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#WithoutGrantOption"><span class="hs-identifier hs-var">WithoutGrantOption</span></a></span><span>
</span><span id="line-1831"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GrantOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#WithGrantOption"><span class="hs-identifier hs-var">WithGrantOption</span></a></span><span> </span><span class="annot"><span class="annottext">GrantOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;grant&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1832"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120200"><span class="annot"><span class="annottext">role :: Parser Statement
</span><a href="#local-6989586621679120200"><span class="hs-keyword hs-var hs-var">role</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; AdminOption -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GrantRole"><span class="hs-identifier hs-var">GrantRole</span></a></span><span>
</span><span id="line-1833"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">([Name] -&gt; [Name] -&gt; AdminOption -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; AdminOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1834"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; AdminOption -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (AdminOption -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;to&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1835"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (AdminOption -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOption
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">AdminOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOption
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOption
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">AdminOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#WithoutAdminOption"><span class="hs-identifier hs-var">WithoutAdminOption</span></a></span><span>
</span><span id="line-1836"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AdminOption
</span><a href="Language.SQL.SimpleSQL.Syntax.html#WithAdminOption"><span class="hs-identifier hs-var">WithAdminOption</span></a></span><span> </span><span class="annot"><span class="annottext">AdminOption
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOption
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;with&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;admin&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1837"></span><span>
</span><span id="line-1838"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#createRole"><span class="hs-identifier hs-type">createRole</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1839"></span><span class="hs-operator">&gt;</span><span> </span><span id="createRole"><span class="annot"><span class="annottext">createRole :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#createRole"><span class="hs-identifier hs-var hs-var">createRole</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;role&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1840"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Name -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#CreateRole"><span class="hs-identifier hs-var">CreateRole</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Statement) -&gt; Parser Name -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1841"></span><span>
</span><span id="line-1842"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#dropRole"><span class="hs-identifier hs-type">dropRole</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1843"></span><span class="hs-operator">&gt;</span><span> </span><span id="dropRole"><span class="annot"><span class="annottext">dropRole :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropRole"><span class="hs-identifier hs-var hs-var">dropRole</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;role&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1844"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Name -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#DropRole"><span class="hs-identifier hs-var">DropRole</span></a></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Statement) -&gt; Parser Name -&gt; Parser Statement
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1845"></span><span>
</span><span id="line-1846"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">fix</span><span> </span><span class="hs-identifier">try</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">on'</span><span>
</span><span id="line-1847"></span><span>
</span><span id="line-1848"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#revoke"><span class="hs-identifier hs-type">revoke</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span>
</span><span id="line-1849"></span><span class="hs-operator">&gt;</span><span> </span><span id="revoke"><span class="annot"><span class="annottext">revoke :: Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#revoke"><span class="hs-identifier hs-var hs-var">revoke</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;revoke&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser Statement -&gt; Parser Statement
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Statement -&gt; Parser Statement
forall s u (m :: * -&gt; *) a. ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">try</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="#local-6989586621679120189"><span class="hs-identifier hs-var">priv</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Statement -&gt; Parser Statement -&gt; Parser Statement
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="#local-6989586621679120188"><span class="hs-keyword hs-var">role</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1850"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1851"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120189"><span class="annot"><span class="annottext">priv :: Parser Statement
</span><a href="#local-6989586621679120189"><span class="hs-identifier hs-var hs-var">priv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GrantOptionFor
-&gt; [PrivilegeAction]
-&gt; PrivilegeObject
-&gt; [Name]
-&gt; DropBehaviour
-&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RevokePrivilege"><span class="hs-identifier hs-var">RevokePrivilege</span></a></span><span>
</span><span id="line-1852"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">(GrantOptionFor
 -&gt; [PrivilegeAction]
 -&gt; PrivilegeObject
 -&gt; [Name]
 -&gt; DropBehaviour
 -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([PrivilegeAction]
      -&gt; PrivilegeObject -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">GrantOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOptionFor
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">GrantOptionFor
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NoGrantOptionFor"><span class="hs-identifier hs-var">NoGrantOptionFor</span></a></span><span>
</span><span id="line-1853"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">GrantOptionFor
</span><a href="Language.SQL.SimpleSQL.Syntax.html#GrantOptionFor"><span class="hs-identifier hs-var">GrantOptionFor</span></a></span><span> </span><span class="annot"><span class="annottext">GrantOptionFor
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity GrantOptionFor
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;grant&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;for&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1854"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([PrivilegeAction]
   -&gt; PrivilegeObject -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [PrivilegeAction]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (PrivilegeObject -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser PrivilegeAction
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [PrivilegeAction]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeAction"><span class="hs-identifier hs-var">privilegeAction</span></a></span><span>
</span><span id="line-1855"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (PrivilegeObject -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;on&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeObject"><span class="hs-identifier hs-var">privilegeObject</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1856"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1857"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1858"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120188"><span class="annot"><span class="annottext">role :: Parser Statement
</span><a href="#local-6989586621679120188"><span class="hs-keyword hs-var hs-var">role</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">AdminOptionFor -&gt; [Name] -&gt; [Name] -&gt; DropBehaviour -&gt; Statement
</span><a href="Language.SQL.SimpleSQL.Syntax.html#RevokeRole"><span class="hs-identifier hs-var">RevokeRole</span></a></span><span>
</span><span id="line-1859"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">(AdminOptionFor -&gt; [Name] -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">AdminOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOptionFor
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOptionFor
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="annot"><span class="annottext">AdminOptionFor
</span><a href="Language.SQL.SimpleSQL.Syntax.html#NoAdminOptionFor"><span class="hs-identifier hs-var">NoAdminOptionFor</span></a></span><span>
</span><span id="line-1860"></span><span class="hs-operator">&gt;</span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">AdminOptionFor
</span><a href="Language.SQL.SimpleSQL.Syntax.html#AdminOptionFor"><span class="hs-identifier hs-var">AdminOptionFor</span></a></span><span> </span><span class="annot"><span class="annottext">AdminOptionFor
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity AdminOptionFor
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;admin&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;option&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-string">&quot;for&quot;</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1861"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; [Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     ([Name] -&gt; DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1862"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  ([Name] -&gt; DropBehaviour -&gt; Statement)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (DropBehaviour -&gt; Statement)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;from&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser [Name] -&gt; Parser [Name]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1863"></span><span class="hs-operator">&gt;</span><span>            </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (DropBehaviour -&gt; Statement)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
-&gt; Parser Statement
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity DropBehaviour
</span><a href="Language.SQL.SimpleSQL.Parse.html#dropBehaviour"><span class="hs-identifier hs-var">dropBehaviour</span></a></span><span>
</span><span id="line-1864"></span><span>
</span><span id="line-1865"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#privilegeAction"><span class="hs-identifier hs-type">privilegeAction</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#PrivilegeAction"><span class="hs-identifier hs-type">PrivilegeAction</span></a></span><span>
</span><span id="line-1866"></span><span class="hs-operator">&gt;</span><span> </span><span id="privilegeAction"><span class="annot"><span class="annottext">privilegeAction :: Parser PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeAction"><span class="hs-identifier hs-var hs-var">privilegeAction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parser PrivilegeAction] -&gt; Parser PrivilegeAction
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1867"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivAll"><span class="hs-identifier hs-var">PrivAll</span></a></span><span> </span><span class="annot"><span class="annottext">PrivilegeAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;all&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;privileges&quot;</span></span><span class="hs-special">]</span><span>
</span><span id="line-1868"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;select&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction -&gt; Parser PrivilegeAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1869"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivSelect"><span class="hs-identifier hs-var">PrivSelect</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeAction)
-&gt; Parser [Name] -&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1870"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivDelete"><span class="hs-identifier hs-var">PrivDelete</span></a></span><span> </span><span class="annot"><span class="annottext">PrivilegeAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;delete&quot;</span></span><span>
</span><span id="line-1871"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivUsage"><span class="hs-identifier hs-var">PrivUsage</span></a></span><span> </span><span class="annot"><span class="annottext">PrivilegeAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;usage&quot;</span></span><span>
</span><span id="line-1872"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivTrigger"><span class="hs-identifier hs-var">PrivTrigger</span></a></span><span> </span><span class="annot"><span class="annottext">PrivilegeAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;trigger&quot;</span></span><span>
</span><span id="line-1873"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivExecute"><span class="hs-identifier hs-var">PrivExecute</span></a></span><span> </span><span class="annot"><span class="annottext">PrivilegeAction
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;execute&quot;</span></span><span>
</span><span id="line-1874"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;insert&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction -&gt; Parser PrivilegeAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1875"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivInsert"><span class="hs-identifier hs-var">PrivInsert</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeAction)
-&gt; Parser [Name] -&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1876"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;update&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction -&gt; Parser PrivilegeAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1877"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivUpdate"><span class="hs-identifier hs-var">PrivUpdate</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeAction)
-&gt; Parser [Name] -&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1878"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;references&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; Parser PrivilegeAction -&gt; Parser PrivilegeAction
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span>
</span><span id="line-1879"></span><span class="hs-operator">&gt;</span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeAction
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivReferences"><span class="hs-identifier hs-var">PrivReferences</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeAction)
-&gt; Parser [Name] -&gt; Parser PrivilegeAction
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Parser [Name] -&gt; Parser [Name]
forall s (m :: * -&gt; *) t a u.
Stream s m t =&gt;
a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">option</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser [Name] -&gt; Parser [Name]
forall a. Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="annot"><span class="annottext">(Parser [Name] -&gt; Parser [Name]) -&gt; Parser [Name] -&gt; Parser [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parser Name -&gt; Parser [Name]
forall a. Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var">commaSep</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Name
</span><a href="Language.SQL.SimpleSQL.Parse.html#name"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1880"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">]</span><span>
</span><span id="line-1881"></span><span>
</span><span id="line-1882"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#privilegeObject"><span class="hs-identifier hs-type">privilegeObject</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#PrivilegeObject"><span class="hs-identifier hs-type">PrivilegeObject</span></a></span><span>
</span><span id="line-1883"></span><span class="hs-operator">&gt;</span><span> </span><span id="privilegeObject"><span class="annot"><span class="annottext">privilegeObject :: ParsecT
  [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Parse.html#privilegeObject"><span class="hs-identifier hs-var hs-var">privilegeObject</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span>
</span><span id="line-1884"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;domain&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivDomain"><span class="hs-identifier hs-var">PrivDomain</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeObject)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1885"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;type&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivType"><span class="hs-identifier hs-var">PrivType</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeObject)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1886"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;sequence&quot;</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivSequence"><span class="hs-identifier hs-var">PrivSequence</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeObject)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1887"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var">keywords_</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-string">&quot;specific&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-string">&quot;function&quot;</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivFunction"><span class="hs-identifier hs-var">PrivFunction</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeObject)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1888"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">,</span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m ()
</span><span class="hs-identifier hs-var">optional</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;table&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; PrivilegeObject
</span><a href="Language.SQL.SimpleSQL.Syntax.html#PrivTable"><span class="hs-identifier hs-var">PrivTable</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; PrivilegeObject)
-&gt; Parser [Name]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity PrivilegeObject
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Name]
</span><a href="Language.SQL.SimpleSQL.Parse.html#names"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1889"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">]</span><span>
</span><span id="line-1890"></span><span>
</span><span id="line-1891"></span><span>
</span><span id="line-1892"></span><span class="hs-comment">----------------------------</span><span>
</span><span id="line-1893"></span><span>
</span><span id="line-1894"></span><span class="hs-identifier">wrapper</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">series</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">statements</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">They</span><span> </span><span class="hs-identifier">must</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">separated</span><span> </span><span class="hs-identifier">by</span><span>
</span><span id="line-1895"></span><span class="hs-identifier">semicolon</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">last</span><span> </span><span class="hs-identifier">statement</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">trailing</span><span> </span><span class="hs-identifier">semicolon</span><span> </span><span class="hs-identifier">is</span><span>
</span><span id="line-1896"></span><span class="hs-identifier">optional</span><span class="hs-operator">.</span><span>
</span><span id="line-1897"></span><span>
</span><span id="line-1898"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">change</span><span> </span><span class="hs-identifier">style</span><span>
</span><span id="line-1899"></span><span>
</span><span id="line-1900"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#statements"><span class="hs-identifier hs-type">statements</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.SQL.SimpleSQL.Syntax.html#Statement"><span class="hs-identifier hs-type">Statement</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1901"></span><span class="hs-operator">&gt;</span><span> </span><span id="statements"><span class="annot"><span class="annottext">statements :: Parser [Statement]
</span><a href="Language.SQL.SimpleSQL.Parse.html#statements"><span class="hs-identifier hs-var hs-var">statements</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Statement -&gt; [Statement] -&gt; [Statement]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Statement -&gt; [Statement])
-&gt; Parser Statement -&gt; Parser [Statement]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser Statement
</span><a href="Language.SQL.SimpleSQL.Parse.html#statement"><span class="hs-identifier hs-var">statement</span></a></span><span>
</span><span id="line-1902"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">Parser [Statement]
-&gt; ([Statement] -&gt; Parser [Statement]) -&gt; Parser [Statement]
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">([Statement] -&gt; Parser [Statement])
-&gt; [Statement] -&gt; Parser [Statement]
forall a t s. (a -&gt; GenParser t s a) -&gt; a -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#optionSuffix"><span class="hs-identifier hs-var">optionSuffix</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#semi"><span class="hs-identifier hs-var">semi</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char -&gt; Parser [Statement] -&gt; Parser [Statement]
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Parser [Statement] -&gt; Parser [Statement])
-&gt; ([Statement] -&gt; Parser [Statement])
-&gt; [Statement]
-&gt; Parser [Statement]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[Statement] -&gt; Parser [Statement]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span class="hs-special">)</span><span>
</span><span id="line-1903"></span><span class="hs-operator">&gt;</span><span>              </span><span class="annot"><span class="annottext">Parser [Statement]
-&gt; ([Statement] -&gt; Parser [Statement]) -&gt; Parser [Statement]
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">([Statement] -&gt; Parser [Statement])
-&gt; [Statement] -&gt; Parser [Statement]
forall a t s. (a -&gt; GenParser t s a) -&gt; a -&gt; GenParser t s a
</span><a href="Language.SQL.SimpleSQL.Combinators.html#optionSuffix"><span class="hs-identifier hs-var">optionSuffix</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120167"><span class="annot"><span class="annottext">p :: [Statement]
</span><a href="#local-6989586621679120167"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Statement]
</span><a href="#local-6989586621679120167"><span class="hs-identifier hs-var">p</span></a></span><span class="annot"><span class="annottext">[Statement] -&gt; [Statement] -&gt; [Statement]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Statement] -&gt; [Statement])
-&gt; Parser [Statement] -&gt; Parser [Statement]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parser [Statement]
</span><a href="Language.SQL.SimpleSQL.Parse.html#statements"><span class="hs-identifier hs-var">statements</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1904"></span><span>
</span><span id="line-1905"></span><span class="hs-comment">----------------------------------------------</span><span>
</span><span id="line-1906"></span><span>
</span><span id="line-1907"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">multi</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">helper</span><span>
</span><span id="line-1908"></span><span>
</span><span id="line-1909"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">helper</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">help</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">multiple</span><span> </span><span class="hs-identifier">options</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">multiple</span><span> </span><span class="hs-identifier">keywords</span><span>
</span><span id="line-1910"></span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">similar</span><span> </span><span class="hs-identifier">prefixes</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">null'</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">null'</span><span class="hs-operator">.</span><span>
</span><span id="line-1911"></span><span>
</span><span id="line-1912"></span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">left</span><span> </span><span class="hs-identifier">factor</span><span class="hs-operator">/</span><span> </span><span class="hs-identifier">improve</span><span class="hs-glyph">:</span><span>
</span><span id="line-1913"></span><span class="hs-identifier">typed</span><span> </span><span class="hs-identifier">literal</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">general</span><span> </span><span class="hs-identifier">identifiers</span><span>
</span><span id="line-1914"></span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">like</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-keyword">in</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">between</span><span> </span><span class="hs-identifier">operators</span><span>
</span><span id="line-1915"></span><span class="hs-identifier">help</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">factoring</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">functions</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">app</span><span class="hs-glyph">-</span><span class="hs-identifier">likes</span><span>
</span><span id="line-1916"></span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">join</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">sequences</span><span>
</span><span id="line-1917"></span><span class="hs-identifier">fetch</span><span> </span><span class="hs-identifier">first</span><span class="hs-operator">/</span><span class="hs-identifier">next</span><span>
</span><span id="line-1918"></span><span class="hs-identifier">row</span><span class="hs-operator">/</span><span class="hs-identifier">rows</span><span> </span><span class="hs-identifier">only</span><span>
</span><span id="line-1919"></span><span>
</span><span id="line-1920"></span><span class="hs-identifier">There</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">probably</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">simpler</span><span> </span><span class="hs-identifier">way</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">doing</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">I</span><span> </span><span class="hs-identifier">am</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">bit</span><span>
</span><span id="line-1921"></span><span class="hs-identifier">thick</span><span class="hs-operator">.</span><span>
</span><span id="line-1922"></span><span>
</span><span id="line-1923"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-type">makeKeywordTree</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-1924"></span><span class="hs-operator">&gt;</span><span> </span><span id="makeKeywordTree"><span class="annot"><span class="annottext">makeKeywordTree :: [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#makeKeywordTree"><span class="hs-identifier hs-var hs-var">makeKeywordTree</span></a></span></span><span> </span><span id="local-6989586621679120166"><span class="annot"><span class="annottext">sets :: [FilePath]
</span><a href="#local-6989586621679120166"><span class="hs-identifier hs-var">sets</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1925"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[[FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120165"><span class="hs-identifier hs-var">parseTrees</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[[FilePath]] -&gt; [[FilePath]]
forall a. Ord a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">sort</span></span><span> </span><span class="annot"><span class="annottext">([[FilePath]] -&gt; [[FilePath]]) -&gt; [[FilePath]] -&gt; [[FilePath]]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; [FilePath]) -&gt; [FilePath] -&gt; [[FilePath]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath]
</span><span class="hs-identifier hs-var">words</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120166"><span class="hs-identifier hs-var">sets</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1926"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-1927"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120165"><span class="hs-identifier hs-type">parseTrees</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-1928"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120165"><span class="annot"><span class="annottext">parseTrees :: [[FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120165"><span class="hs-identifier hs-var hs-var">parseTrees</span></a></span></span><span> </span><span id="local-6989586621679120163"><span class="annot"><span class="annottext">ws :: [[FilePath]]
</span><a href="#local-6989586621679120163"><span class="hs-identifier hs-var">ws</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1929"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679120162"><span class="hs-identifier hs-type">gs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-1930"></span><span class="hs-operator">&gt;</span><span>           </span><span id="local-6989586621679120162"><span class="annot"><span class="annottext">gs :: [[[FilePath]]]
</span><a href="#local-6989586621679120162"><span class="hs-identifier hs-var hs-var">gs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([FilePath] -&gt; [FilePath] -&gt; Bool)
-&gt; [[FilePath]] -&gt; [[[FilePath]]]
forall a. (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [[a]]
</span><span class="hs-identifier hs-var">groupBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe FilePath -&gt; Maybe FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">(==)</span></span><span> </span><span class="annot"><span class="annottext">(Maybe FilePath -&gt; Maybe FilePath -&gt; Bool)
-&gt; ([FilePath] -&gt; Maybe FilePath)
-&gt; [FilePath]
-&gt; [FilePath]
-&gt; Bool
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; Maybe FilePath
forall a. [a] -&gt; Maybe a
</span><a href="#local-6989586621679120161"><span class="hs-identifier hs-var">safeHead</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
</span><a href="#local-6989586621679120163"><span class="hs-identifier hs-var">ws</span></a></span><span>
</span><span id="line-1931"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="annot"><span class="annottext">([ParsecT
    [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]]
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity [FilePath])
-&gt; [ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([[FilePath]]
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity [FilePath])
-&gt; [[[FilePath]]]
-&gt; [ParsecT
      [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120160"><span class="hs-identifier hs-var">parseGroup</span></a></span><span> </span><span class="annot"><span class="annottext">[[[FilePath]]]
</span><a href="#local-6989586621679120162"><span class="hs-identifier hs-var">gs</span></a></span><span>
</span><span id="line-1932"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120160"><span class="hs-identifier hs-type">parseGroup</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-1933"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120160"><span class="annot"><span class="annottext">parseGroup :: [[FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120160"><span class="hs-identifier hs-var hs-var">parseGroup</span></a></span></span><span> </span><span id="local-6989586621679120159"><span class="annot"><span class="annottext">l :: [[FilePath]]
</span><a href="#local-6989586621679120159"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679120158"><span class="annot"><span class="annottext">k :: FilePath
</span><a href="#local-6989586621679120158"><span class="hs-identifier hs-var">k</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1934"></span><span class="hs-operator">&gt;</span><span>         </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120158"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1935"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679120157"><span class="annot"><span class="annottext">tls :: [[FilePath]]
</span><a href="#local-6989586621679120157"><span class="hs-identifier hs-var hs-var">tls</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Maybe [FilePath]] -&gt; [[FilePath]]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span> </span><span class="annot"><span class="annottext">([Maybe [FilePath]] -&gt; [[FilePath]])
-&gt; [Maybe [FilePath]] -&gt; [[FilePath]]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([FilePath] -&gt; Maybe [FilePath])
-&gt; [[FilePath]] -&gt; [Maybe [FilePath]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; Maybe [FilePath]
forall a. [a] -&gt; Maybe [a]
</span><a href="#local-6989586621679120156"><span class="hs-identifier hs-var">safeTail</span></a></span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
</span><a href="#local-6989586621679120159"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-1936"></span><span class="hs-operator">&gt;</span><span>             </span><span id="local-6989586621679120155"><span class="annot"><span class="annottext">pr :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120155"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120158"><span class="hs-identifier hs-var">k</span></a></span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; [FilePath]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([FilePath] -&gt; [FilePath])
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120165"><span class="hs-identifier hs-var">parseTrees</span></a></span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
</span><a href="#local-6989586621679120157"><span class="hs-identifier hs-var">tls</span></a></span><span>
</span><span id="line-1937"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-keyword">if</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Bool] -&gt; Bool
forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><span class="hs-identifier hs-var">or</span></span><span> </span><span class="annot"><span class="annottext">([Bool] -&gt; Bool) -&gt; [Bool] -&gt; Bool
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">([FilePath] -&gt; Bool) -&gt; [[FilePath]] -&gt; [Bool]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[[FilePath]]
</span><a href="#local-6989586621679120157"><span class="hs-identifier hs-var">tls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1938"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120155"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120158"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1939"></span><span class="hs-operator">&gt;</span><span>           </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
</span><a href="#local-6989586621679120155"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-1940"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120160"><span class="hs-identifier hs-var">parseGroup</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT
     [((FilePath, Int, Int), Token)] Dialect Identity [FilePath]
forall a. HasCallStack =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="hs-string">&quot;impossible&quot;</span></span><span>
</span><span id="line-1941"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120161"><span class="annot"><span class="annottext">safeHead :: [a] -&gt; Maybe a
</span><a href="#local-6989586621679120161"><span class="hs-identifier hs-var hs-var">safeHead</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679120151"><span class="annot"><span class="annottext">x :: a
</span><a href="#local-6989586621679120151"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679120151"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1942"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120161"><span class="hs-identifier hs-var">safeHead</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1943"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120156"><span class="annot"><span class="annottext">safeTail :: [a] -&gt; Maybe [a]
</span><a href="#local-6989586621679120156"><span class="hs-identifier hs-var hs-var">safeTail</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679120150"><span class="annot"><span class="annottext">x :: [a]
</span><a href="#local-6989586621679120150"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Maybe [a]
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679120150"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1944"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><a href="#local-6989586621679120156"><span class="hs-identifier hs-var">safeTail</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe [a]
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1945"></span><span>
</span><span id="line-1946"></span><span class="hs-comment">------------------------------------------------</span><span>
</span><span id="line-1947"></span><span>
</span><span id="line-1948"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">lexing</span><span>
</span><span id="line-1949"></span><span>
</span><span id="line-1950"></span><span class="hs-identifier">TODO</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">push</span><span> </span><span class="hs-identifier">checks</span><span> </span><span class="hs-identifier">into</span><span> </span><span class="hs-identifier">here</span><span class="hs-glyph">:</span><span>
</span><span id="line-1951"></span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">blacklists</span><span>
</span><span id="line-1952"></span><span class="hs-identifier">unsigned</span><span> </span><span class="hs-identifier">integer</span><span> </span><span class="hs-identifier">match</span><span>
</span><span id="line-1953"></span><span class="hs-identifier">symbol</span><span> </span><span class="hs-identifier">matching</span><span>
</span><span id="line-1954"></span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">matching</span><span>
</span><span id="line-1955"></span><span>
</span><span id="line-1956"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#stringTok"><span class="hs-identifier hs-type">stringTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-1957"></span><span class="hs-operator">&gt;</span><span> </span><span id="stringTok"><span class="annot"><span class="annottext">stringTok :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath, FilePath, FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringTok"><span class="hs-identifier hs-var hs-var">stringTok</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe (FilePath, FilePath, FilePath))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120147"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120147"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1958"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120147"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1959"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#SqlString"><span class="hs-identifier hs-type">L.SqlString</span></a></span><span> </span><span id="local-6989586621679120145"><span class="annot"><span class="annottext">s :: FilePath
</span><a href="#local-6989586621679120145"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679120144"><span class="annot"><span class="annottext">e :: FilePath
</span><a href="#local-6989586621679120144"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679120143"><span class="annot"><span class="annottext">t :: FilePath
</span><a href="#local-6989586621679120143"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(FilePath, FilePath, FilePath)
-&gt; Maybe (FilePath, FilePath, FilePath)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120145"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120144"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120143"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1960"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath, FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1961"></span><span>
</span><span id="line-1962"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-type">singleQuotesOnlyStringTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1963"></span><span class="hs-operator">&gt;</span><span> </span><span id="singleQuotesOnlyStringTok"><span class="annot"><span class="annottext">singleQuotesOnlyStringTok :: Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleQuotesOnlyStringTok"><span class="hs-identifier hs-var hs-var">singleQuotesOnlyStringTok</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe FilePath) -&gt; Parser FilePath
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120142"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120142"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1964"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120142"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1965"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#SqlString"><span class="hs-identifier hs-type">L.SqlString</span></a></span><span> </span><span class="hs-string">&quot;'&quot;</span><span> </span><span class="hs-string">&quot;'&quot;</span><span> </span><span id="local-6989586621679120141"><span class="annot"><span class="annottext">t :: FilePath
</span><a href="#local-6989586621679120141"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120141"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1966"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1967"></span><span>
</span><span id="line-1968"></span><span class="hs-identifier">This</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">support</span><span> </span><span class="hs-identifier">SQL</span><span> </span><span class="hs-identifier">strings</span><span> </span><span class="hs-keyword">where</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">write</span><span>
</span><span id="line-1969"></span><span class="hs-special">'</span><span class="hs-identifier">part</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">string'</span><span> </span><span class="hs-special">'</span><span> </span><span class="hs-identifier">another</span><span> </span><span class="hs-identifier">part'</span><span>
</span><span id="line-1970"></span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">single</span><span> </span><span class="hs-identifier">string</span><span>
</span><span id="line-1971"></span><span>
</span><span id="line-1972"></span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">allowed</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">all</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">strings</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">quoted</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-special">'</span><span> </span><span class="hs-identifier">atm</span><span class="hs-operator">.</span><span>
</span><span id="line-1973"></span><span>
</span><span id="line-1974"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#stringTokExtend"><span class="hs-identifier hs-type">stringTokExtend</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-1975"></span><span class="hs-operator">&gt;</span><span> </span><span id="stringTokExtend"><span class="annot"><span class="annottext">stringTokExtend :: ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath, FilePath, FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringTokExtend"><span class="hs-identifier hs-var hs-var">stringTokExtend</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1976"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-special">(</span><span id="local-6989586621679120140"><span class="annot"><span class="annottext">s :: FilePath
</span><a href="#local-6989586621679120140"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120139"><span class="annot"><span class="annottext">e :: FilePath
</span><a href="#local-6989586621679120139"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120138"><span class="annot"><span class="annottext">x :: FilePath
</span><a href="#local-6989586621679120138"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath, FilePath, FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringTok"><span class="hs-identifier hs-var">stringTok</span></a></span><span>
</span><span id="line-1977"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">[ParsecT
   [((FilePath, Int, Int), Token)]
   Dialect
   Identity
   (FilePath, FilePath, FilePath)]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
forall s (m :: * -&gt; *) t u a.
Stream s m t =&gt;
[ParsecT s u m a] -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">choice</span></span><span> </span><span class="hs-special">[</span><span>
</span><span id="line-1978"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-keyword">do</span><span>
</span><span id="line-1979"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">Bool -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120140"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120139"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1980"></span><span class="hs-operator">&gt;</span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679120137"><span class="annot"><span class="annottext">s' :: FilePath
</span><a href="#local-6989586621679120137"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120136"><span class="annot"><span class="annottext">e' :: FilePath
</span><a href="#local-6989586621679120136"><span class="hs-identifier hs-var">e'</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120135"><span class="annot"><span class="annottext">y :: FilePath
</span><a href="#local-6989586621679120135"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT
  [((FilePath, Int, Int), Token)]
  Dialect
  Identity
  (FilePath, FilePath, FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#stringTokExtend"><span class="hs-identifier hs-var">stringTokExtend</span></a></span><span>
</span><span id="line-1981"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">Bool -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120137"><span class="hs-identifier hs-var">s'</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120136"><span class="hs-identifier hs-var">e'</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-string">&quot;'&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1982"></span><span class="hs-operator">&gt;</span><span>          </span><span class="annot"><span class="annottext">(FilePath, FilePath, FilePath)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((FilePath, FilePath, FilePath)
 -&gt; ParsecT
      [((FilePath, Int, Int), Token)]
      Dialect
      Identity
      (FilePath, FilePath, FilePath))
-&gt; (FilePath, FilePath, FilePath)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120140"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120139"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120138"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; FilePath
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120135"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1983"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(FilePath, FilePath, FilePath)
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (FilePath, FilePath, FilePath)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120140"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120139"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120138"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1984"></span><span class="hs-operator">&gt;</span><span>         </span><span class="hs-special">]</span><span>
</span><span id="line-1985"></span><span>
</span><span id="line-1986"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#hostParamTok"><span class="hs-identifier hs-type">hostParamTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1987"></span><span class="hs-operator">&gt;</span><span> </span><span id="hostParamTok"><span class="annot"><span class="annottext">hostParamTok :: Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#hostParamTok"><span class="hs-identifier hs-var hs-var">hostParamTok</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe FilePath) -&gt; Parser FilePath
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120134"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120134"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1988"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120134"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1989"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#PrefixedVariable"><span class="hs-identifier hs-type">L.PrefixedVariable</span></a></span><span> </span><span id="local-6989586621679120132"><span class="annot"><span class="annottext">c :: Char
</span><a href="#local-6989586621679120132"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679120131"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120131"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679120132"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">Char -&gt; FilePath -&gt; FilePath
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120131"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1990"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1991"></span><span>
</span><span id="line-1992"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#positionalArgTok"><span class="hs-identifier hs-type">positionalArgTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-1993"></span><span class="hs-operator">&gt;</span><span> </span><span id="positionalArgTok"><span class="annot"><span class="annottext">positionalArgTok :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Int
</span><a href="Language.SQL.SimpleSQL.Parse.html#positionalArgTok"><span class="hs-identifier hs-var hs-var">positionalArgTok</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Int)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Int
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120130"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120130"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1994"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120130"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1995"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#PositionalArg"><span class="hs-identifier hs-type">L.PositionalArg</span></a></span><span> </span><span id="local-6989586621679120128"><span class="annot"><span class="annottext">p :: Int
</span><a href="#local-6989586621679120128"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Maybe Int
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120128"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-1996"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Int
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-1997"></span><span>
</span><span id="line-1998"></span><span>
</span><span id="line-1999"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#sqlNumberTok"><span class="hs-identifier hs-type">sqlNumberTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2000"></span><span class="hs-operator">&gt;</span><span> </span><span id="sqlNumberTok"><span class="annot"><span class="annottext">sqlNumberTok :: Bool -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#sqlNumberTok"><span class="hs-identifier hs-var hs-var">sqlNumberTok</span></a></span></span><span> </span><span id="local-6989586621679120127"><span class="annot"><span class="annottext">intOnly :: Bool
</span><a href="#local-6989586621679120127"><span class="hs-identifier hs-var">intOnly</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe FilePath) -&gt; Parser FilePath
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120126"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120126"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2001"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120126"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2002"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#SqlNumber"><span class="hs-identifier hs-type">L.SqlNumber</span></a></span><span> </span><span id="local-6989586621679120124"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120124"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679120127"><span class="hs-identifier hs-var">intOnly</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; FilePath -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">isDigit</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120124"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120124"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-2003"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-2004"></span><span>
</span><span id="line-2005"></span><span>
</span><span id="line-2006"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#symbolTok"><span class="hs-identifier hs-type">symbolTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2007"></span><span class="hs-operator">&gt;</span><span> </span><span id="symbolTok"><span class="annot"><span class="annottext">symbolTok :: Maybe FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbolTok"><span class="hs-identifier hs-var hs-var">symbolTok</span></a></span></span><span> </span><span id="local-6989586621679120119"><span class="annot"><span class="annottext">sym :: Maybe FilePath
</span><a href="#local-6989586621679120119"><span class="hs-identifier hs-var">sym</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe FilePath) -&gt; Parser FilePath
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120118"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120118"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2008"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe FilePath
</span><a href="#local-6989586621679120119"><span class="hs-identifier hs-var">sym</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120118"><span class="hs-identifier hs-var">tok</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2009"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Symbol"><span class="hs-identifier hs-type">L.Symbol</span></a></span><span> </span><span id="local-6989586621679120116"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120116"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120116"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-2010"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679120115"><span class="annot"><span class="annottext">s :: FilePath
</span><a href="#local-6989586621679120115"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Symbol"><span class="hs-identifier hs-type">L.Symbol</span></a></span><span> </span><span id="local-6989586621679120114"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120114"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120115"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120114"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120114"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-2011"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-2012"></span><span>
</span><span id="line-2013"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#identifierTok"><span class="hs-identifier hs-type">identifierTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-2014"></span><span class="hs-operator">&gt;</span><span> </span><span id="identifierTok"><span class="annot"><span class="annottext">identifierTok :: [FilePath]
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, FilePath), FilePath)
</span><a href="Language.SQL.SimpleSQL.Parse.html#identifierTok"><span class="hs-identifier hs-var hs-var">identifierTok</span></a></span></span><span> </span><span id="local-6989586621679120113"><span class="annot"><span class="annottext">blackList :: [FilePath]
</span><a href="#local-6989586621679120113"><span class="hs-identifier hs-var">blackList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe (Maybe (FilePath, FilePath), FilePath))
-&gt; ParsecT
     [((FilePath, Int, Int), Token)]
     Dialect
     Identity
     (Maybe (FilePath, FilePath), FilePath)
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120112"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120112"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2015"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120112"><span class="hs-identifier hs-var">tok</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2016"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Identifier"><span class="hs-identifier hs-type">L.Identifier</span></a></span><span> </span><span id="local-6989586621679120110"><span class="annot"><span class="annottext">q :: Maybe (FilePath, FilePath)
</span><a href="#local-6989586621679120110"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679120109"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120109"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Maybe (FilePath, FilePath), FilePath)
-&gt; Maybe (Maybe (FilePath, FilePath), FilePath)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
</span><a href="#local-6989586621679120110"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120109"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2017"></span><span class="hs-operator">&gt;</span><span>       </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Identifier"><span class="hs-identifier hs-type">L.Identifier</span></a></span><span> </span><span id="local-6989586621679120108"><span class="annot"><span class="annottext">q :: Maybe (FilePath, FilePath)
</span><a href="#local-6989586621679120108"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679120107"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120107"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120107"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`notElem`</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120113"><span class="hs-identifier hs-var">blackList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Maybe (FilePath, FilePath), FilePath)
-&gt; Maybe (Maybe (FilePath, FilePath), FilePath)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (FilePath, FilePath)
</span><a href="#local-6989586621679120108"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120107"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2018"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Maybe (FilePath, FilePath), FilePath)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-2019"></span><span>
</span><span id="line-2020"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#unquotedIdentifierTok"><span class="hs-identifier hs-type">unquotedIdentifierTok</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2021"></span><span class="hs-operator">&gt;</span><span> </span><span id="unquotedIdentifierTok"><span class="annot"><span class="annottext">unquotedIdentifierTok :: [FilePath] -&gt; Maybe FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#unquotedIdentifierTok"><span class="hs-identifier hs-var hs-var">unquotedIdentifierTok</span></a></span></span><span> </span><span id="local-6989586621679120105"><span class="annot"><span class="annottext">blackList :: [FilePath]
</span><a href="#local-6989586621679120105"><span class="hs-identifier hs-var">blackList</span></a></span></span><span> </span><span id="local-6989586621679120104"><span class="annot"><span class="annottext">kw :: Maybe FilePath
</span><a href="#local-6989586621679120104"><span class="hs-identifier hs-var">kw</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe FilePath) -&gt; Parser FilePath
forall a. (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var">mytoken</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679120103"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120103"><span class="hs-identifier hs-var">tok</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2022"></span><span class="hs-operator">&gt;</span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe FilePath
</span><a href="#local-6989586621679120104"><span class="hs-identifier hs-var">kw</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120103"><span class="hs-identifier hs-var">tok</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2023"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Identifier"><span class="hs-identifier hs-type">L.Identifier</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span id="local-6989586621679120102"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120102"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120102"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`notElem`</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120105"><span class="hs-identifier hs-var">blackList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120102"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-2024"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679120101"><span class="annot"><span class="annottext">k :: FilePath
</span><a href="#local-6989586621679120101"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Identifier"><span class="hs-identifier hs-type">L.Identifier</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span> </span><span id="local-6989586621679120100"><span class="annot"><span class="annottext">p :: FilePath
</span><a href="#local-6989586621679120100"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120101"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; FilePath -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Char) -&gt; FilePath -&gt; FilePath
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Char
</span><span class="hs-identifier hs-var">toLower</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120100"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120100"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-2025"></span><span class="hs-operator">&gt;</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-2026"></span><span>
</span><span id="line-2027"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679120926"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-type">mytoken</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Token"><span class="hs-identifier hs-type">L.Token</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679120926"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679120926"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-2028"></span><span class="hs-operator">&gt;</span><span> </span><span id="mytoken"><span class="annot"><span class="annottext">mytoken :: (Token -&gt; Maybe a) -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#mytoken"><span class="hs-identifier hs-var hs-var">mytoken</span></a></span></span><span> </span><span id="local-6989586621679120099"><span class="annot"><span class="annottext">test :: Token -&gt; Maybe a
</span><a href="#local-6989586621679120099"><span class="hs-identifier hs-var">test</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(((FilePath, Int, Int), Token) -&gt; FilePath)
-&gt; (((FilePath, Int, Int), Token) -&gt; SourcePos)
-&gt; (((FilePath, Int, Int), Token) -&gt; Maybe a)
-&gt; Parser a
forall s t a u.
Stream s Identity t =&gt;
(t -&gt; FilePath)
-&gt; (t -&gt; SourcePos) -&gt; (t -&gt; Maybe a) -&gt; Parsec s u a
</span><span class="hs-identifier hs-var">token</span></span><span> </span><span class="annot"><span class="annottext">((FilePath, Int, Int), Token) -&gt; FilePath
forall a a. Show a =&gt; (a, a) -&gt; FilePath
</span><a href="#local-6989586621679120098"><span class="hs-identifier hs-var">showToken</span></a></span><span> </span><span class="annot"><span class="annottext">((FilePath, Int, Int), Token) -&gt; SourcePos
forall b. ((FilePath, Int, Int), b) -&gt; SourcePos
</span><a href="#local-6989586621679120097"><span class="hs-identifier hs-var">posToken</span></a></span><span> </span><span class="annot"><span class="annottext">((FilePath, Int, Int), Token) -&gt; Maybe a
forall a. (a, Token) -&gt; Maybe a
</span><a href="#local-6989586621679120096"><span class="hs-identifier hs-var">testToken</span></a></span><span>
</span><span id="line-2029"></span><span class="hs-operator">&gt;</span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-2030"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120098"><span class="annot"><span class="annottext">showToken :: (a, a) -&gt; FilePath
</span><a href="#local-6989586621679120098"><span class="hs-identifier hs-var hs-var">showToken</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679120095"><span class="annot"><span class="annottext">tok :: a
</span><a href="#local-6989586621679120095"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; FilePath
forall a. Show a =&gt; a -&gt; FilePath
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679120095"><span class="hs-identifier hs-var">tok</span></a></span><span>
</span><span id="line-2031"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120097"><span class="annot"><span class="annottext">posToken :: ((FilePath, Int, Int), b) -&gt; SourcePos
</span><a href="#local-6989586621679120097"><span class="hs-identifier hs-var hs-var">posToken</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679120093"><span class="annot"><span class="annottext">a :: FilePath
</span><a href="#local-6989586621679120093"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120092"><span class="annot"><span class="annottext">b :: Int
</span><a href="#local-6989586621679120092"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679120091"><span class="annot"><span class="annottext">c :: Int
</span><a href="#local-6989586621679120091"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Int -&gt; Int -&gt; SourcePos
</span><span class="hs-identifier hs-var">newPos</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120093"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120092"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679120091"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-2032"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120096"><span class="annot"><span class="annottext">testToken :: (a, Token) -&gt; Maybe a
</span><a href="#local-6989586621679120096"><span class="hs-identifier hs-var hs-var">testToken</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679120090"><span class="annot"><span class="annottext">tok :: Token
</span><a href="#local-6989586621679120090"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe a
</span><a href="#local-6989586621679120099"><span class="hs-identifier hs-var">test</span></a></span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679120090"><span class="hs-identifier hs-var">tok</span></a></span><span>
</span><span id="line-2033"></span><span>
</span><span id="line-2034"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-type">unsignedInteger</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Integer</span></span><span>
</span><span id="line-2035"></span><span class="hs-operator">&gt;</span><span> </span><span id="unsignedInteger"><span class="annot"><span class="annottext">unsignedInteger :: ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
</span><a href="Language.SQL.SimpleSQL.Parse.html#unsignedInteger"><span class="hs-identifier hs-var hs-var">unsignedInteger</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Integer
forall a. Read a =&gt; FilePath -&gt; a
</span><span class="hs-identifier hs-var">read</span></span><span> </span><span class="annot"><span class="annottext">(FilePath -&gt; Integer)
-&gt; Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#sqlNumberTok"><span class="hs-identifier hs-var">sqlNumberTok</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
-&gt; FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Integer
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;natural number&quot;</span></span><span>
</span><span id="line-2036"></span><span>
</span><span id="line-2037"></span><span class="hs-identifier">todo</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">work</span><span> </span><span class="hs-identifier">out</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">symbol</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">better</span><span>
</span><span id="line-2038"></span><span>
</span><span id="line-2039"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-type">symbol</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2040"></span><span class="hs-operator">&gt;</span><span> </span><span id="symbol"><span class="annot"><span class="annottext">symbol :: FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var hs-var">symbol</span></a></span></span><span> </span><span id="local-6989586621679120088"><span class="annot"><span class="annottext">s :: FilePath
</span><a href="#local-6989586621679120088"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbolTok"><span class="hs-identifier hs-var">symbolTok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120088"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; FilePath -&gt; Parser FilePath
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120088"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-2041"></span><span>
</span><span id="line-2042"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-type">singleCharSymbol</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2043"></span><span class="hs-operator">&gt;</span><span> </span><span id="singleCharSymbol"><span class="annot"><span class="annottext">singleCharSymbol :: Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var hs-var">singleCharSymbol</span></a></span></span><span> </span><span id="local-6989586621679120086"><span class="annot"><span class="annottext">c :: Char
</span><a href="#local-6989586621679120086"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679120086"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser FilePath -&gt; Parser Char
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679120086"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2044"></span><span>
</span><span id="line-2045"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#questionMark"><span class="hs-identifier hs-type">questionMark</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2046"></span><span class="hs-operator">&gt;</span><span> </span><span id="questionMark"><span class="annot"><span class="annottext">questionMark :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#questionMark"><span class="hs-identifier hs-var hs-var">questionMark</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">'?'</span></span><span> </span><span class="annot"><span class="annottext">Parser Char -&gt; FilePath -&gt; Parser Char
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="hs-string">&quot;question mark&quot;</span></span><span>
</span><span id="line-2047"></span><span>
</span><span id="line-2048"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-type">openParen</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2049"></span><span class="hs-operator">&gt;</span><span> </span><span id="openParen"><span class="annot"><span class="annottext">openParen :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var hs-var">openParen</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">'('</span></span><span>
</span><span id="line-2050"></span><span>
</span><span id="line-2051"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-type">closeParen</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2052"></span><span class="hs-operator">&gt;</span><span> </span><span id="closeParen"><span class="annot"><span class="annottext">closeParen :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var hs-var">closeParen</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">')'</span></span><span>
</span><span id="line-2053"></span><span>
</span><span id="line-2054"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#openBracket"><span class="hs-identifier hs-type">openBracket</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2055"></span><span class="hs-operator">&gt;</span><span> </span><span id="openBracket"><span class="annot"><span class="annottext">openBracket :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openBracket"><span class="hs-identifier hs-var hs-var">openBracket</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">'['</span></span><span>
</span><span id="line-2056"></span><span>
</span><span id="line-2057"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#closeBracket"><span class="hs-identifier hs-type">closeBracket</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2058"></span><span class="hs-operator">&gt;</span><span> </span><span id="closeBracket"><span class="annot"><span class="annottext">closeBracket :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeBracket"><span class="hs-identifier hs-var hs-var">closeBracket</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">']'</span></span><span>
</span><span id="line-2059"></span><span>
</span><span id="line-2060"></span><span>
</span><span id="line-2061"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-type">comma</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2062"></span><span class="hs-operator">&gt;</span><span> </span><span id="comma"><span class="annot"><span class="annottext">comma :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-var hs-var">comma</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">','</span></span><span>
</span><span id="line-2063"></span><span>
</span><span id="line-2064"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#semi"><span class="hs-identifier hs-type">semi</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span>
</span><span id="line-2065"></span><span class="hs-operator">&gt;</span><span> </span><span id="semi"><span class="annot"><span class="annottext">semi :: Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#semi"><span class="hs-identifier hs-var hs-var">semi</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#singleCharSymbol"><span class="hs-identifier hs-var">singleCharSymbol</span></a></span><span> </span><span class="annot"><span class="hs-char">';'</span></span><span>
</span><span id="line-2066"></span><span>
</span><span id="line-2067"></span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">helper</span><span> </span><span class="hs-identifier">functions</span><span>
</span><span id="line-2068"></span><span>
</span><span id="line-2069"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-type">keyword</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-2070"></span><span class="hs-operator">&gt;</span><span> </span><span id="keyword"><span class="annot"><span class="annottext">keyword :: FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var hs-var">keyword</span></a></span></span><span> </span><span id="local-6989586621679120083"><span class="annot"><span class="annottext">k :: FilePath
</span><a href="#local-6989586621679120083"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[FilePath] -&gt; Maybe FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#unquotedIdentifierTok"><span class="hs-identifier hs-var">unquotedIdentifierTok</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FilePath -&gt; Maybe FilePath
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120083"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parser FilePath -&gt; FilePath -&gt; Parser FilePath
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath
</span><a href="#local-6989586621679120083"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-2071"></span><span>
</span><span id="line-2072"></span><span class="hs-identifier">helper</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">improve</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-identifier">messages</span><span>
</span><span id="line-2073"></span><span>
</span><span id="line-2074"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-type">keywords_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-2075"></span><span class="hs-operator">&gt;</span><span> </span><span id="keywords_"><span class="annot"><span class="annottext">keywords_ :: [FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keywords_"><span class="hs-identifier hs-var hs-var">keywords_</span></a></span></span><span> </span><span id="local-6989586621679120082"><span class="annot"><span class="annottext">ks :: [FilePath]
</span><a href="#local-6989586621679120082"><span class="hs-identifier hs-var">ks</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(FilePath
 -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ())
-&gt; [FilePath]
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">mapM_</span></span><span> </span><span class="annot"><span class="annottext">FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var">keyword_</span></a></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120082"><span class="hs-identifier hs-var">ks</span></a></span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
-&gt; FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall s u (m :: * -&gt; *) a.
ParsecT s u m a -&gt; FilePath -&gt; ParsecT s u m a
</span><span class="hs-operator hs-var">&lt;?&gt;</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; [FilePath] -&gt; FilePath
forall a. [a] -&gt; [[a]] -&gt; [a]
</span><span class="hs-identifier hs-var">intercalate</span></span><span> </span><span class="annot"><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">[FilePath]
</span><a href="#local-6989586621679120082"><span class="hs-identifier hs-var">ks</span></a></span><span>
</span><span id="line-2076"></span><span>
</span><span id="line-2077"></span><span>
</span><span id="line-2078"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679121143"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-type">parens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679121143"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679121143"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-2079"></span><span class="hs-operator">&gt;</span><span> </span><span id="parens"><span class="annot"><span class="annottext">parens :: Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#parens"><span class="hs-identifier hs-var hs-var">parens</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser Char -&gt; Parser Char -&gt; Parser a -&gt; Parser a
forall s (m :: * -&gt; *) t u open close a.
Stream s m t =&gt;
ParsecT s u m open
-&gt; ParsecT s u m close -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">between</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openParen"><span class="hs-identifier hs-var">openParen</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeParen"><span class="hs-identifier hs-var">closeParen</span></a></span><span>
</span><span id="line-2080"></span><span>
</span><span id="line-2081"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679120080"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-type">brackets</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679120080"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679120080"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-2082"></span><span class="hs-operator">&gt;</span><span> </span><span id="brackets"><span class="annot"><span class="annottext">brackets :: Parser a -&gt; Parser a
</span><a href="Language.SQL.SimpleSQL.Parse.html#brackets"><span class="hs-identifier hs-var hs-var">brackets</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser Char -&gt; Parser Char -&gt; Parser a -&gt; Parser a
forall s (m :: * -&gt; *) t u open close a.
Stream s m t =&gt;
ParsecT s u m open
-&gt; ParsecT s u m close -&gt; ParsecT s u m a -&gt; ParsecT s u m a
</span><span class="hs-identifier hs-var">between</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#openBracket"><span class="hs-identifier hs-var">openBracket</span></a></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#closeBracket"><span class="hs-identifier hs-var">closeBracket</span></a></span><span>
</span><span id="line-2083"></span><span>
</span><span id="line-2084"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679120079"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-type">commaSep</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679120079"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679120079"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-2085"></span><span class="hs-operator">&gt;</span><span> </span><span id="commaSep"><span class="annot"><span class="annottext">commaSep :: Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep"><span class="hs-identifier hs-var hs-var">commaSep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser a -&gt; Parser Char -&gt; Parser [a]
forall s (m :: * -&gt; *) t u a sep.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m sep -&gt; ParsecT s u m [a]
</span><span class="hs-operator hs-var">`sepBy`</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2086"></span><span>
</span><span id="line-2087"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-type">keyword_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-2088"></span><span class="hs-operator">&gt;</span><span> </span><span id="keyword_"><span class="annot"><span class="annottext">keyword_ :: FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword_"><span class="hs-identifier hs-var hs-var">keyword_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">(Parser FilePath
 -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ())
-&gt; (FilePath -&gt; Parser FilePath)
-&gt; FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#keyword"><span class="hs-identifier hs-var">keyword</span></a></span><span>
</span><span id="line-2089"></span><span>
</span><span id="line-2090"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-type">symbol_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-2091"></span><span class="hs-operator">&gt;</span><span> </span><span id="symbol_"><span class="annot"><span class="annottext">symbol_ :: FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol_"><span class="hs-identifier hs-var hs-var">symbol_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parser FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">(Parser FilePath
 -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ())
-&gt; (FilePath -&gt; Parser FilePath)
-&gt; FilePath
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">FilePath -&gt; Parser FilePath
</span><a href="Language.SQL.SimpleSQL.Parse.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span>
</span><span id="line-2092"></span><span>
</span><span id="line-2093"></span><span class="hs-operator">&gt;</span><span> </span><span id="local-6989586621679121142"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-type">commaSep1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679121142"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679121142"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-2094"></span><span class="hs-operator">&gt;</span><span> </span><span id="commaSep1"><span class="annot"><span class="annottext">commaSep1 :: Parser a -&gt; Parser [a]
</span><a href="Language.SQL.SimpleSQL.Parse.html#commaSep1"><span class="hs-identifier hs-var hs-var">commaSep1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parser a -&gt; Parser Char -&gt; Parser [a]
forall s (m :: * -&gt; *) t u a sep.
Stream s m t =&gt;
ParsecT s u m a -&gt; ParsecT s u m sep -&gt; ParsecT s u m [a]
</span><span class="hs-operator hs-var">`sepBy1`</span></span><span> </span><span class="annot"><span class="annottext">Parser Char
</span><a href="Language.SQL.SimpleSQL.Parse.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2095"></span><span>
</span><span id="line-2096"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#blacklist"><span class="hs-identifier hs-type">blacklist</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-2097"></span><span class="hs-operator">&gt;</span><span> </span><span id="blacklist"><span class="annot"><span class="annottext">blacklist :: Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Parse.html#blacklist"><span class="hs-identifier hs-var hs-var">blacklist</span></a></span></span><span> </span><span id="local-6989586621679120078"><span class="annot"><span class="annottext">d :: Dialect
</span><a href="#local-6989586621679120078"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Dialect -&gt; [FilePath]
</span><a href="Language.SQL.SimpleSQL.Dialect.html#diKeywords"><span class="hs-identifier hs-var hs-var">diKeywords</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120078"><span class="hs-identifier hs-var">d</span></a></span><span>
</span><span id="line-2098"></span><span>
</span><span id="line-2099"></span><span class="hs-identifier">These</span><span> </span><span class="hs-identifier">blacklisted</span><span> </span><span class="hs-identifier">names</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">mostly</span><span> </span><span class="hs-identifier">needed</span><span> </span><span class="hs-identifier">when</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">something</span><span> </span><span class="hs-identifier">with</span><span>
</span><span id="line-2100"></span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">optional</span><span> </span><span class="hs-identifier">alias</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">t</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">If</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">write</span><span> </span><span class="hs-identifier">select</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">from</span><span>
</span><span id="line-2101"></span><span class="hs-identifier">t</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">we</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">make</span><span> </span><span class="hs-identifier">sure</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">isn't</span><span> </span><span class="hs-identifier">parsed</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">alias</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">I'm</span><span> </span><span class="hs-identifier">not</span><span>
</span><span id="line-2102"></span><span class="hs-identifier">sure</span><span> </span><span class="hs-identifier">what</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">places</span><span> </span><span class="hs-identifier">strictly</span><span> </span><span class="hs-identifier">need</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">blacklist</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">theory</span><span> </span><span class="hs-identifier">it</span><span>
</span><span id="line-2103"></span><span class="hs-identifier">could</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">tuned</span><span> </span><span class="hs-identifier">differently</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">each</span><span> </span><span class="hs-identifier">place</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">identifierString</span><span class="hs-operator">/</span><span>
</span><span id="line-2104"></span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">parsers</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">blacklist</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">bare</span><span>
</span><span id="line-2105"></span><span class="hs-identifier">minimum</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Something</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">might</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">needed</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">dialect</span><span> </span><span class="hs-identifier">support</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">even</span><span>
</span><span id="line-2106"></span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">pretty</span><span> </span><span class="hs-identifier">silly</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">use</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">unquoted</span><span> </span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">when</span><span>
</span><span id="line-2107"></span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">quoting</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">well</span><span class="hs-operator">.</span><span>
</span><span id="line-2108"></span><span>
</span><span id="line-2109"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-identifier">has</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">weird</span><span> </span><span class="hs-identifier">mix</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">reserved</span><span> </span><span class="hs-identifier">keywords</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">unreserved</span><span>
</span><span id="line-2110"></span><span class="hs-identifier">keywords</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">I'm</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">sure</span><span> </span><span class="hs-identifier">what</span><span> </span><span class="hs-identifier">exactly</span><span> </span><span class="hs-identifier">being</span><span> </span><span class="hs-identifier">an</span><span> </span><span class="hs-identifier">unreserved</span><span> </span><span class="hs-identifier">keyword</span><span>
</span><span id="line-2111"></span><span class="hs-identifier">means</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-2112"></span><span>
</span><span id="line-2113"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">current</span><span> </span><span class="hs-identifier">approach</span><span> </span><span class="hs-identifier">tries</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">everything</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">only</span><span>
</span><span id="line-2114"></span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">list</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">so</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">other</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-keyword">if</span><span>
</span><span id="line-2115"></span><span class="hs-identifier">quoted</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">If</span><span> </span><span class="hs-identifier">something</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">ansi</span><span> </span><span class="hs-identifier">keyword'</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">appears</span><span> </span><span class="hs-identifier">only</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">an</span><span>
</span><span id="line-2116"></span><span class="hs-identifier">identifier</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">function</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">syntax</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">something</span><span>
</span><span id="line-2117"></span><span class="hs-identifier">that</span><span> </span><span class="hs-identifier">looks</span><span> </span><span class="hs-identifier">identical</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">this</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">isn't</span><span> </span><span class="hs-identifier">treated</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">at</span><span>
</span><span id="line-2118"></span><span class="hs-identifier">all</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">When</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">some</span><span> </span><span class="hs-identifier">overlap</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">set'</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">there</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">either</span><span>
</span><span id="line-2119"></span><span class="hs-identifier">special</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">code</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">handle</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-identifier">set</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">it</span><span>
</span><span id="line-2120"></span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">treated</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">not</span><span> </span><span class="hs-identifier">perfect</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">it</span><span> </span><span class="hs-identifier">more</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">less</span><span>
</span><span id="line-2121"></span><span class="hs-identifier">works</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ok</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">now</span><span class="hs-special">)</span><span class="hs-operator">.</span><span>
</span><span id="line-2122"></span><span>
</span><span id="line-2123"></span><span class="hs-identifier">An</span><span> </span><span class="hs-identifier">exception</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">standard</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">names</span><span> </span><span class="hs-identifier">are</span><span> </span><span class="hs-identifier">considered</span><span> </span><span class="hs-keyword">as</span><span>
</span><span id="line-2124"></span><span class="hs-identifier">keywords</span><span> </span><span class="hs-identifier">at</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">moment</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">with</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">special</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">parser</span><span> </span><span class="hs-identifier">to</span><span>
</span><span id="line-2125"></span><span class="hs-identifier">make</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">work</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">isn't</span><span> </span><span class="hs-identifier">necessary</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">bad</span><span> </span><span class="hs-identifier">idea</span><span class="hs-operator">.</span><span>
</span><span id="line-2126"></span><span>
</span><span id="line-2127"></span><span class="hs-identifier">It</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">possible</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">have</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">problem</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">you</span><span> </span><span class="hs-identifier">remove</span><span> </span><span class="hs-identifier">something</span><span> </span><span class="hs-identifier">which</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-2128"></span><span class="hs-identifier">keyword</span><span> </span><span class="hs-identifier">from</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">list</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">and</span><span> </span><span class="hs-identifier">still</span><span> </span><span class="hs-identifier">want</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">statements</span><span> </span><span class="hs-identifier">using</span><span> </span><span class="hs-identifier">it</span><span>
</span><span id="line-2129"></span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">keyword</span><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-keyword">instance</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">removing</span><span> </span><span class="hs-identifier">things</span><span> </span><span class="hs-identifier">like</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">from'</span><span> </span><span class="hs-identifier">or</span><span> </span><span class="hs-special">'</span><span class="hs-identifier">as'</span><span class="hs-special">,</span><span>
</span><span id="line-2130"></span><span class="hs-identifier">will</span><span> </span><span class="hs-identifier">likely</span><span> </span><span class="hs-identifier">mean</span><span> </span><span class="hs-identifier">many</span><span> </span><span class="hs-identifier">things</span><span> </span><span class="hs-identifier">don't</span><span> </span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">anymore</span><span class="hs-operator">.</span><span>
</span><span id="line-2131"></span><span>
</span><span id="line-2132"></span><span>
</span><span id="line-2133"></span><span>
</span><span id="line-2134"></span><span class="hs-comment">-----------</span><span>
</span><span id="line-2135"></span><span>
</span><span id="line-2136"></span><span class="hs-identifier">Used</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">make</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">dialect</span><span> </span><span class="hs-identifier">available</span><span> </span><span class="hs-identifier">during</span><span> </span><span class="hs-identifier">parsing</span><span> </span><span class="hs-identifier">so</span><span> </span><span class="hs-identifier">different</span><span> </span><span class="hs-identifier">parsers</span><span>
</span><span id="line-2137"></span><span class="hs-identifier">can</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">different</span><span> </span><span class="hs-identifier">dialects</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Not</span><span> </span><span class="hs-identifier">sure</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">this</span><span> </span><span class="hs-identifier">is</span><span> </span><span class="hs-identifier">the</span><span> </span><span class="hs-identifier">best</span><span> </span><span class="hs-identifier">way</span><span>
</span><span id="line-2138"></span><span class="hs-identifier">to</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">it</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">but</span><span> </span><span class="hs-identifier">it's</span><span> </span><span class="hs-identifier">convenient</span><span>
</span><span id="line-2139"></span><span>
</span><span id="line-2140"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">type</span><span> </span><span id="ParseState"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#ParseState"><span class="hs-identifier hs-var">ParseState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span>
</span><span id="line-2141"></span><span>
</span><span id="line-2142"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">type</span><span> </span><span id="Token"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Token"><span class="hs-identifier hs-var">Token</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><a href="Language.SQL.SimpleSQL.Lex.html#Token"><span class="hs-identifier hs-type">L.Token</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2143"></span><span>
</span><span id="line-2144"></span><span class="hs-operator">&gt;</span><span> </span><span class="hs-keyword">type</span><span> </span><span id="Parser"><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-var">Parser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">GenParser</span></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#ParseState"><span class="hs-identifier hs-type">ParseState</span></a></span><span>
</span><span id="line-2145"></span><span>
</span><span id="line-2146"></span><span class="hs-operator">&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#guardDialect"><span class="hs-identifier hs-type">guardDialect</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.SQL.SimpleSQL.Dialect.html#Dialect"><span class="hs-identifier hs-type">Dialect</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.SQL.SimpleSQL.Parse.html#Parser"><span class="hs-identifier hs-type">Parser</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-2147"></span><span class="hs-operator">&gt;</span><span> </span><span id="guardDialect"><span class="annot"><span class="annottext">guardDialect :: (Dialect -&gt; Bool)
-&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
</span><a href="Language.SQL.SimpleSQL.Parse.html#guardDialect"><span class="hs-identifier hs-var hs-var">guardDialect</span></a></span></span><span> </span><span id="local-6989586621679120076"><span class="annot"><span class="annottext">f :: Dialect -&gt; Bool
</span><a href="#local-6989586621679120076"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-2148"></span><span class="hs-operator">&gt;</span><span>     </span><span id="local-6989586621679120075"><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120075"><span class="hs-identifier hs-var">d</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ParsecT [((FilePath, Int, Int), Token)] Dialect Identity Dialect
forall (m :: * -&gt; *) s u. Monad m =&gt; ParsecT s u m u
</span><span class="hs-identifier hs-var">getState</span></span><span>
</span><span id="line-2149"></span><span class="hs-operator">&gt;</span><span>     </span><span class="annot"><span class="annottext">Bool -&gt; ParsecT [((FilePath, Int, Int), Token)] Dialect Identity ()
forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Dialect -&gt; Bool
</span><a href="#local-6989586621679120076"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Dialect
</span><a href="#local-6989586621679120075"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2150"></span><span>
</span><span id="line-2151"></span><span class="hs-identifier">The</span><span> </span><span class="hs-identifier">dialect</span><span> </span><span class="hs-identifier">stuff</span><span> </span><span class="hs-identifier">could</span><span> </span><span class="hs-identifier">also</span><span> </span><span class="hs-identifier">be</span><span> </span><span class="hs-identifier">used</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-identifier">custom</span><span> </span><span class="hs-identifier">options</span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">e</span><span class="hs-operator">.</span><span class="hs-identifier">g</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">to</span><span> </span><span class="hs-identifier">only</span><span>
</span><span id="line-2152"></span><span class="hs-identifier">parse</span><span> </span><span class="hs-identifier">dml</span><span> </span><span class="hs-identifier">for</span><span> </span><span class="hs-keyword">instance</span><span class="hs-operator">.</span><span>
</span><span id="line-2153"></span></pre></body></html>